import {
  require_react
} from "./chunk-ABDRZE5M.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-LFBQMW2U.js";

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    (function(nacl5) {
      "use strict";
      var gf = function(init) {
        var i17, r17 = new Float64Array(16);
        if (init)
          for (i17 = 0; i17 < init.length; i17++)
            r17[i17] = init[i17];
        return r17;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D4 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X2 = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y3 = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I6 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x5, i17, h7, l9) {
        x5[i17] = h7 >> 24 & 255;
        x5[i17 + 1] = h7 >> 16 & 255;
        x5[i17 + 2] = h7 >> 8 & 255;
        x5[i17 + 3] = h7 & 255;
        x5[i17 + 4] = l9 >> 24 & 255;
        x5[i17 + 5] = l9 >> 16 & 255;
        x5[i17 + 6] = l9 >> 8 & 255;
        x5[i17 + 7] = l9 & 255;
      }
      function vn(x5, xi, y6, yi, n17) {
        var i17, d15 = 0;
        for (i17 = 0; i17 < n17; i17++)
          d15 |= x5[xi + i17] ^ y6[yi + i17];
        return (1 & d15 - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x5, xi, y6, yi) {
        return vn(x5, xi, y6, yi, 16);
      }
      function crypto_verify_32(x5, xi, y6, yi) {
        return vn(x5, xi, y6, yi, 32);
      }
      function core_salsa20(o18, p12, k4, c11) {
        var j0 = c11[0] & 255 | (c11[1] & 255) << 8 | (c11[2] & 255) << 16 | (c11[3] & 255) << 24, j1 = k4[0] & 255 | (k4[1] & 255) << 8 | (k4[2] & 255) << 16 | (k4[3] & 255) << 24, j2 = k4[4] & 255 | (k4[5] & 255) << 8 | (k4[6] & 255) << 16 | (k4[7] & 255) << 24, j3 = k4[8] & 255 | (k4[9] & 255) << 8 | (k4[10] & 255) << 16 | (k4[11] & 255) << 24, j4 = k4[12] & 255 | (k4[13] & 255) << 8 | (k4[14] & 255) << 16 | (k4[15] & 255) << 24, j5 = c11[4] & 255 | (c11[5] & 255) << 8 | (c11[6] & 255) << 16 | (c11[7] & 255) << 24, j6 = p12[0] & 255 | (p12[1] & 255) << 8 | (p12[2] & 255) << 16 | (p12[3] & 255) << 24, j7 = p12[4] & 255 | (p12[5] & 255) << 8 | (p12[6] & 255) << 16 | (p12[7] & 255) << 24, j8 = p12[8] & 255 | (p12[9] & 255) << 8 | (p12[10] & 255) << 16 | (p12[11] & 255) << 24, j9 = p12[12] & 255 | (p12[13] & 255) << 8 | (p12[14] & 255) << 16 | (p12[15] & 255) << 24, j10 = c11[8] & 255 | (c11[9] & 255) << 8 | (c11[10] & 255) << 16 | (c11[11] & 255) << 24, j11 = k4[16] & 255 | (k4[17] & 255) << 8 | (k4[18] & 255) << 16 | (k4[19] & 255) << 24, j12 = k4[20] & 255 | (k4[21] & 255) << 8 | (k4[22] & 255) << 16 | (k4[23] & 255) << 24, j13 = k4[24] & 255 | (k4[25] & 255) << 8 | (k4[26] & 255) << 16 | (k4[27] & 255) << 24, j14 = k4[28] & 255 | (k4[29] & 255) << 8 | (k4[30] & 255) << 16 | (k4[31] & 255) << 24, j15 = c11[12] & 255 | (c11[13] & 255) << 8 | (c11[14] & 255) << 16 | (c11[15] & 255) << 24;
        var x0 = j0, x1 = j1, x22 = j2, x32 = j3, x42 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u5;
        for (var i17 = 0; i17 < 20; i17 += 2) {
          u5 = x0 + x12 | 0;
          x42 ^= u5 << 7 | u5 >>> 32 - 7;
          u5 = x42 + x0 | 0;
          x8 ^= u5 << 9 | u5 >>> 32 - 9;
          u5 = x8 + x42 | 0;
          x12 ^= u5 << 13 | u5 >>> 32 - 13;
          u5 = x12 + x8 | 0;
          x0 ^= u5 << 18 | u5 >>> 32 - 18;
          u5 = x5 + x1 | 0;
          x9 ^= u5 << 7 | u5 >>> 32 - 7;
          u5 = x9 + x5 | 0;
          x13 ^= u5 << 9 | u5 >>> 32 - 9;
          u5 = x13 + x9 | 0;
          x1 ^= u5 << 13 | u5 >>> 32 - 13;
          u5 = x1 + x13 | 0;
          x5 ^= u5 << 18 | u5 >>> 32 - 18;
          u5 = x10 + x6 | 0;
          x14 ^= u5 << 7 | u5 >>> 32 - 7;
          u5 = x14 + x10 | 0;
          x22 ^= u5 << 9 | u5 >>> 32 - 9;
          u5 = x22 + x14 | 0;
          x6 ^= u5 << 13 | u5 >>> 32 - 13;
          u5 = x6 + x22 | 0;
          x10 ^= u5 << 18 | u5 >>> 32 - 18;
          u5 = x15 + x11 | 0;
          x32 ^= u5 << 7 | u5 >>> 32 - 7;
          u5 = x32 + x15 | 0;
          x7 ^= u5 << 9 | u5 >>> 32 - 9;
          u5 = x7 + x32 | 0;
          x11 ^= u5 << 13 | u5 >>> 32 - 13;
          u5 = x11 + x7 | 0;
          x15 ^= u5 << 18 | u5 >>> 32 - 18;
          u5 = x0 + x32 | 0;
          x1 ^= u5 << 7 | u5 >>> 32 - 7;
          u5 = x1 + x0 | 0;
          x22 ^= u5 << 9 | u5 >>> 32 - 9;
          u5 = x22 + x1 | 0;
          x32 ^= u5 << 13 | u5 >>> 32 - 13;
          u5 = x32 + x22 | 0;
          x0 ^= u5 << 18 | u5 >>> 32 - 18;
          u5 = x5 + x42 | 0;
          x6 ^= u5 << 7 | u5 >>> 32 - 7;
          u5 = x6 + x5 | 0;
          x7 ^= u5 << 9 | u5 >>> 32 - 9;
          u5 = x7 + x6 | 0;
          x42 ^= u5 << 13 | u5 >>> 32 - 13;
          u5 = x42 + x7 | 0;
          x5 ^= u5 << 18 | u5 >>> 32 - 18;
          u5 = x10 + x9 | 0;
          x11 ^= u5 << 7 | u5 >>> 32 - 7;
          u5 = x11 + x10 | 0;
          x8 ^= u5 << 9 | u5 >>> 32 - 9;
          u5 = x8 + x11 | 0;
          x9 ^= u5 << 13 | u5 >>> 32 - 13;
          u5 = x9 + x8 | 0;
          x10 ^= u5 << 18 | u5 >>> 32 - 18;
          u5 = x15 + x14 | 0;
          x12 ^= u5 << 7 | u5 >>> 32 - 7;
          u5 = x12 + x15 | 0;
          x13 ^= u5 << 9 | u5 >>> 32 - 9;
          u5 = x13 + x12 | 0;
          x14 ^= u5 << 13 | u5 >>> 32 - 13;
          u5 = x14 + x13 | 0;
          x15 ^= u5 << 18 | u5 >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x22 = x22 + j2 | 0;
        x32 = x32 + j3 | 0;
        x42 = x42 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o18[0] = x0 >>> 0 & 255;
        o18[1] = x0 >>> 8 & 255;
        o18[2] = x0 >>> 16 & 255;
        o18[3] = x0 >>> 24 & 255;
        o18[4] = x1 >>> 0 & 255;
        o18[5] = x1 >>> 8 & 255;
        o18[6] = x1 >>> 16 & 255;
        o18[7] = x1 >>> 24 & 255;
        o18[8] = x22 >>> 0 & 255;
        o18[9] = x22 >>> 8 & 255;
        o18[10] = x22 >>> 16 & 255;
        o18[11] = x22 >>> 24 & 255;
        o18[12] = x32 >>> 0 & 255;
        o18[13] = x32 >>> 8 & 255;
        o18[14] = x32 >>> 16 & 255;
        o18[15] = x32 >>> 24 & 255;
        o18[16] = x42 >>> 0 & 255;
        o18[17] = x42 >>> 8 & 255;
        o18[18] = x42 >>> 16 & 255;
        o18[19] = x42 >>> 24 & 255;
        o18[20] = x5 >>> 0 & 255;
        o18[21] = x5 >>> 8 & 255;
        o18[22] = x5 >>> 16 & 255;
        o18[23] = x5 >>> 24 & 255;
        o18[24] = x6 >>> 0 & 255;
        o18[25] = x6 >>> 8 & 255;
        o18[26] = x6 >>> 16 & 255;
        o18[27] = x6 >>> 24 & 255;
        o18[28] = x7 >>> 0 & 255;
        o18[29] = x7 >>> 8 & 255;
        o18[30] = x7 >>> 16 & 255;
        o18[31] = x7 >>> 24 & 255;
        o18[32] = x8 >>> 0 & 255;
        o18[33] = x8 >>> 8 & 255;
        o18[34] = x8 >>> 16 & 255;
        o18[35] = x8 >>> 24 & 255;
        o18[36] = x9 >>> 0 & 255;
        o18[37] = x9 >>> 8 & 255;
        o18[38] = x9 >>> 16 & 255;
        o18[39] = x9 >>> 24 & 255;
        o18[40] = x10 >>> 0 & 255;
        o18[41] = x10 >>> 8 & 255;
        o18[42] = x10 >>> 16 & 255;
        o18[43] = x10 >>> 24 & 255;
        o18[44] = x11 >>> 0 & 255;
        o18[45] = x11 >>> 8 & 255;
        o18[46] = x11 >>> 16 & 255;
        o18[47] = x11 >>> 24 & 255;
        o18[48] = x12 >>> 0 & 255;
        o18[49] = x12 >>> 8 & 255;
        o18[50] = x12 >>> 16 & 255;
        o18[51] = x12 >>> 24 & 255;
        o18[52] = x13 >>> 0 & 255;
        o18[53] = x13 >>> 8 & 255;
        o18[54] = x13 >>> 16 & 255;
        o18[55] = x13 >>> 24 & 255;
        o18[56] = x14 >>> 0 & 255;
        o18[57] = x14 >>> 8 & 255;
        o18[58] = x14 >>> 16 & 255;
        o18[59] = x14 >>> 24 & 255;
        o18[60] = x15 >>> 0 & 255;
        o18[61] = x15 >>> 8 & 255;
        o18[62] = x15 >>> 16 & 255;
        o18[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o18, p12, k4, c11) {
        var j0 = c11[0] & 255 | (c11[1] & 255) << 8 | (c11[2] & 255) << 16 | (c11[3] & 255) << 24, j1 = k4[0] & 255 | (k4[1] & 255) << 8 | (k4[2] & 255) << 16 | (k4[3] & 255) << 24, j2 = k4[4] & 255 | (k4[5] & 255) << 8 | (k4[6] & 255) << 16 | (k4[7] & 255) << 24, j3 = k4[8] & 255 | (k4[9] & 255) << 8 | (k4[10] & 255) << 16 | (k4[11] & 255) << 24, j4 = k4[12] & 255 | (k4[13] & 255) << 8 | (k4[14] & 255) << 16 | (k4[15] & 255) << 24, j5 = c11[4] & 255 | (c11[5] & 255) << 8 | (c11[6] & 255) << 16 | (c11[7] & 255) << 24, j6 = p12[0] & 255 | (p12[1] & 255) << 8 | (p12[2] & 255) << 16 | (p12[3] & 255) << 24, j7 = p12[4] & 255 | (p12[5] & 255) << 8 | (p12[6] & 255) << 16 | (p12[7] & 255) << 24, j8 = p12[8] & 255 | (p12[9] & 255) << 8 | (p12[10] & 255) << 16 | (p12[11] & 255) << 24, j9 = p12[12] & 255 | (p12[13] & 255) << 8 | (p12[14] & 255) << 16 | (p12[15] & 255) << 24, j10 = c11[8] & 255 | (c11[9] & 255) << 8 | (c11[10] & 255) << 16 | (c11[11] & 255) << 24, j11 = k4[16] & 255 | (k4[17] & 255) << 8 | (k4[18] & 255) << 16 | (k4[19] & 255) << 24, j12 = k4[20] & 255 | (k4[21] & 255) << 8 | (k4[22] & 255) << 16 | (k4[23] & 255) << 24, j13 = k4[24] & 255 | (k4[25] & 255) << 8 | (k4[26] & 255) << 16 | (k4[27] & 255) << 24, j14 = k4[28] & 255 | (k4[29] & 255) << 8 | (k4[30] & 255) << 16 | (k4[31] & 255) << 24, j15 = c11[12] & 255 | (c11[13] & 255) << 8 | (c11[14] & 255) << 16 | (c11[15] & 255) << 24;
        var x0 = j0, x1 = j1, x22 = j2, x32 = j3, x42 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u5;
        for (var i17 = 0; i17 < 20; i17 += 2) {
          u5 = x0 + x12 | 0;
          x42 ^= u5 << 7 | u5 >>> 32 - 7;
          u5 = x42 + x0 | 0;
          x8 ^= u5 << 9 | u5 >>> 32 - 9;
          u5 = x8 + x42 | 0;
          x12 ^= u5 << 13 | u5 >>> 32 - 13;
          u5 = x12 + x8 | 0;
          x0 ^= u5 << 18 | u5 >>> 32 - 18;
          u5 = x5 + x1 | 0;
          x9 ^= u5 << 7 | u5 >>> 32 - 7;
          u5 = x9 + x5 | 0;
          x13 ^= u5 << 9 | u5 >>> 32 - 9;
          u5 = x13 + x9 | 0;
          x1 ^= u5 << 13 | u5 >>> 32 - 13;
          u5 = x1 + x13 | 0;
          x5 ^= u5 << 18 | u5 >>> 32 - 18;
          u5 = x10 + x6 | 0;
          x14 ^= u5 << 7 | u5 >>> 32 - 7;
          u5 = x14 + x10 | 0;
          x22 ^= u5 << 9 | u5 >>> 32 - 9;
          u5 = x22 + x14 | 0;
          x6 ^= u5 << 13 | u5 >>> 32 - 13;
          u5 = x6 + x22 | 0;
          x10 ^= u5 << 18 | u5 >>> 32 - 18;
          u5 = x15 + x11 | 0;
          x32 ^= u5 << 7 | u5 >>> 32 - 7;
          u5 = x32 + x15 | 0;
          x7 ^= u5 << 9 | u5 >>> 32 - 9;
          u5 = x7 + x32 | 0;
          x11 ^= u5 << 13 | u5 >>> 32 - 13;
          u5 = x11 + x7 | 0;
          x15 ^= u5 << 18 | u5 >>> 32 - 18;
          u5 = x0 + x32 | 0;
          x1 ^= u5 << 7 | u5 >>> 32 - 7;
          u5 = x1 + x0 | 0;
          x22 ^= u5 << 9 | u5 >>> 32 - 9;
          u5 = x22 + x1 | 0;
          x32 ^= u5 << 13 | u5 >>> 32 - 13;
          u5 = x32 + x22 | 0;
          x0 ^= u5 << 18 | u5 >>> 32 - 18;
          u5 = x5 + x42 | 0;
          x6 ^= u5 << 7 | u5 >>> 32 - 7;
          u5 = x6 + x5 | 0;
          x7 ^= u5 << 9 | u5 >>> 32 - 9;
          u5 = x7 + x6 | 0;
          x42 ^= u5 << 13 | u5 >>> 32 - 13;
          u5 = x42 + x7 | 0;
          x5 ^= u5 << 18 | u5 >>> 32 - 18;
          u5 = x10 + x9 | 0;
          x11 ^= u5 << 7 | u5 >>> 32 - 7;
          u5 = x11 + x10 | 0;
          x8 ^= u5 << 9 | u5 >>> 32 - 9;
          u5 = x8 + x11 | 0;
          x9 ^= u5 << 13 | u5 >>> 32 - 13;
          u5 = x9 + x8 | 0;
          x10 ^= u5 << 18 | u5 >>> 32 - 18;
          u5 = x15 + x14 | 0;
          x12 ^= u5 << 7 | u5 >>> 32 - 7;
          u5 = x12 + x15 | 0;
          x13 ^= u5 << 9 | u5 >>> 32 - 9;
          u5 = x13 + x12 | 0;
          x14 ^= u5 << 13 | u5 >>> 32 - 13;
          u5 = x14 + x13 | 0;
          x15 ^= u5 << 18 | u5 >>> 32 - 18;
        }
        o18[0] = x0 >>> 0 & 255;
        o18[1] = x0 >>> 8 & 255;
        o18[2] = x0 >>> 16 & 255;
        o18[3] = x0 >>> 24 & 255;
        o18[4] = x5 >>> 0 & 255;
        o18[5] = x5 >>> 8 & 255;
        o18[6] = x5 >>> 16 & 255;
        o18[7] = x5 >>> 24 & 255;
        o18[8] = x10 >>> 0 & 255;
        o18[9] = x10 >>> 8 & 255;
        o18[10] = x10 >>> 16 & 255;
        o18[11] = x10 >>> 24 & 255;
        o18[12] = x15 >>> 0 & 255;
        o18[13] = x15 >>> 8 & 255;
        o18[14] = x15 >>> 16 & 255;
        o18[15] = x15 >>> 24 & 255;
        o18[16] = x6 >>> 0 & 255;
        o18[17] = x6 >>> 8 & 255;
        o18[18] = x6 >>> 16 & 255;
        o18[19] = x6 >>> 24 & 255;
        o18[20] = x7 >>> 0 & 255;
        o18[21] = x7 >>> 8 & 255;
        o18[22] = x7 >>> 16 & 255;
        o18[23] = x7 >>> 24 & 255;
        o18[24] = x8 >>> 0 & 255;
        o18[25] = x8 >>> 8 & 255;
        o18[26] = x8 >>> 16 & 255;
        o18[27] = x8 >>> 24 & 255;
        o18[28] = x9 >>> 0 & 255;
        o18[29] = x9 >>> 8 & 255;
        o18[30] = x9 >>> 16 & 255;
        o18[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k4, c11) {
        core_salsa20(out, inp, k4, c11);
      }
      function crypto_core_hsalsa20(out, inp, k4, c11) {
        core_hsalsa20(out, inp, k4, c11);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c11, cpos, m12, mpos, b5, n17, k4) {
        var z = new Uint8Array(16), x5 = new Uint8Array(64);
        var u5, i17;
        for (i17 = 0; i17 < 16; i17++)
          z[i17] = 0;
        for (i17 = 0; i17 < 8; i17++)
          z[i17] = n17[i17];
        while (b5 >= 64) {
          crypto_core_salsa20(x5, z, k4, sigma);
          for (i17 = 0; i17 < 64; i17++)
            c11[cpos + i17] = m12[mpos + i17] ^ x5[i17];
          u5 = 1;
          for (i17 = 8; i17 < 16; i17++) {
            u5 = u5 + (z[i17] & 255) | 0;
            z[i17] = u5 & 255;
            u5 >>>= 8;
          }
          b5 -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b5 > 0) {
          crypto_core_salsa20(x5, z, k4, sigma);
          for (i17 = 0; i17 < b5; i17++)
            c11[cpos + i17] = m12[mpos + i17] ^ x5[i17];
        }
        return 0;
      }
      function crypto_stream_salsa20(c11, cpos, b5, n17, k4) {
        var z = new Uint8Array(16), x5 = new Uint8Array(64);
        var u5, i17;
        for (i17 = 0; i17 < 16; i17++)
          z[i17] = 0;
        for (i17 = 0; i17 < 8; i17++)
          z[i17] = n17[i17];
        while (b5 >= 64) {
          crypto_core_salsa20(x5, z, k4, sigma);
          for (i17 = 0; i17 < 64; i17++)
            c11[cpos + i17] = x5[i17];
          u5 = 1;
          for (i17 = 8; i17 < 16; i17++) {
            u5 = u5 + (z[i17] & 255) | 0;
            z[i17] = u5 & 255;
            u5 >>>= 8;
          }
          b5 -= 64;
          cpos += 64;
        }
        if (b5 > 0) {
          crypto_core_salsa20(x5, z, k4, sigma);
          for (i17 = 0; i17 < b5; i17++)
            c11[cpos + i17] = x5[i17];
        }
        return 0;
      }
      function crypto_stream(c11, cpos, d15, n17, k4) {
        var s9 = new Uint8Array(32);
        crypto_core_hsalsa20(s9, n17, k4, sigma);
        var sn = new Uint8Array(8);
        for (var i17 = 0; i17 < 8; i17++)
          sn[i17] = n17[i17 + 16];
        return crypto_stream_salsa20(c11, cpos, d15, sn, s9);
      }
      function crypto_stream_xor(c11, cpos, m12, mpos, d15, n17, k4) {
        var s9 = new Uint8Array(32);
        crypto_core_hsalsa20(s9, n17, k4, sigma);
        var sn = new Uint8Array(8);
        for (var i17 = 0; i17 < 8; i17++)
          sn[i17] = n17[i17 + 16];
        return crypto_stream_salsa20_xor(c11, cpos, m12, mpos, d15, sn, s9);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t22, t32, t42, t52, t62, t72;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t22 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t22 << 6) & 7939;
        t32 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t22 >>> 7 | t32 << 9) & 8191;
        t42 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t32 >>> 4 | t42 << 12) & 255;
        this.r[5] = t42 >>> 1 & 8190;
        t52 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t42 >>> 14 | t52 << 2) & 8191;
        t62 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t52 >>> 11 | t62 << 5) & 8065;
        t72 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t62 >>> 8 | t72 << 8) & 8191;
        this.r[9] = t72 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m12, mpos, bytes2) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t22, t32, t42, t52, t62, t72, c11;
        var d0, d1, d22, d32, d42, d52, d62, d72, d82, d92;
        var h0 = this.h[0], h1 = this.h[1], h22 = this.h[2], h32 = this.h[3], h42 = this.h[4], h52 = this.h[5], h62 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r22 = this.r[2], r32 = this.r[3], r42 = this.r[4], r52 = this.r[5], r62 = this.r[6], r72 = this.r[7], r82 = this.r[8], r92 = this.r[9];
        while (bytes2 >= 16) {
          t0 = m12[mpos + 0] & 255 | (m12[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m12[mpos + 2] & 255 | (m12[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t22 = m12[mpos + 4] & 255 | (m12[mpos + 5] & 255) << 8;
          h22 += (t1 >>> 10 | t22 << 6) & 8191;
          t32 = m12[mpos + 6] & 255 | (m12[mpos + 7] & 255) << 8;
          h32 += (t22 >>> 7 | t32 << 9) & 8191;
          t42 = m12[mpos + 8] & 255 | (m12[mpos + 9] & 255) << 8;
          h42 += (t32 >>> 4 | t42 << 12) & 8191;
          h52 += t42 >>> 1 & 8191;
          t52 = m12[mpos + 10] & 255 | (m12[mpos + 11] & 255) << 8;
          h62 += (t42 >>> 14 | t52 << 2) & 8191;
          t62 = m12[mpos + 12] & 255 | (m12[mpos + 13] & 255) << 8;
          h7 += (t52 >>> 11 | t62 << 5) & 8191;
          t72 = m12[mpos + 14] & 255 | (m12[mpos + 15] & 255) << 8;
          h8 += (t62 >>> 8 | t72 << 8) & 8191;
          h9 += t72 >>> 5 | hibit;
          c11 = 0;
          d0 = c11;
          d0 += h0 * r0;
          d0 += h1 * (5 * r92);
          d0 += h22 * (5 * r82);
          d0 += h32 * (5 * r72);
          d0 += h42 * (5 * r62);
          c11 = d0 >>> 13;
          d0 &= 8191;
          d0 += h52 * (5 * r52);
          d0 += h62 * (5 * r42);
          d0 += h7 * (5 * r32);
          d0 += h8 * (5 * r22);
          d0 += h9 * (5 * r1);
          c11 += d0 >>> 13;
          d0 &= 8191;
          d1 = c11;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h22 * (5 * r92);
          d1 += h32 * (5 * r82);
          d1 += h42 * (5 * r72);
          c11 = d1 >>> 13;
          d1 &= 8191;
          d1 += h52 * (5 * r62);
          d1 += h62 * (5 * r52);
          d1 += h7 * (5 * r42);
          d1 += h8 * (5 * r32);
          d1 += h9 * (5 * r22);
          c11 += d1 >>> 13;
          d1 &= 8191;
          d22 = c11;
          d22 += h0 * r22;
          d22 += h1 * r1;
          d22 += h22 * r0;
          d22 += h32 * (5 * r92);
          d22 += h42 * (5 * r82);
          c11 = d22 >>> 13;
          d22 &= 8191;
          d22 += h52 * (5 * r72);
          d22 += h62 * (5 * r62);
          d22 += h7 * (5 * r52);
          d22 += h8 * (5 * r42);
          d22 += h9 * (5 * r32);
          c11 += d22 >>> 13;
          d22 &= 8191;
          d32 = c11;
          d32 += h0 * r32;
          d32 += h1 * r22;
          d32 += h22 * r1;
          d32 += h32 * r0;
          d32 += h42 * (5 * r92);
          c11 = d32 >>> 13;
          d32 &= 8191;
          d32 += h52 * (5 * r82);
          d32 += h62 * (5 * r72);
          d32 += h7 * (5 * r62);
          d32 += h8 * (5 * r52);
          d32 += h9 * (5 * r42);
          c11 += d32 >>> 13;
          d32 &= 8191;
          d42 = c11;
          d42 += h0 * r42;
          d42 += h1 * r32;
          d42 += h22 * r22;
          d42 += h32 * r1;
          d42 += h42 * r0;
          c11 = d42 >>> 13;
          d42 &= 8191;
          d42 += h52 * (5 * r92);
          d42 += h62 * (5 * r82);
          d42 += h7 * (5 * r72);
          d42 += h8 * (5 * r62);
          d42 += h9 * (5 * r52);
          c11 += d42 >>> 13;
          d42 &= 8191;
          d52 = c11;
          d52 += h0 * r52;
          d52 += h1 * r42;
          d52 += h22 * r32;
          d52 += h32 * r22;
          d52 += h42 * r1;
          c11 = d52 >>> 13;
          d52 &= 8191;
          d52 += h52 * r0;
          d52 += h62 * (5 * r92);
          d52 += h7 * (5 * r82);
          d52 += h8 * (5 * r72);
          d52 += h9 * (5 * r62);
          c11 += d52 >>> 13;
          d52 &= 8191;
          d62 = c11;
          d62 += h0 * r62;
          d62 += h1 * r52;
          d62 += h22 * r42;
          d62 += h32 * r32;
          d62 += h42 * r22;
          c11 = d62 >>> 13;
          d62 &= 8191;
          d62 += h52 * r1;
          d62 += h62 * r0;
          d62 += h7 * (5 * r92);
          d62 += h8 * (5 * r82);
          d62 += h9 * (5 * r72);
          c11 += d62 >>> 13;
          d62 &= 8191;
          d72 = c11;
          d72 += h0 * r72;
          d72 += h1 * r62;
          d72 += h22 * r52;
          d72 += h32 * r42;
          d72 += h42 * r32;
          c11 = d72 >>> 13;
          d72 &= 8191;
          d72 += h52 * r22;
          d72 += h62 * r1;
          d72 += h7 * r0;
          d72 += h8 * (5 * r92);
          d72 += h9 * (5 * r82);
          c11 += d72 >>> 13;
          d72 &= 8191;
          d82 = c11;
          d82 += h0 * r82;
          d82 += h1 * r72;
          d82 += h22 * r62;
          d82 += h32 * r52;
          d82 += h42 * r42;
          c11 = d82 >>> 13;
          d82 &= 8191;
          d82 += h52 * r32;
          d82 += h62 * r22;
          d82 += h7 * r1;
          d82 += h8 * r0;
          d82 += h9 * (5 * r92);
          c11 += d82 >>> 13;
          d82 &= 8191;
          d92 = c11;
          d92 += h0 * r92;
          d92 += h1 * r82;
          d92 += h22 * r72;
          d92 += h32 * r62;
          d92 += h42 * r52;
          c11 = d92 >>> 13;
          d92 &= 8191;
          d92 += h52 * r42;
          d92 += h62 * r32;
          d92 += h7 * r22;
          d92 += h8 * r1;
          d92 += h9 * r0;
          c11 += d92 >>> 13;
          d92 &= 8191;
          c11 = (c11 << 2) + c11 | 0;
          c11 = c11 + d0 | 0;
          d0 = c11 & 8191;
          c11 = c11 >>> 13;
          d1 += c11;
          h0 = d0;
          h1 = d1;
          h22 = d22;
          h32 = d32;
          h42 = d42;
          h52 = d52;
          h62 = d62;
          h7 = d72;
          h8 = d82;
          h9 = d92;
          mpos += 16;
          bytes2 -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h22;
        this.h[3] = h32;
        this.h[4] = h42;
        this.h[5] = h52;
        this.h[6] = h62;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g10 = new Uint16Array(10);
        var c11, mask2, f11, i17;
        if (this.leftover) {
          i17 = this.leftover;
          this.buffer[i17++] = 1;
          for (; i17 < 16; i17++)
            this.buffer[i17] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c11 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i17 = 2; i17 < 10; i17++) {
          this.h[i17] += c11;
          c11 = this.h[i17] >>> 13;
          this.h[i17] &= 8191;
        }
        this.h[0] += c11 * 5;
        c11 = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c11;
        c11 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c11;
        g10[0] = this.h[0] + 5;
        c11 = g10[0] >>> 13;
        g10[0] &= 8191;
        for (i17 = 1; i17 < 10; i17++) {
          g10[i17] = this.h[i17] + c11;
          c11 = g10[i17] >>> 13;
          g10[i17] &= 8191;
        }
        g10[9] -= 1 << 13;
        mask2 = (c11 ^ 1) - 1;
        for (i17 = 0; i17 < 10; i17++)
          g10[i17] &= mask2;
        mask2 = ~mask2;
        for (i17 = 0; i17 < 10; i17++)
          this.h[i17] = this.h[i17] & mask2 | g10[i17];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f11 = this.h[0] + this.pad[0];
        this.h[0] = f11 & 65535;
        for (i17 = 1; i17 < 8; i17++) {
          f11 = (this.h[i17] + this.pad[i17] | 0) + (f11 >>> 16) | 0;
          this.h[i17] = f11 & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m12, mpos, bytes2) {
        var i17, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes2)
            want = bytes2;
          for (i17 = 0; i17 < want; i17++)
            this.buffer[this.leftover + i17] = m12[mpos + i17];
          bytes2 -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes2 >= 16) {
          want = bytes2 - bytes2 % 16;
          this.blocks(m12, mpos, want);
          mpos += want;
          bytes2 -= want;
        }
        if (bytes2) {
          for (i17 = 0; i17 < bytes2; i17++)
            this.buffer[this.leftover + i17] = m12[mpos + i17];
          this.leftover += bytes2;
        }
      };
      function crypto_onetimeauth(out, outpos, m12, mpos, n17, k4) {
        var s9 = new poly1305(k4);
        s9.update(m12, mpos, n17);
        s9.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h7, hpos, m12, mpos, n17, k4) {
        var x5 = new Uint8Array(16);
        crypto_onetimeauth(x5, 0, m12, mpos, n17, k4);
        return crypto_verify_16(h7, hpos, x5, 0);
      }
      function crypto_secretbox(c11, m12, d15, n17, k4) {
        var i17;
        if (d15 < 32)
          return -1;
        crypto_stream_xor(c11, 0, m12, 0, d15, n17, k4);
        crypto_onetimeauth(c11, 16, c11, 32, d15 - 32, c11);
        for (i17 = 0; i17 < 16; i17++)
          c11[i17] = 0;
        return 0;
      }
      function crypto_secretbox_open(m12, c11, d15, n17, k4) {
        var i17;
        var x5 = new Uint8Array(32);
        if (d15 < 32)
          return -1;
        crypto_stream(x5, 0, 32, n17, k4);
        if (crypto_onetimeauth_verify(c11, 16, c11, 32, d15 - 32, x5) !== 0)
          return -1;
        crypto_stream_xor(m12, 0, c11, 0, d15, n17, k4);
        for (i17 = 0; i17 < 32; i17++)
          m12[i17] = 0;
        return 0;
      }
      function set25519(r17, a10) {
        var i17;
        for (i17 = 0; i17 < 16; i17++)
          r17[i17] = a10[i17] | 0;
      }
      function car25519(o18) {
        var i17, v7, c11 = 1;
        for (i17 = 0; i17 < 16; i17++) {
          v7 = o18[i17] + c11 + 65535;
          c11 = Math.floor(v7 / 65536);
          o18[i17] = v7 - c11 * 65536;
        }
        o18[0] += c11 - 1 + 37 * (c11 - 1);
      }
      function sel25519(p12, q2, b5) {
        var t18, c11 = ~(b5 - 1);
        for (var i17 = 0; i17 < 16; i17++) {
          t18 = c11 & (p12[i17] ^ q2[i17]);
          p12[i17] ^= t18;
          q2[i17] ^= t18;
        }
      }
      function pack25519(o18, n17) {
        var i17, j2, b5;
        var m12 = gf(), t18 = gf();
        for (i17 = 0; i17 < 16; i17++)
          t18[i17] = n17[i17];
        car25519(t18);
        car25519(t18);
        car25519(t18);
        for (j2 = 0; j2 < 2; j2++) {
          m12[0] = t18[0] - 65517;
          for (i17 = 1; i17 < 15; i17++) {
            m12[i17] = t18[i17] - 65535 - (m12[i17 - 1] >> 16 & 1);
            m12[i17 - 1] &= 65535;
          }
          m12[15] = t18[15] - 32767 - (m12[14] >> 16 & 1);
          b5 = m12[15] >> 16 & 1;
          m12[14] &= 65535;
          sel25519(t18, m12, 1 - b5);
        }
        for (i17 = 0; i17 < 16; i17++) {
          o18[2 * i17] = t18[i17] & 255;
          o18[2 * i17 + 1] = t18[i17] >> 8;
        }
      }
      function neq25519(a10, b5) {
        var c11 = new Uint8Array(32), d15 = new Uint8Array(32);
        pack25519(c11, a10);
        pack25519(d15, b5);
        return crypto_verify_32(c11, 0, d15, 0);
      }
      function par25519(a10) {
        var d15 = new Uint8Array(32);
        pack25519(d15, a10);
        return d15[0] & 1;
      }
      function unpack25519(o18, n17) {
        var i17;
        for (i17 = 0; i17 < 16; i17++)
          o18[i17] = n17[2 * i17] + (n17[2 * i17 + 1] << 8);
        o18[15] &= 32767;
      }
      function A2(o18, a10, b5) {
        for (var i17 = 0; i17 < 16; i17++)
          o18[i17] = a10[i17] + b5[i17];
      }
      function Z(o18, a10, b5) {
        for (var i17 = 0; i17 < 16; i17++)
          o18[i17] = a10[i17] - b5[i17];
      }
      function M5(o18, a10, b5) {
        var v7, c11, t0 = 0, t1 = 0, t22 = 0, t32 = 0, t42 = 0, t52 = 0, t62 = 0, t72 = 0, t82 = 0, t92 = 0, t102 = 0, t112 = 0, t122 = 0, t132 = 0, t142 = 0, t152 = 0, t162 = 0, t172 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t222 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b5[0], b1 = b5[1], b22 = b5[2], b32 = b5[3], b42 = b5[4], b52 = b5[5], b6 = b5[6], b7 = b5[7], b8 = b5[8], b9 = b5[9], b10 = b5[10], b11 = b5[11], b12 = b5[12], b13 = b5[13], b14 = b5[14], b15 = b5[15];
        v7 = a10[0];
        t0 += v7 * b0;
        t1 += v7 * b1;
        t22 += v7 * b22;
        t32 += v7 * b32;
        t42 += v7 * b42;
        t52 += v7 * b52;
        t62 += v7 * b6;
        t72 += v7 * b7;
        t82 += v7 * b8;
        t92 += v7 * b9;
        t102 += v7 * b10;
        t112 += v7 * b11;
        t122 += v7 * b12;
        t132 += v7 * b13;
        t142 += v7 * b14;
        t152 += v7 * b15;
        v7 = a10[1];
        t1 += v7 * b0;
        t22 += v7 * b1;
        t32 += v7 * b22;
        t42 += v7 * b32;
        t52 += v7 * b42;
        t62 += v7 * b52;
        t72 += v7 * b6;
        t82 += v7 * b7;
        t92 += v7 * b8;
        t102 += v7 * b9;
        t112 += v7 * b10;
        t122 += v7 * b11;
        t132 += v7 * b12;
        t142 += v7 * b13;
        t152 += v7 * b14;
        t162 += v7 * b15;
        v7 = a10[2];
        t22 += v7 * b0;
        t32 += v7 * b1;
        t42 += v7 * b22;
        t52 += v7 * b32;
        t62 += v7 * b42;
        t72 += v7 * b52;
        t82 += v7 * b6;
        t92 += v7 * b7;
        t102 += v7 * b8;
        t112 += v7 * b9;
        t122 += v7 * b10;
        t132 += v7 * b11;
        t142 += v7 * b12;
        t152 += v7 * b13;
        t162 += v7 * b14;
        t172 += v7 * b15;
        v7 = a10[3];
        t32 += v7 * b0;
        t42 += v7 * b1;
        t52 += v7 * b22;
        t62 += v7 * b32;
        t72 += v7 * b42;
        t82 += v7 * b52;
        t92 += v7 * b6;
        t102 += v7 * b7;
        t112 += v7 * b8;
        t122 += v7 * b9;
        t132 += v7 * b10;
        t142 += v7 * b11;
        t152 += v7 * b12;
        t162 += v7 * b13;
        t172 += v7 * b14;
        t18 += v7 * b15;
        v7 = a10[4];
        t42 += v7 * b0;
        t52 += v7 * b1;
        t62 += v7 * b22;
        t72 += v7 * b32;
        t82 += v7 * b42;
        t92 += v7 * b52;
        t102 += v7 * b6;
        t112 += v7 * b7;
        t122 += v7 * b8;
        t132 += v7 * b9;
        t142 += v7 * b10;
        t152 += v7 * b11;
        t162 += v7 * b12;
        t172 += v7 * b13;
        t18 += v7 * b14;
        t19 += v7 * b15;
        v7 = a10[5];
        t52 += v7 * b0;
        t62 += v7 * b1;
        t72 += v7 * b22;
        t82 += v7 * b32;
        t92 += v7 * b42;
        t102 += v7 * b52;
        t112 += v7 * b6;
        t122 += v7 * b7;
        t132 += v7 * b8;
        t142 += v7 * b9;
        t152 += v7 * b10;
        t162 += v7 * b11;
        t172 += v7 * b12;
        t18 += v7 * b13;
        t19 += v7 * b14;
        t20 += v7 * b15;
        v7 = a10[6];
        t62 += v7 * b0;
        t72 += v7 * b1;
        t82 += v7 * b22;
        t92 += v7 * b32;
        t102 += v7 * b42;
        t112 += v7 * b52;
        t122 += v7 * b6;
        t132 += v7 * b7;
        t142 += v7 * b8;
        t152 += v7 * b9;
        t162 += v7 * b10;
        t172 += v7 * b11;
        t18 += v7 * b12;
        t19 += v7 * b13;
        t20 += v7 * b14;
        t21 += v7 * b15;
        v7 = a10[7];
        t72 += v7 * b0;
        t82 += v7 * b1;
        t92 += v7 * b22;
        t102 += v7 * b32;
        t112 += v7 * b42;
        t122 += v7 * b52;
        t132 += v7 * b6;
        t142 += v7 * b7;
        t152 += v7 * b8;
        t162 += v7 * b9;
        t172 += v7 * b10;
        t18 += v7 * b11;
        t19 += v7 * b12;
        t20 += v7 * b13;
        t21 += v7 * b14;
        t222 += v7 * b15;
        v7 = a10[8];
        t82 += v7 * b0;
        t92 += v7 * b1;
        t102 += v7 * b22;
        t112 += v7 * b32;
        t122 += v7 * b42;
        t132 += v7 * b52;
        t142 += v7 * b6;
        t152 += v7 * b7;
        t162 += v7 * b8;
        t172 += v7 * b9;
        t18 += v7 * b10;
        t19 += v7 * b11;
        t20 += v7 * b12;
        t21 += v7 * b13;
        t222 += v7 * b14;
        t23 += v7 * b15;
        v7 = a10[9];
        t92 += v7 * b0;
        t102 += v7 * b1;
        t112 += v7 * b22;
        t122 += v7 * b32;
        t132 += v7 * b42;
        t142 += v7 * b52;
        t152 += v7 * b6;
        t162 += v7 * b7;
        t172 += v7 * b8;
        t18 += v7 * b9;
        t19 += v7 * b10;
        t20 += v7 * b11;
        t21 += v7 * b12;
        t222 += v7 * b13;
        t23 += v7 * b14;
        t24 += v7 * b15;
        v7 = a10[10];
        t102 += v7 * b0;
        t112 += v7 * b1;
        t122 += v7 * b22;
        t132 += v7 * b32;
        t142 += v7 * b42;
        t152 += v7 * b52;
        t162 += v7 * b6;
        t172 += v7 * b7;
        t18 += v7 * b8;
        t19 += v7 * b9;
        t20 += v7 * b10;
        t21 += v7 * b11;
        t222 += v7 * b12;
        t23 += v7 * b13;
        t24 += v7 * b14;
        t25 += v7 * b15;
        v7 = a10[11];
        t112 += v7 * b0;
        t122 += v7 * b1;
        t132 += v7 * b22;
        t142 += v7 * b32;
        t152 += v7 * b42;
        t162 += v7 * b52;
        t172 += v7 * b6;
        t18 += v7 * b7;
        t19 += v7 * b8;
        t20 += v7 * b9;
        t21 += v7 * b10;
        t222 += v7 * b11;
        t23 += v7 * b12;
        t24 += v7 * b13;
        t25 += v7 * b14;
        t26 += v7 * b15;
        v7 = a10[12];
        t122 += v7 * b0;
        t132 += v7 * b1;
        t142 += v7 * b22;
        t152 += v7 * b32;
        t162 += v7 * b42;
        t172 += v7 * b52;
        t18 += v7 * b6;
        t19 += v7 * b7;
        t20 += v7 * b8;
        t21 += v7 * b9;
        t222 += v7 * b10;
        t23 += v7 * b11;
        t24 += v7 * b12;
        t25 += v7 * b13;
        t26 += v7 * b14;
        t27 += v7 * b15;
        v7 = a10[13];
        t132 += v7 * b0;
        t142 += v7 * b1;
        t152 += v7 * b22;
        t162 += v7 * b32;
        t172 += v7 * b42;
        t18 += v7 * b52;
        t19 += v7 * b6;
        t20 += v7 * b7;
        t21 += v7 * b8;
        t222 += v7 * b9;
        t23 += v7 * b10;
        t24 += v7 * b11;
        t25 += v7 * b12;
        t26 += v7 * b13;
        t27 += v7 * b14;
        t28 += v7 * b15;
        v7 = a10[14];
        t142 += v7 * b0;
        t152 += v7 * b1;
        t162 += v7 * b22;
        t172 += v7 * b32;
        t18 += v7 * b42;
        t19 += v7 * b52;
        t20 += v7 * b6;
        t21 += v7 * b7;
        t222 += v7 * b8;
        t23 += v7 * b9;
        t24 += v7 * b10;
        t25 += v7 * b11;
        t26 += v7 * b12;
        t27 += v7 * b13;
        t28 += v7 * b14;
        t29 += v7 * b15;
        v7 = a10[15];
        t152 += v7 * b0;
        t162 += v7 * b1;
        t172 += v7 * b22;
        t18 += v7 * b32;
        t19 += v7 * b42;
        t20 += v7 * b52;
        t21 += v7 * b6;
        t222 += v7 * b7;
        t23 += v7 * b8;
        t24 += v7 * b9;
        t25 += v7 * b10;
        t26 += v7 * b11;
        t27 += v7 * b12;
        t28 += v7 * b13;
        t29 += v7 * b14;
        t30 += v7 * b15;
        t0 += 38 * t162;
        t1 += 38 * t172;
        t22 += 38 * t18;
        t32 += 38 * t19;
        t42 += 38 * t20;
        t52 += 38 * t21;
        t62 += 38 * t222;
        t72 += 38 * t23;
        t82 += 38 * t24;
        t92 += 38 * t25;
        t102 += 38 * t26;
        t112 += 38 * t27;
        t122 += 38 * t28;
        t132 += 38 * t29;
        t142 += 38 * t30;
        c11 = 1;
        v7 = t0 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t0 = v7 - c11 * 65536;
        v7 = t1 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t1 = v7 - c11 * 65536;
        v7 = t22 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t22 = v7 - c11 * 65536;
        v7 = t32 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t32 = v7 - c11 * 65536;
        v7 = t42 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t42 = v7 - c11 * 65536;
        v7 = t52 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t52 = v7 - c11 * 65536;
        v7 = t62 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t62 = v7 - c11 * 65536;
        v7 = t72 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t72 = v7 - c11 * 65536;
        v7 = t82 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t82 = v7 - c11 * 65536;
        v7 = t92 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t92 = v7 - c11 * 65536;
        v7 = t102 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t102 = v7 - c11 * 65536;
        v7 = t112 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t112 = v7 - c11 * 65536;
        v7 = t122 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t122 = v7 - c11 * 65536;
        v7 = t132 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t132 = v7 - c11 * 65536;
        v7 = t142 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t142 = v7 - c11 * 65536;
        v7 = t152 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t152 = v7 - c11 * 65536;
        t0 += c11 - 1 + 37 * (c11 - 1);
        c11 = 1;
        v7 = t0 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t0 = v7 - c11 * 65536;
        v7 = t1 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t1 = v7 - c11 * 65536;
        v7 = t22 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t22 = v7 - c11 * 65536;
        v7 = t32 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t32 = v7 - c11 * 65536;
        v7 = t42 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t42 = v7 - c11 * 65536;
        v7 = t52 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t52 = v7 - c11 * 65536;
        v7 = t62 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t62 = v7 - c11 * 65536;
        v7 = t72 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t72 = v7 - c11 * 65536;
        v7 = t82 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t82 = v7 - c11 * 65536;
        v7 = t92 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t92 = v7 - c11 * 65536;
        v7 = t102 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t102 = v7 - c11 * 65536;
        v7 = t112 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t112 = v7 - c11 * 65536;
        v7 = t122 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t122 = v7 - c11 * 65536;
        v7 = t132 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t132 = v7 - c11 * 65536;
        v7 = t142 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t142 = v7 - c11 * 65536;
        v7 = t152 + c11 + 65535;
        c11 = Math.floor(v7 / 65536);
        t152 = v7 - c11 * 65536;
        t0 += c11 - 1 + 37 * (c11 - 1);
        o18[0] = t0;
        o18[1] = t1;
        o18[2] = t22;
        o18[3] = t32;
        o18[4] = t42;
        o18[5] = t52;
        o18[6] = t62;
        o18[7] = t72;
        o18[8] = t82;
        o18[9] = t92;
        o18[10] = t102;
        o18[11] = t112;
        o18[12] = t122;
        o18[13] = t132;
        o18[14] = t142;
        o18[15] = t152;
      }
      function S3(o18, a10) {
        M5(o18, a10, a10);
      }
      function inv25519(o18, i17) {
        var c11 = gf();
        var a10;
        for (a10 = 0; a10 < 16; a10++)
          c11[a10] = i17[a10];
        for (a10 = 253; a10 >= 0; a10--) {
          S3(c11, c11);
          if (a10 !== 2 && a10 !== 4)
            M5(c11, c11, i17);
        }
        for (a10 = 0; a10 < 16; a10++)
          o18[a10] = c11[a10];
      }
      function pow2523(o18, i17) {
        var c11 = gf();
        var a10;
        for (a10 = 0; a10 < 16; a10++)
          c11[a10] = i17[a10];
        for (a10 = 250; a10 >= 0; a10--) {
          S3(c11, c11);
          if (a10 !== 1)
            M5(c11, c11, i17);
        }
        for (a10 = 0; a10 < 16; a10++)
          o18[a10] = c11[a10];
      }
      function crypto_scalarmult(q2, n17, p12) {
        var z = new Uint8Array(32);
        var x5 = new Float64Array(80), r17, i17;
        var a10 = gf(), b5 = gf(), c11 = gf(), d15 = gf(), e16 = gf(), f11 = gf();
        for (i17 = 0; i17 < 31; i17++)
          z[i17] = n17[i17];
        z[31] = n17[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x5, p12);
        for (i17 = 0; i17 < 16; i17++) {
          b5[i17] = x5[i17];
          d15[i17] = a10[i17] = c11[i17] = 0;
        }
        a10[0] = d15[0] = 1;
        for (i17 = 254; i17 >= 0; --i17) {
          r17 = z[i17 >>> 3] >>> (i17 & 7) & 1;
          sel25519(a10, b5, r17);
          sel25519(c11, d15, r17);
          A2(e16, a10, c11);
          Z(a10, a10, c11);
          A2(c11, b5, d15);
          Z(b5, b5, d15);
          S3(d15, e16);
          S3(f11, a10);
          M5(a10, c11, a10);
          M5(c11, b5, e16);
          A2(e16, a10, c11);
          Z(a10, a10, c11);
          S3(b5, a10);
          Z(c11, d15, f11);
          M5(a10, c11, _121665);
          A2(a10, a10, d15);
          M5(c11, c11, a10);
          M5(a10, d15, f11);
          M5(d15, b5, x5);
          S3(b5, e16);
          sel25519(a10, b5, r17);
          sel25519(c11, d15, r17);
        }
        for (i17 = 0; i17 < 16; i17++) {
          x5[i17 + 16] = a10[i17];
          x5[i17 + 32] = c11[i17];
          x5[i17 + 48] = b5[i17];
          x5[i17 + 64] = d15[i17];
        }
        var x32 = x5.subarray(32);
        var x16 = x5.subarray(16);
        inv25519(x32, x32);
        M5(x16, x16, x32);
        pack25519(q2, x16);
        return 0;
      }
      function crypto_scalarmult_base(q2, n17) {
        return crypto_scalarmult(q2, n17, _9);
      }
      function crypto_box_keypair(y6, x5) {
        randombytes(x5, 32);
        return crypto_scalarmult_base(y6, x5);
      }
      function crypto_box_beforenm(k4, y6, x5) {
        var s9 = new Uint8Array(32);
        crypto_scalarmult(s9, x5, y6);
        return crypto_core_hsalsa20(k4, _0, s9, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c11, m12, d15, n17, y6, x5) {
        var k4 = new Uint8Array(32);
        crypto_box_beforenm(k4, y6, x5);
        return crypto_box_afternm(c11, m12, d15, n17, k4);
      }
      function crypto_box_open(m12, c11, d15, n17, y6, x5) {
        var k4 = new Uint8Array(32);
        crypto_box_beforenm(k4, y6, x5);
        return crypto_box_open_afternm(m12, c11, d15, n17, k4);
      }
      var K2 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m12, n17) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i17, j2, h7, l9, a10, b5, c11, d15;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n17 >= 128) {
          for (i17 = 0; i17 < 16; i17++) {
            j2 = 8 * i17 + pos;
            wh[i17] = m12[j2 + 0] << 24 | m12[j2 + 1] << 16 | m12[j2 + 2] << 8 | m12[j2 + 3];
            wl[i17] = m12[j2 + 4] << 24 | m12[j2 + 5] << 16 | m12[j2 + 6] << 8 | m12[j2 + 7];
          }
          for (i17 = 0; i17 < 80; i17++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h7 = ah7;
            l9 = al7;
            a10 = l9 & 65535;
            b5 = l9 >>> 16;
            c11 = h7 & 65535;
            d15 = h7 >>> 16;
            h7 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l9 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a10 += l9 & 65535;
            b5 += l9 >>> 16;
            c11 += h7 & 65535;
            d15 += h7 >>> 16;
            h7 = ah4 & ah5 ^ ~ah4 & ah6;
            l9 = al4 & al5 ^ ~al4 & al6;
            a10 += l9 & 65535;
            b5 += l9 >>> 16;
            c11 += h7 & 65535;
            d15 += h7 >>> 16;
            h7 = K2[i17 * 2];
            l9 = K2[i17 * 2 + 1];
            a10 += l9 & 65535;
            b5 += l9 >>> 16;
            c11 += h7 & 65535;
            d15 += h7 >>> 16;
            h7 = wh[i17 % 16];
            l9 = wl[i17 % 16];
            a10 += l9 & 65535;
            b5 += l9 >>> 16;
            c11 += h7 & 65535;
            d15 += h7 >>> 16;
            b5 += a10 >>> 16;
            c11 += b5 >>> 16;
            d15 += c11 >>> 16;
            th = c11 & 65535 | d15 << 16;
            tl = a10 & 65535 | b5 << 16;
            h7 = th;
            l9 = tl;
            a10 = l9 & 65535;
            b5 = l9 >>> 16;
            c11 = h7 & 65535;
            d15 = h7 >>> 16;
            h7 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l9 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a10 += l9 & 65535;
            b5 += l9 >>> 16;
            c11 += h7 & 65535;
            d15 += h7 >>> 16;
            h7 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l9 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a10 += l9 & 65535;
            b5 += l9 >>> 16;
            c11 += h7 & 65535;
            d15 += h7 >>> 16;
            b5 += a10 >>> 16;
            c11 += b5 >>> 16;
            d15 += c11 >>> 16;
            bh7 = c11 & 65535 | d15 << 16;
            bl7 = a10 & 65535 | b5 << 16;
            h7 = bh3;
            l9 = bl3;
            a10 = l9 & 65535;
            b5 = l9 >>> 16;
            c11 = h7 & 65535;
            d15 = h7 >>> 16;
            h7 = th;
            l9 = tl;
            a10 += l9 & 65535;
            b5 += l9 >>> 16;
            c11 += h7 & 65535;
            d15 += h7 >>> 16;
            b5 += a10 >>> 16;
            c11 += b5 >>> 16;
            d15 += c11 >>> 16;
            bh3 = c11 & 65535 | d15 << 16;
            bl3 = a10 & 65535 | b5 << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i17 % 16 === 15) {
              for (j2 = 0; j2 < 16; j2++) {
                h7 = wh[j2];
                l9 = wl[j2];
                a10 = l9 & 65535;
                b5 = l9 >>> 16;
                c11 = h7 & 65535;
                d15 = h7 >>> 16;
                h7 = wh[(j2 + 9) % 16];
                l9 = wl[(j2 + 9) % 16];
                a10 += l9 & 65535;
                b5 += l9 >>> 16;
                c11 += h7 & 65535;
                d15 += h7 >>> 16;
                th = wh[(j2 + 1) % 16];
                tl = wl[(j2 + 1) % 16];
                h7 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l9 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a10 += l9 & 65535;
                b5 += l9 >>> 16;
                c11 += h7 & 65535;
                d15 += h7 >>> 16;
                th = wh[(j2 + 14) % 16];
                tl = wl[(j2 + 14) % 16];
                h7 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l9 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a10 += l9 & 65535;
                b5 += l9 >>> 16;
                c11 += h7 & 65535;
                d15 += h7 >>> 16;
                b5 += a10 >>> 16;
                c11 += b5 >>> 16;
                d15 += c11 >>> 16;
                wh[j2] = c11 & 65535 | d15 << 16;
                wl[j2] = a10 & 65535 | b5 << 16;
              }
            }
          }
          h7 = ah0;
          l9 = al0;
          a10 = l9 & 65535;
          b5 = l9 >>> 16;
          c11 = h7 & 65535;
          d15 = h7 >>> 16;
          h7 = hh[0];
          l9 = hl[0];
          a10 += l9 & 65535;
          b5 += l9 >>> 16;
          c11 += h7 & 65535;
          d15 += h7 >>> 16;
          b5 += a10 >>> 16;
          c11 += b5 >>> 16;
          d15 += c11 >>> 16;
          hh[0] = ah0 = c11 & 65535 | d15 << 16;
          hl[0] = al0 = a10 & 65535 | b5 << 16;
          h7 = ah1;
          l9 = al1;
          a10 = l9 & 65535;
          b5 = l9 >>> 16;
          c11 = h7 & 65535;
          d15 = h7 >>> 16;
          h7 = hh[1];
          l9 = hl[1];
          a10 += l9 & 65535;
          b5 += l9 >>> 16;
          c11 += h7 & 65535;
          d15 += h7 >>> 16;
          b5 += a10 >>> 16;
          c11 += b5 >>> 16;
          d15 += c11 >>> 16;
          hh[1] = ah1 = c11 & 65535 | d15 << 16;
          hl[1] = al1 = a10 & 65535 | b5 << 16;
          h7 = ah2;
          l9 = al2;
          a10 = l9 & 65535;
          b5 = l9 >>> 16;
          c11 = h7 & 65535;
          d15 = h7 >>> 16;
          h7 = hh[2];
          l9 = hl[2];
          a10 += l9 & 65535;
          b5 += l9 >>> 16;
          c11 += h7 & 65535;
          d15 += h7 >>> 16;
          b5 += a10 >>> 16;
          c11 += b5 >>> 16;
          d15 += c11 >>> 16;
          hh[2] = ah2 = c11 & 65535 | d15 << 16;
          hl[2] = al2 = a10 & 65535 | b5 << 16;
          h7 = ah3;
          l9 = al3;
          a10 = l9 & 65535;
          b5 = l9 >>> 16;
          c11 = h7 & 65535;
          d15 = h7 >>> 16;
          h7 = hh[3];
          l9 = hl[3];
          a10 += l9 & 65535;
          b5 += l9 >>> 16;
          c11 += h7 & 65535;
          d15 += h7 >>> 16;
          b5 += a10 >>> 16;
          c11 += b5 >>> 16;
          d15 += c11 >>> 16;
          hh[3] = ah3 = c11 & 65535 | d15 << 16;
          hl[3] = al3 = a10 & 65535 | b5 << 16;
          h7 = ah4;
          l9 = al4;
          a10 = l9 & 65535;
          b5 = l9 >>> 16;
          c11 = h7 & 65535;
          d15 = h7 >>> 16;
          h7 = hh[4];
          l9 = hl[4];
          a10 += l9 & 65535;
          b5 += l9 >>> 16;
          c11 += h7 & 65535;
          d15 += h7 >>> 16;
          b5 += a10 >>> 16;
          c11 += b5 >>> 16;
          d15 += c11 >>> 16;
          hh[4] = ah4 = c11 & 65535 | d15 << 16;
          hl[4] = al4 = a10 & 65535 | b5 << 16;
          h7 = ah5;
          l9 = al5;
          a10 = l9 & 65535;
          b5 = l9 >>> 16;
          c11 = h7 & 65535;
          d15 = h7 >>> 16;
          h7 = hh[5];
          l9 = hl[5];
          a10 += l9 & 65535;
          b5 += l9 >>> 16;
          c11 += h7 & 65535;
          d15 += h7 >>> 16;
          b5 += a10 >>> 16;
          c11 += b5 >>> 16;
          d15 += c11 >>> 16;
          hh[5] = ah5 = c11 & 65535 | d15 << 16;
          hl[5] = al5 = a10 & 65535 | b5 << 16;
          h7 = ah6;
          l9 = al6;
          a10 = l9 & 65535;
          b5 = l9 >>> 16;
          c11 = h7 & 65535;
          d15 = h7 >>> 16;
          h7 = hh[6];
          l9 = hl[6];
          a10 += l9 & 65535;
          b5 += l9 >>> 16;
          c11 += h7 & 65535;
          d15 += h7 >>> 16;
          b5 += a10 >>> 16;
          c11 += b5 >>> 16;
          d15 += c11 >>> 16;
          hh[6] = ah6 = c11 & 65535 | d15 << 16;
          hl[6] = al6 = a10 & 65535 | b5 << 16;
          h7 = ah7;
          l9 = al7;
          a10 = l9 & 65535;
          b5 = l9 >>> 16;
          c11 = h7 & 65535;
          d15 = h7 >>> 16;
          h7 = hh[7];
          l9 = hl[7];
          a10 += l9 & 65535;
          b5 += l9 >>> 16;
          c11 += h7 & 65535;
          d15 += h7 >>> 16;
          b5 += a10 >>> 16;
          c11 += b5 >>> 16;
          d15 += c11 >>> 16;
          hh[7] = ah7 = c11 & 65535 | d15 << 16;
          hl[7] = al7 = a10 & 65535 | b5 << 16;
          pos += 128;
          n17 -= 128;
        }
        return n17;
      }
      function crypto_hash(out, m12, n17) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x5 = new Uint8Array(256), i17, b5 = n17;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m12, n17);
        n17 %= 128;
        for (i17 = 0; i17 < n17; i17++)
          x5[i17] = m12[b5 - n17 + i17];
        x5[n17] = 128;
        n17 = 256 - 128 * (n17 < 112 ? 1 : 0);
        x5[n17 - 9] = 0;
        ts64(x5, n17 - 8, b5 / 536870912 | 0, b5 << 3);
        crypto_hashblocks_hl(hh, hl, x5, n17);
        for (i17 = 0; i17 < 8; i17++)
          ts64(out, 8 * i17, hh[i17], hl[i17]);
        return 0;
      }
      function add2(p12, q2) {
        var a10 = gf(), b5 = gf(), c11 = gf(), d15 = gf(), e16 = gf(), f11 = gf(), g10 = gf(), h7 = gf(), t18 = gf();
        Z(a10, p12[1], p12[0]);
        Z(t18, q2[1], q2[0]);
        M5(a10, a10, t18);
        A2(b5, p12[0], p12[1]);
        A2(t18, q2[0], q2[1]);
        M5(b5, b5, t18);
        M5(c11, p12[3], q2[3]);
        M5(c11, c11, D22);
        M5(d15, p12[2], q2[2]);
        A2(d15, d15, d15);
        Z(e16, b5, a10);
        Z(f11, d15, c11);
        A2(g10, d15, c11);
        A2(h7, b5, a10);
        M5(p12[0], e16, f11);
        M5(p12[1], h7, g10);
        M5(p12[2], g10, f11);
        M5(p12[3], e16, h7);
      }
      function cswap(p12, q2, b5) {
        var i17;
        for (i17 = 0; i17 < 4; i17++) {
          sel25519(p12[i17], q2[i17], b5);
        }
      }
      function pack(r17, p12) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p12[2]);
        M5(tx, p12[0], zi);
        M5(ty, p12[1], zi);
        pack25519(r17, ty);
        r17[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p12, q2, s9) {
        var b5, i17;
        set25519(p12[0], gf0);
        set25519(p12[1], gf1);
        set25519(p12[2], gf1);
        set25519(p12[3], gf0);
        for (i17 = 255; i17 >= 0; --i17) {
          b5 = s9[i17 / 8 | 0] >> (i17 & 7) & 1;
          cswap(p12, q2, b5);
          add2(q2, p12);
          add2(p12, p12);
          cswap(p12, q2, b5);
        }
      }
      function scalarbase(p12, s9) {
        var q2 = [gf(), gf(), gf(), gf()];
        set25519(q2[0], X2);
        set25519(q2[1], Y3);
        set25519(q2[2], gf1);
        M5(q2[3], X2, Y3);
        scalarmult(p12, q2, s9);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d15 = new Uint8Array(64);
        var p12 = [gf(), gf(), gf(), gf()];
        var i17;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d15, sk, 32);
        d15[0] &= 248;
        d15[31] &= 127;
        d15[31] |= 64;
        scalarbase(p12, d15);
        pack(pk, p12);
        for (i17 = 0; i17 < 32; i17++)
          sk[i17 + 32] = pk[i17];
        return 0;
      }
      var L3 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r17, x5) {
        var carry, i17, j2, k4;
        for (i17 = 63; i17 >= 32; --i17) {
          carry = 0;
          for (j2 = i17 - 32, k4 = i17 - 12; j2 < k4; ++j2) {
            x5[j2] += carry - 16 * x5[i17] * L3[j2 - (i17 - 32)];
            carry = Math.floor((x5[j2] + 128) / 256);
            x5[j2] -= carry * 256;
          }
          x5[j2] += carry;
          x5[i17] = 0;
        }
        carry = 0;
        for (j2 = 0; j2 < 32; j2++) {
          x5[j2] += carry - (x5[31] >> 4) * L3[j2];
          carry = x5[j2] >> 8;
          x5[j2] &= 255;
        }
        for (j2 = 0; j2 < 32; j2++)
          x5[j2] -= carry * L3[j2];
        for (i17 = 0; i17 < 32; i17++) {
          x5[i17 + 1] += x5[i17] >> 8;
          r17[i17] = x5[i17] & 255;
        }
      }
      function reduce(r17) {
        var x5 = new Float64Array(64), i17;
        for (i17 = 0; i17 < 64; i17++)
          x5[i17] = r17[i17];
        for (i17 = 0; i17 < 64; i17++)
          r17[i17] = 0;
        modL(r17, x5);
      }
      function crypto_sign(sm, m12, n17, sk) {
        var d15 = new Uint8Array(64), h7 = new Uint8Array(64), r17 = new Uint8Array(64);
        var i17, j2, x5 = new Float64Array(64);
        var p12 = [gf(), gf(), gf(), gf()];
        crypto_hash(d15, sk, 32);
        d15[0] &= 248;
        d15[31] &= 127;
        d15[31] |= 64;
        var smlen = n17 + 64;
        for (i17 = 0; i17 < n17; i17++)
          sm[64 + i17] = m12[i17];
        for (i17 = 0; i17 < 32; i17++)
          sm[32 + i17] = d15[32 + i17];
        crypto_hash(r17, sm.subarray(32), n17 + 32);
        reduce(r17);
        scalarbase(p12, r17);
        pack(sm, p12);
        for (i17 = 32; i17 < 64; i17++)
          sm[i17] = sk[i17];
        crypto_hash(h7, sm, n17 + 64);
        reduce(h7);
        for (i17 = 0; i17 < 64; i17++)
          x5[i17] = 0;
        for (i17 = 0; i17 < 32; i17++)
          x5[i17] = r17[i17];
        for (i17 = 0; i17 < 32; i17++) {
          for (j2 = 0; j2 < 32; j2++) {
            x5[i17 + j2] += h7[i17] * d15[j2];
          }
        }
        modL(sm.subarray(32), x5);
        return smlen;
      }
      function unpackneg(r17, p12) {
        var t18 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r17[2], gf1);
        unpack25519(r17[1], p12);
        S3(num, r17[1]);
        M5(den, num, D4);
        Z(num, num, r17[2]);
        A2(den, r17[2], den);
        S3(den2, den);
        S3(den4, den2);
        M5(den6, den4, den2);
        M5(t18, den6, num);
        M5(t18, t18, den);
        pow2523(t18, t18);
        M5(t18, t18, num);
        M5(t18, t18, den);
        M5(t18, t18, den);
        M5(r17[0], t18, den);
        S3(chk, r17[0]);
        M5(chk, chk, den);
        if (neq25519(chk, num))
          M5(r17[0], r17[0], I6);
        S3(chk, r17[0]);
        M5(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r17[0]) === p12[31] >> 7)
          Z(r17[0], gf0, r17[0]);
        M5(r17[3], r17[0], r17[1]);
        return 0;
      }
      function crypto_sign_open(m12, sm, n17, pk) {
        var i17;
        var t18 = new Uint8Array(32), h7 = new Uint8Array(64);
        var p12 = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
        if (n17 < 64)
          return -1;
        if (unpackneg(q2, pk))
          return -1;
        for (i17 = 0; i17 < n17; i17++)
          m12[i17] = sm[i17];
        for (i17 = 0; i17 < 32; i17++)
          m12[i17 + 32] = pk[i17];
        crypto_hash(h7, m12, n17);
        reduce(h7);
        scalarmult(p12, q2, h7);
        scalarbase(q2, sm.subarray(32));
        add2(p12, q2);
        pack(t18, p12);
        n17 -= 64;
        if (crypto_verify_32(sm, 0, t18, 0)) {
          for (i17 = 0; i17 < n17; i17++)
            m12[i17] = 0;
          return -1;
        }
        for (i17 = 0; i17 < n17; i17++)
          m12[i17] = sm[i17 + 64];
        return n17;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl5.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D: D4,
        L: L3,
        pack25519,
        unpack25519,
        M: M5,
        A: A2,
        S: S3,
        Z,
        pow2523,
        add: add2,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k4, n17) {
        if (k4.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n17.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i17 = 0; i17 < arguments.length; i17++) {
          if (!(arguments[i17] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i17 = 0; i17 < arr.length; i17++)
          arr[i17] = 0;
      }
      nacl5.randomBytes = function(n17) {
        var b5 = new Uint8Array(n17);
        randombytes(b5, n17);
        return b5;
      };
      nacl5.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m12 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c11 = new Uint8Array(m12.length);
        for (var i17 = 0; i17 < msg.length; i17++)
          m12[i17 + crypto_secretbox_ZEROBYTES] = msg[i17];
        crypto_secretbox(c11, m12, m12.length, nonce, key);
        return c11.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl5.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c11 = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m12 = new Uint8Array(c11.length);
        for (var i17 = 0; i17 < box.length; i17++)
          c11[i17 + crypto_secretbox_BOXZEROBYTES] = box[i17];
        if (c11.length < 32)
          return null;
        if (crypto_secretbox_open(m12, c11, c11.length, nonce, key) !== 0)
          return null;
        return m12.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl5.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl5.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl5.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl5.scalarMult = function(n17, p12) {
        checkArrayTypes(n17, p12);
        if (n17.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p12.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q2 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q2, n17, p12);
        return q2;
      };
      nacl5.scalarMult.base = function(n17) {
        checkArrayTypes(n17);
        if (n17.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q2 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q2, n17);
        return q2;
      };
      nacl5.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl5.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl5.box = function(msg, nonce, publicKey, secretKey) {
        var k4 = nacl5.box.before(publicKey, secretKey);
        return nacl5.secretbox(msg, nonce, k4);
      };
      nacl5.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k4 = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k4, publicKey, secretKey);
        return k4;
      };
      nacl5.box.after = nacl5.secretbox;
      nacl5.box.open = function(msg, nonce, publicKey, secretKey) {
        var k4 = nacl5.box.before(publicKey, secretKey);
        return nacl5.secretbox.open(msg, nonce, k4);
      };
      nacl5.box.open.after = nacl5.secretbox.open;
      nacl5.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl5.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl5.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl5.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl5.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl5.box.nonceLength = crypto_box_NONCEBYTES;
      nacl5.box.overheadLength = nacl5.secretbox.overheadLength;
      nacl5.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl5.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m12 = new Uint8Array(mlen);
        for (var i17 = 0; i17 < m12.length; i17++)
          m12[i17] = tmp[i17];
        return m12;
      };
      nacl5.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl5.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i17 = 0; i17 < sig.length; i17++)
          sig[i17] = signedMsg[i17];
        return sig;
      };
      nacl5.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m12 = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i17;
        for (i17 = 0; i17 < crypto_sign_BYTES; i17++)
          sm[i17] = sig[i17];
        for (i17 = 0; i17 < msg.length; i17++)
          sm[i17 + crypto_sign_BYTES] = msg[i17];
        return crypto_sign_open(m12, sm, sm.length, publicKey) >= 0;
      };
      nacl5.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl5.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i17 = 0; i17 < pk.length; i17++)
          pk[i17] = secretKey[32 + i17];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl5.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i17 = 0; i17 < 32; i17++)
          sk[i17] = seed[i17];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl5.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl5.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl5.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl5.sign.signatureLength = crypto_sign_BYTES;
      nacl5.hash = function(msg) {
        checkArrayTypes(msg);
        var h7 = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h7, msg, msg.length);
        return h7;
      };
      nacl5.hash.hashLength = crypto_hash_BYTES;
      nacl5.verify = function(x5, y6) {
        checkArrayTypes(x5, y6);
        if (x5.length === 0 || y6.length === 0)
          return false;
        if (x5.length !== y6.length)
          return false;
        return vn(x5, 0, y6, 0, x5.length) === 0 ? true : false;
      };
      nacl5.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto3 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto3 && crypto3.getRandomValues) {
          var QUOTA = 65536;
          nacl5.setPRNG(function(x5, n17) {
            var i17, v7 = new Uint8Array(n17);
            for (i17 = 0; i17 < n17; i17 += QUOTA) {
              crypto3.getRandomValues(v7.subarray(i17, i17 + Math.min(n17 - i17, QUOTA)));
            }
            for (i17 = 0; i17 < n17; i17++)
              x5[i17] = v7[i17];
            cleanup(v7);
          });
        } else if (typeof __require !== "undefined") {
          crypto3 = require_crypto();
          if (crypto3 && crypto3.randomBytes) {
            nacl5.setPRNG(function(x5, n17) {
              var i17, v7 = crypto3.randomBytes(n17);
              for (i17 = 0; i17 < n17; i17++)
                x5[i17] = v7[i17];
              cleanup(v7);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
        BASE_MAP[j2] = 255;
      }
      for (var i17 = 0; i17 < ALPHABET.length; i17++) {
        var x5 = ALPHABET.charAt(i17);
        var xc = x5.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x5 + " is ambiguous");
        }
        BASE_MAP[xc] = i17;
      }
      var BASE2 = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE2) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE2);
      function encode3(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i18 = 0;
          for (var it1 = size - 1; (carry !== 0 || i18 < length) && it1 !== -1; it1--, i18++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE2 >>> 0;
            carry = carry / BASE2 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i18;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i18 = 0;
          for (var it3 = size - 1; (carry !== 0 || i18 < length) && it3 !== -1; it3--, i18++) {
            carry += BASE2 * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i18;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j3 = zeroes;
        while (it4 !== size) {
          vch[j3++] = b256[it4++];
        }
        return vch;
      }
      function decode3(string2) {
        var buffer = decodeUnsafe(string2);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE2 + " character");
      }
      return {
        encode: encode3,
        decodeUnsafe,
        decode: decode3
      };
    }
    module.exports = base;
  }
});

// node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/bs58/index.js"(exports, module) {
    var basex = require_src();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET);
  }
});

// node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number3(n17) {
      if (!Number.isSafeInteger(n17) || n17 < 0)
        throw new Error(`Wrong positive integer: ${n17}`);
    }
    exports.number = number3;
    function bool2(b5) {
      if (typeof b5 !== "boolean")
        throw new Error(`Expected boolean, not ${b5}`);
    }
    exports.bool = bool2;
    function bytes2(b5, ...lengths) {
      if (!(b5 instanceof Uint8Array))
        throw new TypeError("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b5.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b5.length}`);
    }
    exports.bytes = bytes2;
    function hash2(hash3) {
      if (typeof hash3 !== "function" || typeof hash3.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number3(hash3.outputLen);
      number3(hash3.blockLen);
    }
    exports.hash = hash2;
    function exists2(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists2;
    function output2(out, instance) {
      bytes2(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output2;
    var assert3 = {
      number: number3,
      bool: bool2,
      bytes: bytes2,
      hash: hash2,
      exists: exists2,
      output: output2
    };
    exports.default = assert3;
  }
});

// node_modules/@noble/hashes/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_crypto2();
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u322;
    var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView2;
    var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr2;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes3 = Array.from({ length: 256 }, (v7, i17) => i17.toString(16).padStart(2, "0"));
    function bytesToHex3(uint8a) {
      if (!(uint8a instanceof Uint8Array))
        throw new Error("Uint8Array expected");
      let hex2 = "";
      for (let i17 = 0; i17 < uint8a.length; i17++) {
        hex2 += hexes3[uint8a[i17]];
      }
      return hex2;
    }
    exports.bytesToHex = bytesToHex3;
    function hexToBytes3(hex2) {
      if (typeof hex2 !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex2);
      }
      if (hex2.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex");
      const array2 = new Uint8Array(hex2.length / 2);
      for (let i17 = 0; i17 < array2.length; i17++) {
        const j2 = i17 * 2;
        const hexByte = hex2.slice(j2, j2 + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array2[i17] = byte;
      }
      return array2;
    }
    exports.hexToBytes = hexToBytes3;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i17 = 0; i17 < iters; i17++) {
        cb(i17);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes3(str) {
      if (typeof str !== "string") {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
      }
      return new TextEncoder().encode(str);
    }
    exports.utf8ToBytes = utf8ToBytes3;
    function toBytes2(data) {
      if (typeof data === "string")
        data = utf8ToBytes3(data);
      if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
      return data;
    }
    exports.toBytes = toBytes2;
    function concatBytes3(...arrays) {
      if (!arrays.every((a10) => a10 instanceof Uint8Array))
        throw new Error("Uint8Array list expected");
      if (arrays.length === 1)
        return arrays[0];
      const length = arrays.reduce((a10, arr) => a10 + arr.length, 0);
      const result = new Uint8Array(length);
      for (let i17 = 0, pad = 0; i17 < arrays.length; i17++) {
        const arr = arrays[i17];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    }
    exports.concatBytes = concatBytes3;
    var Hash2 = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash2;
    var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
        throw new TypeError("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor2(hashConstructor) {
      const hashC = (message) => hashConstructor().update(toBytes2(message)).digest();
      const tmp = hashConstructor();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashConstructor();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor2;
    function wrapConstructorWithOpts2(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts2;
    function randomBytes2(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes2;
  }
});

// node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    var HMAC2 = class extends utils_js_1.Hash {
      constructor(hash2, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        _assert_js_1.default.hash(hash2);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash2.create();
        if (typeof this.iHash.update !== "function")
          throw new TypeError("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
        for (let i17 = 0; i17 < pad.length; i17++)
          pad[i17] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash2.create();
        for (let i17 = 0; i17 < pad.length; i17++)
          pad[i17] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        _assert_js_1.default.exists(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.bytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    var hmac2 = (hash2, key, message) => new HMAC2(hash2, key).update(message).digest();
    exports.hmac = hmac2;
    exports.hmac.create = (hash2, key) => new HMAC2(hash2, key);
  }
});

// node_modules/@noble/hashes/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/@noble/hashes/pbkdf2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2Async = exports.pbkdf2 = void 0;
    var _assert_js_1 = require_assert();
    var hmac_js_1 = require_hmac();
    var utils_js_1 = require_utils();
    function pbkdf2Init(hash2, _password, _salt, _opts) {
      _assert_js_1.default.hash(hash2);
      const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
      const { c: c11, dkLen, asyncTick } = opts;
      _assert_js_1.default.number(c11);
      _assert_js_1.default.number(dkLen);
      _assert_js_1.default.number(asyncTick);
      if (c11 < 1)
        throw new Error("PBKDF2: iterations (c) should be >= 1");
      const password = (0, utils_js_1.toBytes)(_password);
      const salt = (0, utils_js_1.toBytes)(_salt);
      const DK = new Uint8Array(dkLen);
      const PRF = hmac_js_1.hmac.create(hash2, password);
      const PRFSalt = PRF._cloneInto().update(salt);
      return { c: c11, dkLen, asyncTick, DK, PRF, PRFSalt };
    }
    function pbkdf2Output(PRF, PRFSalt, DK, prfW, u5) {
      PRF.destroy();
      PRFSalt.destroy();
      if (prfW)
        prfW.destroy();
      u5.fill(0);
      return DK;
    }
    function pbkdf2(hash2, password, salt, opts) {
      const { c: c11, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_js_1.createView)(arr);
      const u5 = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u5);
        Ti.set(u5.subarray(0, Ti.length));
        for (let ui = 1; ui < c11; ui++) {
          PRF._cloneInto(prfW).update(u5).digestInto(u5);
          for (let i17 = 0; i17 < Ti.length; i17++)
            Ti[i17] ^= u5[i17];
        }
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u5);
    }
    exports.pbkdf2 = pbkdf2;
    async function pbkdf2Async(hash2, password, salt, opts) {
      const { c: c11, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_js_1.createView)(arr);
      const u5 = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u5);
        Ti.set(u5.subarray(0, Ti.length));
        await (0, utils_js_1.asyncLoop)(c11 - 1, asyncTick, (i17) => {
          PRF._cloneInto(prfW).update(u5).digestInto(u5);
          for (let i18 = 0; i18 < Ti.length; i18++)
            Ti[i18] ^= u5[i18];
        });
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u5);
    }
    exports.pbkdf2Async = pbkdf2Async;
  }
});

// node_modules/@noble/hashes/_sha2.js
var require_sha2 = __commonJS({
  "node_modules/@noble/hashes/_sha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    function setBigUint642(view, byteOffset, value, isLE2) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE2);
      const _32n2 = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n2 & _u32_max);
      const wl = Number(value & _u32_max);
      const h7 = isLE2 ? 4 : 0;
      const l9 = isLE2 ? 0 : 4;
      view.setUint32(byteOffset + h7, wh, isLE2);
      view.setUint32(byteOffset + l9, wl, isLE2);
    }
    var SHA22 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE2) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE2;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        _assert_js_1.default.exists(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.output(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE: isLE2 } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i17 = pos; i17 < blockLen; i17++)
          buffer[i17] = 0;
        setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE2);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i17 = 0; i17 < outLen; i17++)
          oview.setUint32(4 * i17, state[i17], isLE2);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.SHA2 = SHA22;
  }
});

// node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var Chi2 = (a10, b5, c11) => a10 & b5 ^ ~a10 & c11;
    var Maj2 = (a10, b5, c11) => a10 & b5 ^ a10 & c11 ^ b5 & c11;
    var SHA256_K2 = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV3 = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W2 = new Uint32Array(64);
    var SHA2562 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV3[0] | 0;
        this.B = IV3[1] | 0;
        this.C = IV3[2] | 0;
        this.D = IV3[3] | 0;
        this.E = IV3[4] | 0;
        this.F = IV3[5] | 0;
        this.G = IV3[6] | 0;
        this.H = IV3[7] | 0;
      }
      get() {
        const { A: A2, B: B4, C: C10, D: D4, E: E4, F: F4, G: G4, H } = this;
        return [A2, B4, C10, D4, E4, F4, G4, H];
      }
      // prettier-ignore
      set(A2, B4, C10, D4, E4, F4, G4, H) {
        this.A = A2 | 0;
        this.B = B4 | 0;
        this.C = C10 | 0;
        this.D = D4 | 0;
        this.E = E4 | 0;
        this.F = F4 | 0;
        this.G = G4 | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i17 = 0; i17 < 16; i17++, offset += 4)
          SHA256_W2[i17] = view.getUint32(offset, false);
        for (let i17 = 16; i17 < 64; i17++) {
          const W15 = SHA256_W2[i17 - 15];
          const W22 = SHA256_W2[i17 - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W22, 17) ^ (0, utils_js_1.rotr)(W22, 19) ^ W22 >>> 10;
          SHA256_W2[i17] = s1 + SHA256_W2[i17 - 7] + s0 + SHA256_W2[i17 - 16] | 0;
        }
        let { A: A2, B: B4, C: C10, D: D4, E: E4, F: F4, G: G4, H } = this;
        for (let i17 = 0; i17 < 64; i17++) {
          const sigma1 = (0, utils_js_1.rotr)(E4, 6) ^ (0, utils_js_1.rotr)(E4, 11) ^ (0, utils_js_1.rotr)(E4, 25);
          const T1 = H + sigma1 + Chi2(E4, F4, G4) + SHA256_K2[i17] + SHA256_W2[i17] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A2, 2) ^ (0, utils_js_1.rotr)(A2, 13) ^ (0, utils_js_1.rotr)(A2, 22);
          const T2 = sigma0 + Maj2(A2, B4, C10) | 0;
          H = G4;
          G4 = F4;
          F4 = E4;
          E4 = D4 + T1 | 0;
          D4 = C10;
          C10 = B4;
          B4 = A2;
          A2 = T1 + T2 | 0;
        }
        A2 = A2 + this.A | 0;
        B4 = B4 + this.B | 0;
        C10 = C10 + this.C | 0;
        D4 = D4 + this.D | 0;
        E4 = E4 + this.E | 0;
        F4 = F4 + this.F | 0;
        G4 = G4 + this.G | 0;
        H = H + this.H | 0;
        this.set(A2, B4, C10, D4, E4, F4, G4, H);
      }
      roundClean() {
        SHA256_W2.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA2242 = class extends SHA2562 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA2562());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA2242());
  }
});

// node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK642 = BigInt(2 ** 32 - 1);
    var _32n2 = BigInt(32);
    function fromBig2(n17, le = false) {
      if (le)
        return { h: Number(n17 & U32_MASK642), l: Number(n17 >> _32n2 & U32_MASK642) };
      return { h: Number(n17 >> _32n2 & U32_MASK642) | 0, l: Number(n17 & U32_MASK642) | 0 };
    }
    exports.fromBig = fromBig2;
    function split2(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i17 = 0; i17 < lst.length; i17++) {
        const { h: h7, l: l9 } = fromBig2(lst[i17], le);
        [Ah[i17], Al[i17]] = [h7, l9];
      }
      return [Ah, Al];
    }
    exports.split = split2;
    var toBig2 = (h7, l9) => BigInt(h7 >>> 0) << _32n2 | BigInt(l9 >>> 0);
    exports.toBig = toBig2;
    var shrSH2 = (h7, l9, s9) => h7 >>> s9;
    var shrSL2 = (h7, l9, s9) => h7 << 32 - s9 | l9 >>> s9;
    var rotrSH2 = (h7, l9, s9) => h7 >>> s9 | l9 << 32 - s9;
    var rotrSL2 = (h7, l9, s9) => h7 << 32 - s9 | l9 >>> s9;
    var rotrBH2 = (h7, l9, s9) => h7 << 64 - s9 | l9 >>> s9 - 32;
    var rotrBL2 = (h7, l9, s9) => h7 >>> s9 - 32 | l9 << 64 - s9;
    var rotr32H2 = (h7, l9) => l9;
    var rotr32L2 = (h7, l9) => h7;
    var rotlSH2 = (h7, l9, s9) => h7 << s9 | l9 >>> 32 - s9;
    var rotlSL2 = (h7, l9, s9) => l9 << s9 | h7 >>> 32 - s9;
    var rotlBH2 = (h7, l9, s9) => l9 << s9 - 32 | h7 >>> 64 - s9;
    var rotlBL2 = (h7, l9, s9) => h7 << s9 - 32 | l9 >>> 64 - s9;
    function add2(Ah, Al, Bh, Bl) {
      const l9 = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l9 / 2 ** 32 | 0) | 0, l: l9 | 0 };
    }
    exports.add = add2;
    var add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    var add4L2 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    var add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    var add5L2 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    var add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    var u642 = {
      fromBig: fromBig2,
      split: split2,
      toBig: exports.toBig,
      shrSH: shrSH2,
      shrSL: shrSL2,
      rotrSH: rotrSH2,
      rotrSL: rotrSL2,
      rotrBH: rotrBH2,
      rotrBL: rotrBL2,
      rotr32H: rotr32H2,
      rotr32L: rotr32L2,
      rotlSH: rotlSH2,
      rotlSL: rotlSL2,
      rotlBH: rotlBH2,
      rotlBL: rotlBL2,
      add: add2,
      add3L: add3L2,
      add3H: add3H2,
      add4L: add4L2,
      add4H: add4H2,
      add5H: add5H2,
      add5L: add5L2
    };
    exports.default = u642;
  }
});

// node_modules/@noble/hashes/sha512.js
var require_sha512 = __commonJS({
  "node_modules/@noble/hashes/sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
    var _sha2_js_1 = require_sha2();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils();
    var [SHA512_Kh2, SHA512_Kl2] = _u64_js_1.default.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n17) => BigInt(n17)));
    var SHA512_W_H2 = new Uint32Array(80);
    var SHA512_W_L2 = new Uint32Array(80);
    var SHA5122 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(128, 64, 16, false);
        this.Ah = 1779033703 | 0;
        this.Al = 4089235720 | 0;
        this.Bh = 3144134277 | 0;
        this.Bl = 2227873595 | 0;
        this.Ch = 1013904242 | 0;
        this.Cl = 4271175723 | 0;
        this.Dh = 2773480762 | 0;
        this.Dl = 1595750129 | 0;
        this.Eh = 1359893119 | 0;
        this.El = 2917565137 | 0;
        this.Fh = 2600822924 | 0;
        this.Fl = 725511199 | 0;
        this.Gh = 528734635 | 0;
        this.Gl = 4215389547 | 0;
        this.Hh = 1541459225 | 0;
        this.Hl = 327033209 | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i17 = 0; i17 < 16; i17++, offset += 4) {
          SHA512_W_H2[i17] = view.getUint32(offset);
          SHA512_W_L2[i17] = view.getUint32(offset += 4);
        }
        for (let i17 = 16; i17 < 80; i17++) {
          const W15h = SHA512_W_H2[i17 - 15] | 0;
          const W15l = SHA512_W_L2[i17 - 15] | 0;
          const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
          const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H2[i17 - 2] | 0;
          const W2l = SHA512_W_L2[i17 - 2] | 0;
          const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
          const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
          const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L2[i17 - 7], SHA512_W_L2[i17 - 16]);
          const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H2[i17 - 7], SHA512_W_H2[i17 - 16]);
          SHA512_W_H2[i17] = SUMh | 0;
          SHA512_W_L2[i17] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i17 = 0; i17 < 80; i17++) {
          const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
          const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl2[i17], SHA512_W_L2[i17]);
          const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh2[i17], SHA512_W_H2[i17]);
          const T1l = T1ll | 0;
          const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
          const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
          Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        SHA512_W_H2.fill(0);
        SHA512_W_L2.fill(0);
      }
      destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports.SHA512 = SHA5122;
    var SHA512_2242 = class extends SHA5122 {
      constructor() {
        super();
        this.Ah = 2352822216 | 0;
        this.Al = 424955298 | 0;
        this.Bh = 1944164710 | 0;
        this.Bl = 2312950998 | 0;
        this.Ch = 502970286 | 0;
        this.Cl = 855612546 | 0;
        this.Dh = 1738396948 | 0;
        this.Dl = 1479516111 | 0;
        this.Eh = 258812777 | 0;
        this.El = 2077511080 | 0;
        this.Fh = 2011393907 | 0;
        this.Fl = 79989058 | 0;
        this.Gh = 1067287976 | 0;
        this.Gl = 1780299464 | 0;
        this.Hh = 286451373 | 0;
        this.Hl = 2446758561 | 0;
        this.outputLen = 28;
      }
    };
    var SHA512_2562 = class extends SHA5122 {
      constructor() {
        super();
        this.Ah = 573645204 | 0;
        this.Al = 4230739756 | 0;
        this.Bh = 2673172387 | 0;
        this.Bl = 3360449730 | 0;
        this.Ch = 596883563 | 0;
        this.Cl = 1867755857 | 0;
        this.Dh = 2520282905 | 0;
        this.Dl = 1497426621 | 0;
        this.Eh = 2519219938 | 0;
        this.El = 2827943907 | 0;
        this.Fh = 3193839141 | 0;
        this.Fl = 1401305490 | 0;
        this.Gh = 721525244 | 0;
        this.Gl = 746961066 | 0;
        this.Hh = 246885852 | 0;
        this.Hl = 2177182882 | 0;
        this.outputLen = 32;
      }
    };
    var SHA3842 = class extends SHA5122 {
      constructor() {
        super();
        this.Ah = 3418070365 | 0;
        this.Al = 3238371032 | 0;
        this.Bh = 1654270250 | 0;
        this.Bl = 914150663 | 0;
        this.Ch = 2438529370 | 0;
        this.Cl = 812702999 | 0;
        this.Dh = 355462360 | 0;
        this.Dl = 4144912697 | 0;
        this.Eh = 1731405415 | 0;
        this.El = 4290775857 | 0;
        this.Fh = 2394180231 | 0;
        this.Fl = 1750603025 | 0;
        this.Gh = 3675008525 | 0;
        this.Gl = 1694076839 | 0;
        this.Hh = 1203062813 | 0;
        this.Hl = 3204075428 | 0;
        this.outputLen = 48;
      }
    };
    exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA5122());
    exports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_2242());
    exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_2562());
    exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA3842());
  }
});

// node_modules/@scure/base/lib/index.js
var require_lib = __commonJS({
  "node_modules/@scure/base/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;
    function assertNumber2(n17) {
      if (!Number.isSafeInteger(n17))
        throw new Error(`Wrong integer: ${n17}`);
    }
    exports.assertNumber = assertNumber2;
    function chain2(...args) {
      const wrap = (a10, b5) => (c11) => a10(b5(c11));
      const encode3 = Array.from(args).reverse().reduce((acc, i17) => acc ? wrap(acc, i17.encode) : i17.encode, void 0);
      const decode3 = args.reduce((acc, i17) => acc ? wrap(acc, i17.decode) : i17.decode, void 0);
      return { encode: encode3, decode: decode3 };
    }
    function alphabet2(alphabet3) {
      return {
        encode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("alphabet.encode input should be an array of numbers");
          return digits.map((i17) => {
            assertNumber2(i17);
            if (i17 < 0 || i17 >= alphabet3.length)
              throw new Error(`Digit index outside alphabet: ${i17} (alphabet: ${alphabet3.length})`);
            return alphabet3[i17];
          });
        },
        decode: (input) => {
          if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
            throw new Error("alphabet.decode input should be array of strings");
          return input.map((letter) => {
            if (typeof letter !== "string")
              throw new Error(`alphabet.decode: not string element=${letter}`);
            const index = alphabet3.indexOf(letter);
            if (index === -1)
              throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet3}`);
            return index;
          });
        }
      };
    }
    function join2(separator = "") {
      if (typeof separator !== "string")
        throw new Error("join separator should be string");
      return {
        encode: (from) => {
          if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
            throw new Error("join.encode input should be array of strings");
          for (let i17 of from)
            if (typeof i17 !== "string")
              throw new Error(`join.encode: non-string input=${i17}`);
          return from.join(separator);
        },
        decode: (to) => {
          if (typeof to !== "string")
            throw new Error("join.decode input should be string");
          return to.split(separator);
        }
      };
    }
    function padding2(bits, chr = "=") {
      assertNumber2(bits);
      if (typeof chr !== "string")
        throw new Error("padding chr should be string");
      return {
        encode(data) {
          if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
            throw new Error("padding.encode input should be array of strings");
          for (let i17 of data)
            if (typeof i17 !== "string")
              throw new Error(`padding.encode: non-string input=${i17}`);
          while (data.length * bits % 8)
            data.push(chr);
          return data;
        },
        decode(input) {
          if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
            throw new Error("padding.encode input should be array of strings");
          for (let i17 of input)
            if (typeof i17 !== "string")
              throw new Error(`padding.decode: non-string input=${i17}`);
          let end = input.length;
          if (end * bits % 8)
            throw new Error("Invalid padding: string should have whole number of bytes");
          for (; end > 0 && input[end - 1] === chr; end--) {
            if (!((end - 1) * bits % 8))
              throw new Error("Invalid padding: string has too much padding");
          }
          return input.slice(0, end);
        }
      };
    }
    function normalize2(fn) {
      if (typeof fn !== "function")
        throw new Error("normalize fn should be function");
      return { encode: (from) => from, decode: (to) => fn(to) };
    }
    function convertRadix3(data, from, to) {
      if (from < 2)
        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
      if (to < 2)
        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
      if (!Array.isArray(data))
        throw new Error("convertRadix: data should be array");
      if (!data.length)
        return [];
      let pos = 0;
      const res = [];
      const digits = Array.from(data);
      digits.forEach((d15) => {
        assertNumber2(d15);
        if (d15 < 0 || d15 >= from)
          throw new Error(`Wrong integer: ${d15}`);
      });
      while (true) {
        let carry = 0;
        let done = true;
        for (let i17 = pos; i17 < digits.length; i17++) {
          const digit = digits[i17];
          const digitBase = from * carry + digit;
          if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
            throw new Error("convertRadix: carry overflow");
          }
          carry = digitBase % to;
          digits[i17] = Math.floor(digitBase / to);
          if (!Number.isSafeInteger(digits[i17]) || digits[i17] * to + carry !== digitBase)
            throw new Error("convertRadix: carry overflow");
          if (!done)
            continue;
          else if (!digits[i17])
            pos = i17;
          else
            done = false;
        }
        res.push(carry);
        if (done)
          break;
      }
      for (let i17 = 0; i17 < data.length - 1 && data[i17] === 0; i17++)
        res.push(0);
      return res.reverse();
    }
    var gcd2 = (a10, b5) => !b5 ? a10 : gcd2(b5, a10 % b5);
    var radix2carry2 = (from, to) => from + (to - gcd2(from, to));
    function convertRadix22(data, from, to, padding3) {
      if (!Array.isArray(data))
        throw new Error("convertRadix2: data should be array");
      if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
      if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
      if (radix2carry2(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry2(from, to)}`);
      }
      let carry = 0;
      let pos = 0;
      const mask2 = 2 ** to - 1;
      const res = [];
      for (const n17 of data) {
        assertNumber2(n17);
        if (n17 >= 2 ** from)
          throw new Error(`convertRadix2: invalid data word=${n17} from=${from}`);
        carry = carry << from | n17;
        if (pos + from > 32)
          throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for (; pos >= to; pos -= to)
          res.push((carry >> pos - to & mask2) >>> 0);
        carry &= 2 ** pos - 1;
      }
      carry = carry << to - pos & mask2;
      if (!padding3 && pos >= from)
        throw new Error("Excess padding");
      if (!padding3 && carry)
        throw new Error(`Non-zero padding: ${carry}`);
      if (padding3 && pos > 0)
        res.push(carry >>> 0);
      return res;
    }
    function radix3(num) {
      assertNumber2(num);
      return {
        encode: (bytes2) => {
          if (!(bytes2 instanceof Uint8Array))
            throw new Error("radix.encode input should be Uint8Array");
          return convertRadix3(Array.from(bytes2), 2 ** 8, num);
        },
        decode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("radix.decode input should be array of strings");
          return Uint8Array.from(convertRadix3(digits, num, 2 ** 8));
        }
      };
    }
    function radix22(bits, revPadding = false) {
      assertNumber2(bits);
      if (bits <= 0 || bits > 32)
        throw new Error("radix2: bits should be in (0..32]");
      if (radix2carry2(8, bits) > 32 || radix2carry2(bits, 8) > 32)
        throw new Error("radix2: carry overflow");
      return {
        encode: (bytes2) => {
          if (!(bytes2 instanceof Uint8Array))
            throw new Error("radix2.encode input should be Uint8Array");
          return convertRadix22(Array.from(bytes2), 8, bits, !revPadding);
        },
        decode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("radix2.decode input should be array of strings");
          return Uint8Array.from(convertRadix22(digits, bits, 8, revPadding));
        }
      };
    }
    function unsafeWrapper2(fn) {
      if (typeof fn !== "function")
        throw new Error("unsafeWrapper fn should be function");
      return function(...args) {
        try {
          return fn.apply(null, args);
        } catch (e16) {
        }
      };
    }
    function checksum2(len, fn) {
      assertNumber2(len);
      if (typeof fn !== "function")
        throw new Error("checksum fn should be function");
      return {
        encode(data) {
          if (!(data instanceof Uint8Array))
            throw new Error("checksum.encode: input should be Uint8Array");
          const checksum3 = fn(data).slice(0, len);
          const res = new Uint8Array(data.length + len);
          res.set(data);
          res.set(checksum3, data.length);
          return res;
        },
        decode(data) {
          if (!(data instanceof Uint8Array))
            throw new Error("checksum.decode: input should be Uint8Array");
          const payload = data.slice(0, -len);
          const newChecksum = fn(payload).slice(0, len);
          const oldChecksum = data.slice(-len);
          for (let i17 = 0; i17 < len; i17++)
            if (newChecksum[i17] !== oldChecksum[i17])
              throw new Error("Invalid checksum");
          return payload;
        }
      };
    }
    exports.utils = { alphabet: alphabet2, chain: chain2, checksum: checksum2, radix: radix3, radix2: radix22, join: join2, padding: padding2 };
    exports.base16 = chain2(radix22(4), alphabet2("0123456789ABCDEF"), join2(""));
    exports.base32 = chain2(radix22(5), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding2(5), join2(""));
    exports.base32hex = chain2(radix22(5), alphabet2("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding2(5), join2(""));
    exports.base32crockford = chain2(radix22(5), alphabet2("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join2(""), normalize2((s9) => s9.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
    exports.base64 = chain2(radix22(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding2(6), join2(""));
    exports.base64url = chain2(radix22(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding2(6), join2(""));
    var genBase582 = (abc) => chain2(radix3(58), alphabet2(abc), join2(""));
    exports.base58 = genBase582("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    exports.base58flickr = genBase582("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
    exports.base58xrp = genBase582("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    var XMR_BLOCK_LEN2 = [0, 2, 3, 5, 6, 7, 9, 10, 11];
    exports.base58xmr = {
      encode(data) {
        let res = "";
        for (let i17 = 0; i17 < data.length; i17 += 8) {
          const block = data.subarray(i17, i17 + 8);
          res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN2[block.length], "1");
        }
        return res;
      },
      decode(str) {
        let res = [];
        for (let i17 = 0; i17 < str.length; i17 += 11) {
          const slice = str.slice(i17, i17 + 11);
          const blockLen = XMR_BLOCK_LEN2.indexOf(slice.length);
          const block = exports.base58.decode(slice);
          for (let j2 = 0; j2 < block.length - blockLen; j2++) {
            if (block[j2] !== 0)
              throw new Error("base58xmr: wrong padding");
          }
          res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
      }
    };
    var base58check3 = (sha2562) => chain2(checksum2(4, (data) => sha2562(sha2562(data))), exports.base58);
    exports.base58check = base58check3;
    var BECH_ALPHABET2 = chain2(alphabet2("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join2(""));
    var POLYMOD_GENERATORS2 = [996825010, 642813549, 513874426, 1027748829, 705979059];
    function bech32Polymod2(pre) {
      const b5 = pre >> 25;
      let chk = (pre & 33554431) << 5;
      for (let i17 = 0; i17 < POLYMOD_GENERATORS2.length; i17++) {
        if ((b5 >> i17 & 1) === 1)
          chk ^= POLYMOD_GENERATORS2[i17];
      }
      return chk;
    }
    function bechChecksum2(prefix, words, encodingConst = 1) {
      const len = prefix.length;
      let chk = 1;
      for (let i17 = 0; i17 < len; i17++) {
        const c11 = prefix.charCodeAt(i17);
        if (c11 < 33 || c11 > 126)
          throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod2(chk) ^ c11 >> 5;
      }
      chk = bech32Polymod2(chk);
      for (let i17 = 0; i17 < len; i17++)
        chk = bech32Polymod2(chk) ^ prefix.charCodeAt(i17) & 31;
      for (let v7 of words)
        chk = bech32Polymod2(chk) ^ v7;
      for (let i17 = 0; i17 < 6; i17++)
        chk = bech32Polymod2(chk);
      chk ^= encodingConst;
      return BECH_ALPHABET2.encode(convertRadix22([chk % 2 ** 30], 30, 5, false));
    }
    function genBech322(encoding) {
      const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
      const _words = radix22(5);
      const fromWords = _words.decode;
      const toWords = _words.encode;
      const fromWordsUnsafe = unsafeWrapper2(fromWords);
      function encode3(prefix, words, limit = 90) {
        if (typeof prefix !== "string")
          throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
        if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
          throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
        const actualLength = prefix.length + 7 + words.length;
        if (limit !== false && actualLength > limit)
          throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        prefix = prefix.toLowerCase();
        return `${prefix}1${BECH_ALPHABET2.encode(words)}${bechChecksum2(prefix, words, ENCODING_CONST)}`;
      }
      function decode3(str, limit = 90) {
        if (typeof str !== "string")
          throw new Error(`bech32.decode input should be string, not ${typeof str}`);
        if (str.length < 8 || limit !== false && str.length > limit)
          throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
          throw new Error(`String must be lowercase or uppercase`);
        str = lowered;
        const sepIndex = str.lastIndexOf("1");
        if (sepIndex === 0 || sepIndex === -1)
          throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = str.slice(0, sepIndex);
        const _words2 = str.slice(sepIndex + 1);
        if (_words2.length < 6)
          throw new Error("Data must be at least 6 characters long");
        const words = BECH_ALPHABET2.decode(_words2).slice(0, -6);
        const sum = bechChecksum2(prefix, words, ENCODING_CONST);
        if (!_words2.endsWith(sum))
          throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix, words };
      }
      const decodeUnsafe = unsafeWrapper2(decode3);
      function decodeToBytes(str) {
        const { prefix, words } = decode3(str, false);
        return { prefix, words, bytes: fromWords(words) };
      }
      return { encode: encode3, decode: decode3, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
    }
    exports.bech32 = genBech322("bech32");
    exports.bech32m = genBech322("bech32m");
    exports.utf8 = {
      encode: (data) => new TextDecoder().decode(data),
      decode: (str) => new TextEncoder().encode(str)
    };
    exports.hex = chain2(radix22(4), alphabet2("0123456789abcdef"), join2(""), normalize2((s9) => {
      if (typeof s9 !== "string" || s9.length % 2)
        throw new TypeError(`hex.decode: expected string, got ${typeof s9} with length ${s9.length}`);
      return s9.toLowerCase();
    }));
    var CODERS2 = {
      utf8: exports.utf8,
      hex: exports.hex,
      base16: exports.base16,
      base32: exports.base32,
      base64: exports.base64,
      base64url: exports.base64url,
      base58: exports.base58,
      base58xmr: exports.base58xmr
    };
    var coderTypeError2 = `Invalid encoding type. Available types: ${Object.keys(CODERS2).join(", ")}`;
    var bytesToString = (type2, bytes2) => {
      if (typeof type2 !== "string" || !CODERS2.hasOwnProperty(type2))
        throw new TypeError(coderTypeError2);
      if (!(bytes2 instanceof Uint8Array))
        throw new TypeError("bytesToString() expects Uint8Array");
      return CODERS2[type2].encode(bytes2);
    };
    exports.bytesToString = bytesToString;
    exports.str = exports.bytesToString;
    var stringToBytes2 = (type2, str) => {
      if (!CODERS2.hasOwnProperty(type2))
        throw new TypeError(coderTypeError2);
      if (typeof str !== "string")
        throw new TypeError("stringToBytes() expects string");
      return CODERS2[type2].decode(str);
    };
    exports.stringToBytes = stringToBytes2;
    exports.bytes = exports.stringToBytes;
  }
});

// node_modules/@scure/bip39/index.js
var require_bip39 = __commonJS({
  "node_modules/@scure/bip39/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;
    var _assert_1 = require_assert();
    var pbkdf2_1 = require_pbkdf2();
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var utils_1 = require_utils();
    var base_1 = require_lib();
    var isJapanese = (wordlist) => wordlist[0] === "";
    function nfkd(str) {
      if (typeof str !== "string")
        throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
      return str.normalize("NFKD");
    }
    function normalize2(str) {
      const norm = nfkd(str);
      const words = norm.split(" ");
      if (![12, 15, 18, 21, 24].includes(words.length))
        throw new Error("Invalid mnemonic");
      return { nfkd: norm, words };
    }
    function assertEntropy(entropy) {
      _assert_1.default.bytes(entropy, 16, 20, 24, 28, 32);
    }
    function generateMnemonic(wordlist, strength = 128) {
      _assert_1.default.number(strength);
      if (strength % 32 !== 0 || strength > 256)
        throw new TypeError("Invalid entropy");
      return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);
    }
    exports.generateMnemonic = generateMnemonic;
    var calcChecksum = (entropy) => {
      const bitsLeft = 8 - entropy.length / 4;
      return new Uint8Array([(0, sha256_1.sha256)(entropy)[0] >> bitsLeft << bitsLeft]);
    };
    function getCoder(wordlist) {
      if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== "string")
        throw new Error("Worlist: expected array of 2048 strings");
      wordlist.forEach((i17) => {
        if (typeof i17 !== "string")
          throw new Error(`Wordlist: non-string element: ${i17}`);
      });
      return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));
    }
    function mnemonicToEntropy(mnemonic, wordlist) {
      const { words } = normalize2(mnemonic);
      const entropy = getCoder(wordlist).decode(words);
      assertEntropy(entropy);
      return entropy;
    }
    exports.mnemonicToEntropy = mnemonicToEntropy;
    function entropyToMnemonic(entropy, wordlist) {
      assertEntropy(entropy);
      const words = getCoder(wordlist).encode(entropy);
      return words.join(isJapanese(wordlist) ? "" : " ");
    }
    exports.entropyToMnemonic = entropyToMnemonic;
    function validateMnemonic(mnemonic, wordlist) {
      try {
        mnemonicToEntropy(mnemonic, wordlist);
      } catch (e16) {
        return false;
      }
      return true;
    }
    exports.validateMnemonic = validateMnemonic;
    var salt = (passphrase) => nfkd(`mnemonic${passphrase}`);
    function mnemonicToSeed2(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize2(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
    }
    exports.mnemonicToSeed = mnemonicToSeed2;
    function mnemonicToSeedSync(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize2(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
    }
    exports.mnemonicToSeedSync = mnemonicToSeedSync;
  }
});

// node_modules/uuid/dist/esm-browser/rng.js
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var getRandomValues, rnds8;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-browser/rng.js"() {
    rnds8 = new Uint8Array(16);
  }
});

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist/esm-browser/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/uuid/dist/esm-browser/validate.js
function validate2(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/uuid/dist/esm-browser/validate.js"() {
    init_regex();
    validate_default = validate2;
  }
});

// node_modules/uuid/dist/esm-browser/stringify.js
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, i17, stringify_default;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-browser/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (i17 = 0; i17 < 256; ++i17) {
      byteToHex.push((i17 + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/uuid/dist/esm-browser/v1.js
function v1(options, buf, offset) {
  var i17 = buf && offset || 0;
  var b5 = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt2 = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt2 < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt2 < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b5[i17++] = tl >>> 24 & 255;
  b5[i17++] = tl >>> 16 & 255;
  b5[i17++] = tl >>> 8 & 255;
  b5[i17++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b5[i17++] = tmh >>> 8 & 255;
  b5[i17++] = tmh & 255;
  b5[i17++] = tmh >>> 24 & 15 | 16;
  b5[i17++] = tmh >>> 16 & 255;
  b5[i17++] = clockseq >>> 8 | 128;
  b5[i17++] = clockseq & 255;
  for (var n17 = 0; n17 < 6; ++n17) {
    b5[i17 + n17] = node[n17];
  }
  return buf || stringify_default(b5);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-browser/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v7;
  var arr = new Uint8Array(16);
  arr[0] = (v7 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v7 >>> 16 & 255;
  arr[2] = v7 >>> 8 & 255;
  arr[3] = v7 & 255;
  arr[4] = (v7 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v7 & 255;
  arr[6] = (v7 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v7 & 255;
  arr[8] = (v7 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v7 & 255;
  arr[10] = (v7 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v7 / 4294967296 & 255;
  arr[12] = v7 >>> 24 & 255;
  arr[13] = v7 >>> 16 & 255;
  arr[14] = v7 >>> 8 & 255;
  arr[15] = v7 & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/uuid/dist/esm-browser/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes2 = [];
  for (var i17 = 0; i17 < str.length; ++i17) {
    bytes2.push(str.charCodeAt(i17));
  }
  return bytes2;
}
function v35_default(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes2 = new Uint8Array(16 + value.length);
    bytes2.set(namespace);
    bytes2.set(value, namespace.length);
    bytes2 = hashfunc(bytes2);
    bytes2[6] = bytes2[6] & 15 | version2;
    bytes2[8] = bytes2[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i17 = 0; i17 < 16; ++i17) {
        buf[offset + i17] = bytes2[i17];
      }
      return buf;
    }
    return stringify_default(bytes2);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/uuid/dist/esm-browser/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes2) {
  if (typeof bytes2 === "string") {
    var msg = unescape(encodeURIComponent(bytes2));
    bytes2 = new Uint8Array(msg.length);
    for (var i17 = 0; i17 < msg.length; ++i17) {
      bytes2[i17] = msg.charCodeAt(i17);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes2), bytes2.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output2 = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i17 = 0; i17 < length32; i17 += 8) {
    var x5 = input[i17 >> 5] >>> i17 % 32 & 255;
    var hex2 = parseInt(hexTab.charAt(x5 >>> 4 & 15) + hexTab.charAt(x5 & 15), 16);
    output2.push(hex2);
  }
  return output2;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x5, len) {
  x5[len >> 5] |= 128 << len % 32;
  x5[getOutputLength(len) - 1] = len;
  var a10 = 1732584193;
  var b5 = -271733879;
  var c11 = -1732584194;
  var d15 = 271733878;
  for (var i17 = 0; i17 < x5.length; i17 += 16) {
    var olda = a10;
    var oldb = b5;
    var oldc = c11;
    var oldd = d15;
    a10 = md5ff(a10, b5, c11, d15, x5[i17], 7, -680876936);
    d15 = md5ff(d15, a10, b5, c11, x5[i17 + 1], 12, -389564586);
    c11 = md5ff(c11, d15, a10, b5, x5[i17 + 2], 17, 606105819);
    b5 = md5ff(b5, c11, d15, a10, x5[i17 + 3], 22, -1044525330);
    a10 = md5ff(a10, b5, c11, d15, x5[i17 + 4], 7, -176418897);
    d15 = md5ff(d15, a10, b5, c11, x5[i17 + 5], 12, 1200080426);
    c11 = md5ff(c11, d15, a10, b5, x5[i17 + 6], 17, -1473231341);
    b5 = md5ff(b5, c11, d15, a10, x5[i17 + 7], 22, -45705983);
    a10 = md5ff(a10, b5, c11, d15, x5[i17 + 8], 7, 1770035416);
    d15 = md5ff(d15, a10, b5, c11, x5[i17 + 9], 12, -1958414417);
    c11 = md5ff(c11, d15, a10, b5, x5[i17 + 10], 17, -42063);
    b5 = md5ff(b5, c11, d15, a10, x5[i17 + 11], 22, -1990404162);
    a10 = md5ff(a10, b5, c11, d15, x5[i17 + 12], 7, 1804603682);
    d15 = md5ff(d15, a10, b5, c11, x5[i17 + 13], 12, -40341101);
    c11 = md5ff(c11, d15, a10, b5, x5[i17 + 14], 17, -1502002290);
    b5 = md5ff(b5, c11, d15, a10, x5[i17 + 15], 22, 1236535329);
    a10 = md5gg(a10, b5, c11, d15, x5[i17 + 1], 5, -165796510);
    d15 = md5gg(d15, a10, b5, c11, x5[i17 + 6], 9, -1069501632);
    c11 = md5gg(c11, d15, a10, b5, x5[i17 + 11], 14, 643717713);
    b5 = md5gg(b5, c11, d15, a10, x5[i17], 20, -373897302);
    a10 = md5gg(a10, b5, c11, d15, x5[i17 + 5], 5, -701558691);
    d15 = md5gg(d15, a10, b5, c11, x5[i17 + 10], 9, 38016083);
    c11 = md5gg(c11, d15, a10, b5, x5[i17 + 15], 14, -660478335);
    b5 = md5gg(b5, c11, d15, a10, x5[i17 + 4], 20, -405537848);
    a10 = md5gg(a10, b5, c11, d15, x5[i17 + 9], 5, 568446438);
    d15 = md5gg(d15, a10, b5, c11, x5[i17 + 14], 9, -1019803690);
    c11 = md5gg(c11, d15, a10, b5, x5[i17 + 3], 14, -187363961);
    b5 = md5gg(b5, c11, d15, a10, x5[i17 + 8], 20, 1163531501);
    a10 = md5gg(a10, b5, c11, d15, x5[i17 + 13], 5, -1444681467);
    d15 = md5gg(d15, a10, b5, c11, x5[i17 + 2], 9, -51403784);
    c11 = md5gg(c11, d15, a10, b5, x5[i17 + 7], 14, 1735328473);
    b5 = md5gg(b5, c11, d15, a10, x5[i17 + 12], 20, -1926607734);
    a10 = md5hh(a10, b5, c11, d15, x5[i17 + 5], 4, -378558);
    d15 = md5hh(d15, a10, b5, c11, x5[i17 + 8], 11, -2022574463);
    c11 = md5hh(c11, d15, a10, b5, x5[i17 + 11], 16, 1839030562);
    b5 = md5hh(b5, c11, d15, a10, x5[i17 + 14], 23, -35309556);
    a10 = md5hh(a10, b5, c11, d15, x5[i17 + 1], 4, -1530992060);
    d15 = md5hh(d15, a10, b5, c11, x5[i17 + 4], 11, 1272893353);
    c11 = md5hh(c11, d15, a10, b5, x5[i17 + 7], 16, -155497632);
    b5 = md5hh(b5, c11, d15, a10, x5[i17 + 10], 23, -1094730640);
    a10 = md5hh(a10, b5, c11, d15, x5[i17 + 13], 4, 681279174);
    d15 = md5hh(d15, a10, b5, c11, x5[i17], 11, -358537222);
    c11 = md5hh(c11, d15, a10, b5, x5[i17 + 3], 16, -722521979);
    b5 = md5hh(b5, c11, d15, a10, x5[i17 + 6], 23, 76029189);
    a10 = md5hh(a10, b5, c11, d15, x5[i17 + 9], 4, -640364487);
    d15 = md5hh(d15, a10, b5, c11, x5[i17 + 12], 11, -421815835);
    c11 = md5hh(c11, d15, a10, b5, x5[i17 + 15], 16, 530742520);
    b5 = md5hh(b5, c11, d15, a10, x5[i17 + 2], 23, -995338651);
    a10 = md5ii(a10, b5, c11, d15, x5[i17], 6, -198630844);
    d15 = md5ii(d15, a10, b5, c11, x5[i17 + 7], 10, 1126891415);
    c11 = md5ii(c11, d15, a10, b5, x5[i17 + 14], 15, -1416354905);
    b5 = md5ii(b5, c11, d15, a10, x5[i17 + 5], 21, -57434055);
    a10 = md5ii(a10, b5, c11, d15, x5[i17 + 12], 6, 1700485571);
    d15 = md5ii(d15, a10, b5, c11, x5[i17 + 3], 10, -1894986606);
    c11 = md5ii(c11, d15, a10, b5, x5[i17 + 10], 15, -1051523);
    b5 = md5ii(b5, c11, d15, a10, x5[i17 + 1], 21, -2054922799);
    a10 = md5ii(a10, b5, c11, d15, x5[i17 + 8], 6, 1873313359);
    d15 = md5ii(d15, a10, b5, c11, x5[i17 + 15], 10, -30611744);
    c11 = md5ii(c11, d15, a10, b5, x5[i17 + 6], 15, -1560198380);
    b5 = md5ii(b5, c11, d15, a10, x5[i17 + 13], 21, 1309151649);
    a10 = md5ii(a10, b5, c11, d15, x5[i17 + 4], 6, -145523070);
    d15 = md5ii(d15, a10, b5, c11, x5[i17 + 11], 10, -1120210379);
    c11 = md5ii(c11, d15, a10, b5, x5[i17 + 2], 15, 718787259);
    b5 = md5ii(b5, c11, d15, a10, x5[i17 + 9], 21, -343485551);
    a10 = safeAdd(a10, olda);
    b5 = safeAdd(b5, oldb);
    c11 = safeAdd(c11, oldc);
    d15 = safeAdd(d15, oldd);
  }
  return [a10, b5, c11, d15];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output2 = new Uint32Array(getOutputLength(length8));
  for (var i17 = 0; i17 < length8; i17 += 8) {
    output2[i17 >> 5] |= (input[i17 / 8] & 255) << i17 % 32;
  }
  return output2;
}
function safeAdd(x5, y6) {
  var lsw = (x5 & 65535) + (y6 & 65535);
  var msw = (x5 >> 16) + (y6 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q2, a10, b5, x5, s9, t18) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a10, q2), safeAdd(x5, t18)), s9), b5);
}
function md5ff(a10, b5, c11, d15, x5, s9, t18) {
  return md5cmn(b5 & c11 | ~b5 & d15, a10, b5, x5, s9, t18);
}
function md5gg(a10, b5, c11, d15, x5, s9, t18) {
  return md5cmn(b5 & d15 | c11 & ~d15, a10, b5, x5, s9, t18);
}
function md5hh(a10, b5, c11, d15, x5, s9, t18) {
  return md5cmn(b5 ^ c11 ^ d15, a10, b5, x5, s9, t18);
}
function md5ii(a10, b5, c11, d15, x5, s9, t18) {
  return md5cmn(c11 ^ (b5 | ~d15), a10, b5, x5, s9, t18);
}
var md5_default;
var init_md5 = __esm({
  "node_modules/uuid/dist/esm-browser/md5.js"() {
    md5_default = md5;
  }
});

// node_modules/uuid/dist/esm-browser/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/uuid/dist/esm-browser/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i17 = 0; i17 < 16; ++i17) {
      buf[offset + i17] = rnds[i17];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-browser/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-browser/sha1.js
function f2(s9, x5, y6, z) {
  switch (s9) {
    case 0:
      return x5 & y6 ^ ~x5 & z;
    case 1:
      return x5 ^ y6 ^ z;
    case 2:
      return x5 & y6 ^ x5 & z ^ y6 & z;
    case 3:
      return x5 ^ y6 ^ z;
  }
}
function ROTL(x5, n17) {
  return x5 << n17 | x5 >>> 32 - n17;
}
function sha1(bytes2) {
  var K2 = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes2 === "string") {
    var msg = unescape(encodeURIComponent(bytes2));
    bytes2 = [];
    for (var i17 = 0; i17 < msg.length; ++i17) {
      bytes2.push(msg.charCodeAt(i17));
    }
  } else if (!Array.isArray(bytes2)) {
    bytes2 = Array.prototype.slice.call(bytes2);
  }
  bytes2.push(128);
  var l9 = bytes2.length / 4 + 2;
  var N4 = Math.ceil(l9 / 16);
  var M5 = new Array(N4);
  for (var _i = 0; _i < N4; ++_i) {
    var arr = new Uint32Array(16);
    for (var j2 = 0; j2 < 16; ++j2) {
      arr[j2] = bytes2[_i * 64 + j2 * 4] << 24 | bytes2[_i * 64 + j2 * 4 + 1] << 16 | bytes2[_i * 64 + j2 * 4 + 2] << 8 | bytes2[_i * 64 + j2 * 4 + 3];
    }
    M5[_i] = arr;
  }
  M5[N4 - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
  M5[N4 - 1][14] = Math.floor(M5[N4 - 1][14]);
  M5[N4 - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N4; ++_i2) {
    var W5 = new Uint32Array(80);
    for (var t18 = 0; t18 < 16; ++t18) {
      W5[t18] = M5[_i2][t18];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W5[_t] = ROTL(W5[_t - 3] ^ W5[_t - 8] ^ W5[_t - 14] ^ W5[_t - 16], 1);
    }
    var a10 = H[0];
    var b5 = H[1];
    var c11 = H[2];
    var d15 = H[3];
    var e16 = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s9 = Math.floor(_t2 / 20);
      var T = ROTL(a10, 5) + f2(s9, b5, c11, d15) + e16 + K2[s9] + W5[_t2] >>> 0;
      e16 = d15;
      d15 = c11;
      c11 = ROTL(b5, 30) >>> 0;
      b5 = a10;
      a10 = T;
    }
    H[0] = H[0] + a10 >>> 0;
    H[1] = H[1] + b5 >>> 0;
    H[2] = H[2] + c11 >>> 0;
    H[3] = H[3] + d15 >>> 0;
    H[4] = H[4] + e16 >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist/esm-browser/sha1.js"() {
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist/esm-browser/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/uuid/dist/esm-browser/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/uuid/dist/esm-browser/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/uuid/dist/esm-browser/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/uuid/dist/esm-browser/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/uuid/dist/esm-browser/version.js"() {
    init_validate();
    version_default = version;
  }
});

// node_modules/uuid/dist/esm-browser/index.js
var esm_browser_exports = {};
__export(esm_browser_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_browser = __esm({
  "node_modules/uuid/dist/esm-browser/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// node_modules/jayson/lib/generateRequest.js
var require_generateRequest = __commonJS({
  "node_modules/jayson/lib/generateRequest.js"(exports, module) {
    "use strict";
    var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;
    var generateRequest = function(method, params, id, options) {
      if (typeof method !== "string") {
        throw new TypeError(method + " must be a string");
      }
      options = options || {};
      const version2 = typeof options.version === "number" ? options.version : 2;
      if (version2 !== 1 && version2 !== 2) {
        throw new TypeError(version2 + " must be 1 or 2");
      }
      const request = {
        method
      };
      if (version2 === 2) {
        request.jsonrpc = "2.0";
      }
      if (params) {
        if (typeof params !== "object" && !Array.isArray(params)) {
          throw new TypeError(params + " must be an object, array or omitted");
        }
        request.params = params;
      }
      if (typeof id === "undefined") {
        const generator = typeof options.generator === "function" ? options.generator : function() {
          return uuid();
        };
        request.id = generator(request, options);
      } else if (version2 === 2 && id === null) {
        if (options.notificationIdNull) {
          request.id = null;
        }
      } else {
        request.id = id;
      }
      return request;
    };
    module.exports = generateRequest;
  }
});

// node_modules/jayson/lib/client/browser/index.js
var require_browser = __commonJS({
  "node_modules/jayson/lib/client/browser/index.js"(exports, module) {
    "use strict";
    var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;
    var generateRequest = require_generateRequest();
    var ClientBrowser = function(callServer, options) {
      if (!(this instanceof ClientBrowser)) {
        return new ClientBrowser(callServer, options);
      }
      if (!options) {
        options = {};
      }
      this.options = {
        reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
        replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
        generator: typeof options.generator !== "undefined" ? options.generator : function() {
          return uuid();
        },
        version: typeof options.version !== "undefined" ? options.version : 2,
        notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
      };
      this.callServer = callServer;
    };
    module.exports = ClientBrowser;
    ClientBrowser.prototype.request = function(method, params, id, callback) {
      const self2 = this;
      let request = null;
      const isBatch = Array.isArray(method) && typeof params === "function";
      if (this.options.version === 1 && isBatch) {
        throw new TypeError("JSON-RPC 1.0 does not support batching");
      }
      const isRaw = !isBatch && method && typeof method === "object" && typeof params === "function";
      if (isBatch || isRaw) {
        callback = params;
        request = method;
      } else {
        if (typeof id === "function") {
          callback = id;
          id = void 0;
        }
        const hasCallback = typeof callback === "function";
        try {
          request = generateRequest(method, params, id, {
            generator: this.options.generator,
            version: this.options.version,
            notificationIdNull: this.options.notificationIdNull
          });
        } catch (err) {
          if (hasCallback) {
            return callback(err);
          }
          throw err;
        }
        if (!hasCallback) {
          return request;
        }
      }
      let message;
      try {
        message = JSON.stringify(request, this.options.replacer);
      } catch (err) {
        return callback(err);
      }
      this.callServer(message, function(err, response) {
        self2._parseResponse(err, response, callback);
      });
      return request;
    };
    ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
      if (err) {
        callback(err);
        return;
      }
      if (!responseText) {
        return callback();
      }
      let response;
      try {
        response = JSON.parse(responseText, this.options.reviver);
      } catch (err2) {
        return callback(err2);
      }
      if (callback.length === 3) {
        if (Array.isArray(response)) {
          const isError = function(res) {
            return typeof res.error !== "undefined";
          };
          const isNotError = function(res) {
            return !isError(res);
          };
          return callback(null, response.filter(isError), response.filter(isNotError));
        } else {
          return callback(null, response.error, response.result);
        }
      }
      callback(null, response);
    };
  }
});

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports, module) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(obj);
    }
    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS({
  "node_modules/@babel/runtime/helpers/toPrimitive.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS({
  "node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    var toPrimitive = require_toPrimitive();
    function _toPropertyKey(arg) {
      var key = toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS({
  "node_modules/@babel/runtime/helpers/createClass.js"(exports, module) {
    var toPropertyKey = require_toPropertyKey();
    function _defineProperties(target, props) {
      for (var i17 = 0; i17 < props.length; i17++) {
        var descriptor = props[i17];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS({
  "node_modules/@babel/runtime/helpers/classCallCheck.js"(exports, module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports, module) {
    function _setPrototypeOf(o18, p12) {
      module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o19, p13) {
        o19.__proto__ = p13;
        return o19;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _setPrototypeOf(o18, p12);
    }
    module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/inherits.js
var require_inherits = __commonJS({
  "node_modules/@babel/runtime/helpers/inherits.js"(exports, module) {
    var setPrototypeOf = require_setPrototypeOf();
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass)
        setPrototypeOf(subClass, superClass);
    }
    module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/assertThisInitialized.js
var require_assertThisInitialized = __commonJS({
  "node_modules/@babel/runtime/helpers/assertThisInitialized.js"(exports, module) {
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var require_possibleConstructorReturn = __commonJS({
  "node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    var assertThisInitialized = require_assertThisInitialized();
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return assertThisInitialized(self2);
    }
    module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS({
  "node_modules/@babel/runtime/helpers/getPrototypeOf.js"(exports, module) {
    function _getPrototypeOf(o18) {
      module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o19) {
        return o19.__proto__ || Object.getPrototypeOf(o19);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _getPrototypeOf(o18);
    }
    module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners2(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i17 = 0, l9 = handlers.length, ee2 = new Array(l9); i17 < l9; i17++) {
        ee2[i17] = handlers[i17].fn;
      }
      return ee2;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
      if (!listeners2)
        return 0;
      if (listeners2.fn)
        return 1;
      return listeners2.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a22, a32, a42, a52) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners2 = this._events[evt], len = arguments.length, args, i17;
      if (listeners2.fn) {
        if (listeners2.once)
          this.removeListener(event, listeners2.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners2.fn.call(listeners2.context), true;
          case 2:
            return listeners2.fn.call(listeners2.context, a1), true;
          case 3:
            return listeners2.fn.call(listeners2.context, a1, a22), true;
          case 4:
            return listeners2.fn.call(listeners2.context, a1, a22, a32), true;
          case 5:
            return listeners2.fn.call(listeners2.context, a1, a22, a32, a42), true;
          case 6:
            return listeners2.fn.call(listeners2.context, a1, a22, a32, a42, a52), true;
        }
        for (i17 = 1, args = new Array(len - 1); i17 < len; i17++) {
          args[i17 - 1] = arguments[i17];
        }
        listeners2.fn.apply(listeners2.context, args);
      } else {
        var length = listeners2.length, j2;
        for (i17 = 0; i17 < length; i17++) {
          if (listeners2[i17].once)
            this.removeListener(event, listeners2[i17].fn, void 0, true);
          switch (len) {
            case 1:
              listeners2[i17].fn.call(listeners2[i17].context);
              break;
            case 2:
              listeners2[i17].fn.call(listeners2[i17].context, a1);
              break;
            case 3:
              listeners2[i17].fn.call(listeners2[i17].context, a1, a22);
              break;
            case 4:
              listeners2[i17].fn.call(listeners2[i17].context, a1, a22, a32);
              break;
            default:
              if (!args)
                for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                  args[j2 - 1] = arguments[j2];
                }
              listeners2[i17].fn.apply(listeners2[i17].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on2(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners2 = this._events[evt];
      if (listeners2.fn) {
        if (listeners2.fn === fn && (!once || listeners2.once) && (!context || listeners2.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i17 = 0, events = [], length = listeners2.length; i17 < length; i17++) {
          if (listeners2[i17].fn !== fn || once && !listeners2[i17].once || context && listeners2[i17].context !== context) {
            events.push(listeners2[i17]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter;
    }
  }
});

// node_modules/rpc-websockets/dist/lib/client/websocket.browser.js
var require_websocket_browser = __commonJS({
  "node_modules/rpc-websockets/dist/lib/client/websocket.browser.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = _default;
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _eventemitter = require_eventemitter3();
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2["default"])(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2["default"])(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e16) {
        return false;
      }
    }
    var WebSocketBrowserImpl = function(_EventEmitter) {
      (0, _inherits2["default"])(WebSocketBrowserImpl2, _EventEmitter);
      var _super = _createSuper(WebSocketBrowserImpl2);
      function WebSocketBrowserImpl2(address, options, protocols) {
        var _this;
        (0, _classCallCheck2["default"])(this, WebSocketBrowserImpl2);
        _this = _super.call(this);
        _this.socket = new window.WebSocket(address, protocols);
        _this.socket.onopen = function() {
          return _this.emit("open");
        };
        _this.socket.onmessage = function(event) {
          return _this.emit("message", event.data);
        };
        _this.socket.onerror = function(error) {
          return _this.emit("error", error);
        };
        _this.socket.onclose = function(event) {
          _this.emit("close", event.code, event.reason);
        };
        return _this;
      }
      (0, _createClass2["default"])(WebSocketBrowserImpl2, [{
        key: "send",
        value: function send(data, optionsOrCallback, callback) {
          var cb = callback || optionsOrCallback;
          try {
            this.socket.send(data);
            cb();
          } catch (error) {
            cb(error);
          }
        }
        /**
         * Closes an underlying socket
         * @method
         * @param {Number} code - status code explaining why the connection is being closed
         * @param {String} reason - a description why the connection is closing
         * @return {Undefined}
         * @throws {Error}
         */
      }, {
        key: "close",
        value: function close(code, reason) {
          this.socket.close(code, reason);
        }
      }, {
        key: "addEventListener",
        value: function addEventListener(type2, listener, options) {
          this.socket.addEventListener(type2, listener, options);
        }
      }]);
      return WebSocketBrowserImpl2;
    }(_eventemitter.EventEmitter);
    function _default(address, options) {
      return new WebSocketBrowserImpl(address, options);
    }
  }
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    function _regeneratorRuntime() {
      "use strict";
      module.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
        return exports2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var exports2 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define3(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        }), obj[key];
      }
      try {
        define3({}, "");
      } catch (err) {
        define3 = function define4(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
        return defineProperty(generator, "_invoke", {
          value: makeInvokeMethod(innerFn, self2, context)
        }), generator;
      }
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      exports2.wrap = wrap;
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define3(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define3(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record2 = tryCatch(generator[method], generator, arg);
          if ("throw" !== record2.type) {
            var result = record2.arg, value = result.value;
            return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
          reject(record2.arg);
        }
        var previousPromise;
        defineProperty(this, "_invoke", {
          value: function value(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(innerFn, self2, context) {
        var state = "suspendedStart";
        return function(method, arg) {
          if ("executing" === state)
            throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method)
              throw arg;
            return doneResult();
          }
          for (context.method = method, context.arg = arg; ; ) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if ("next" === context.method)
              context.sent = context._sent = context.arg;
            else if ("throw" === context.method) {
              if ("suspendedStart" === state)
                throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else
              "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record2 = tryCatch(innerFn, self2, context);
            if ("normal" === record2.type) {
              if (state = context.done ? "completed" : "suspendedYield", record2.arg === ContinueSentinel)
                continue;
              return {
                value: record2.arg,
                done: context.done
              };
            }
            "throw" === record2.type && (state = "completed", context.method = "throw", context.arg = record2.arg);
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method, method = delegate.iterator[methodName];
        if (void 0 === method)
          return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
        var record2 = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record2.type)
          return context.method = "throw", context.arg = record2.arg, context.delegate = null, ContinueSentinel;
        var info = record2.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record2 = entry.completion || {};
        record2.type = "normal", delete record2.arg, entry.completion = record2;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod)
            return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next)
            return iterable;
          if (!isNaN(iterable.length)) {
            var i17 = -1, next = function next2() {
              for (; ++i17 < iterable.length; )
                if (hasOwn.call(iterable, i17))
                  return next2.value = iterable[i17], next2.done = false, next2;
              return next2.value = void 0, next2.done = true, next2;
            };
            return next.next = next;
          }
        }
        return {
          next: doneResult
        };
      }
      function doneResult() {
        return {
          value: void 0,
          done: true
        };
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), defineProperty(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define3(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports2.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports2.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define3(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports2.awrap = function(arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define3(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      }), exports2.AsyncIterator = AsyncIterator, exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define3(Gp, toStringTagSymbol, "Generator"), define3(Gp, iteratorSymbol, function() {
        return this;
      }), define3(Gp, "toString", function() {
        return "[object Generator]";
      }), exports2.keys = function(val) {
        var object2 = Object(val), keys = [];
        for (var key in object2)
          keys.push(key);
        return keys.reverse(), function next() {
          for (; keys.length; ) {
            var key2 = keys.pop();
            if (key2 in object2)
              return next.value = key2, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, exports2.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
            for (var name in this)
              "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
        },
        stop: function stop() {
          this.done = true;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type)
            throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done)
            throw exception;
          var context = this;
          function handle(loc, caught) {
            return record2.type = "throw", record2.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
          }
          for (var i17 = this.tryEntries.length - 1; i17 >= 0; --i17) {
            var entry = this.tryEntries[i17], record2 = entry.completion;
            if ("root" === entry.tryLoc)
              return handle("end");
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
              } else {
                if (!hasFinally)
                  throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type2, arg) {
          for (var i17 = this.tryEntries.length - 1; i17 >= 0; --i17) {
            var entry = this.tryEntries[i17];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          finallyEntry && ("break" === type2 || "continue" === type2) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record2 = finallyEntry ? finallyEntry.completion : {};
          return record2.type = type2, record2.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record2);
        },
        complete: function complete(record2, afterLoc) {
          if ("throw" === record2.type)
            throw record2.arg;
          return "break" === record2.type || "continue" === record2.type ? this.next = record2.arg : "return" === record2.type ? (this.rval = this.arg = record2.arg, this.method = "return", this.next = "end") : "normal" === record2.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i17 = this.tryEntries.length - 1; i17 >= 0; --i17) {
            var entry = this.tryEntries[i17];
            if (entry.finallyLoc === finallyLoc)
              return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i17 = this.tryEntries.length - 1; i17 >= 0; --i17) {
            var entry = this.tryEntries[i17];
            if (entry.tryLoc === tryLoc) {
              var record2 = entry.completion;
              if ("throw" === record2.type) {
                var thrown = record2.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
        }
      }, exports2;
    }
    module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    var runtime = require_regeneratorRuntime()();
    module.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@babel/runtime/helpers/asyncToGenerator.js
var require_asyncToGenerator = __commonJS({
  "node_modules/@babel/runtime/helpers/asyncToGenerator.js"(exports, module) {
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/rpc-websockets/dist/lib/client.js
var require_client = __commonJS({
  "node_modules/rpc-websockets/dist/lib/client.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _eventemitter = require_eventemitter3();
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2["default"])(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2["default"])(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e16) {
        return false;
      }
    }
    var __rest = function(s9, e16) {
      var t18 = {};
      for (var p12 in s9) {
        if (Object.prototype.hasOwnProperty.call(s9, p12) && e16.indexOf(p12) < 0)
          t18[p12] = s9[p12];
      }
      if (s9 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i17 = 0, p12 = Object.getOwnPropertySymbols(s9); i17 < p12.length; i17++) {
          if (e16.indexOf(p12[i17]) < 0 && Object.prototype.propertyIsEnumerable.call(s9, p12[i17]))
            t18[p12[i17]] = s9[p12[i17]];
        }
      return t18;
    };
    var CommonClient = function(_EventEmitter) {
      (0, _inherits2["default"])(CommonClient2, _EventEmitter);
      var _super = _createSuper(CommonClient2);
      function CommonClient2(webSocketFactory) {
        var _this;
        var address = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "ws://localhost:8080";
        var _a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var generate_request_id = arguments.length > 3 ? arguments[3] : void 0;
        (0, _classCallCheck2["default"])(this, CommonClient2);
        var _a$autoconnect = _a.autoconnect, autoconnect = _a$autoconnect === void 0 ? true : _a$autoconnect, _a$reconnect = _a.reconnect, reconnect = _a$reconnect === void 0 ? true : _a$reconnect, _a$reconnect_interval = _a.reconnect_interval, reconnect_interval = _a$reconnect_interval === void 0 ? 1e3 : _a$reconnect_interval, _a$max_reconnects = _a.max_reconnects, max_reconnects = _a$max_reconnects === void 0 ? 5 : _a$max_reconnects, rest_options = __rest(_a, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
        _this = _super.call(this);
        _this.webSocketFactory = webSocketFactory;
        _this.queue = {};
        _this.rpc_id = 0;
        _this.address = address;
        _this.autoconnect = autoconnect;
        _this.ready = false;
        _this.reconnect = reconnect;
        _this.reconnect_timer_id = void 0;
        _this.reconnect_interval = reconnect_interval;
        _this.max_reconnects = max_reconnects;
        _this.rest_options = rest_options;
        _this.current_reconnects = 0;
        _this.generate_request_id = generate_request_id || function() {
          return ++_this.rpc_id;
        };
        if (_this.autoconnect)
          _this._connect(_this.address, Object.assign({
            autoconnect: _this.autoconnect,
            reconnect: _this.reconnect,
            reconnect_interval: _this.reconnect_interval,
            max_reconnects: _this.max_reconnects
          }, _this.rest_options));
        return _this;
      }
      (0, _createClass2["default"])(CommonClient2, [{
        key: "connect",
        value: function connect() {
          if (this.socket)
            return;
          this._connect(this.address, Object.assign({
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects
          }, this.rest_options));
        }
        /**
         * Calls a registered RPC method on server.
         * @method
         * @param {String} method - RPC method name
         * @param {Object|Array} params - optional method parameters
         * @param {Number} timeout - RPC reply timeout value
         * @param {Object} ws_opts - options passed to ws
         * @return {Promise}
         */
      }, {
        key: "call",
        value: function call(method, params, timeout, ws_opts) {
          var _this2 = this;
          if (!ws_opts && "object" === (0, _typeof2["default"])(timeout)) {
            ws_opts = timeout;
            timeout = null;
          }
          return new Promise(function(resolve, reject) {
            if (!_this2.ready)
              return reject(new Error("socket not ready"));
            var rpc_id = _this2.generate_request_id(method, params);
            var message = {
              jsonrpc: "2.0",
              method,
              params: params || null,
              id: rpc_id
            };
            _this2.socket.send(JSON.stringify(message), ws_opts, function(error) {
              if (error)
                return reject(error);
              _this2.queue[rpc_id] = {
                promise: [resolve, reject]
              };
              if (timeout) {
                _this2.queue[rpc_id].timeout = setTimeout(function() {
                  delete _this2.queue[rpc_id];
                  reject(new Error("reply timeout"));
                }, timeout);
              }
            });
          });
        }
        /**
         * Logins with the other side of the connection.
         * @method
         * @param {Object} params - Login credentials object
         * @return {Promise}
         */
      }, {
        key: "login",
        value: function() {
          var _login = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(params) {
            var resp;
            return _regenerator["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this.call("rpc.login", params);
                  case 2:
                    resp = _context.sent;
                    if (resp) {
                      _context.next = 5;
                      break;
                    }
                    throw new Error("authentication failed");
                  case 5:
                    return _context.abrupt("return", resp);
                  case 6:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function login(_x) {
            return _login.apply(this, arguments);
          }
          return login;
        }()
        /**
         * Fetches a list of client's methods registered on server.
         * @method
         * @return {Array}
         */
      }, {
        key: "listMethods",
        value: function() {
          var _listMethods = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2() {
            return _regenerator["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this.call("__listMethods");
                  case 2:
                    return _context2.abrupt("return", _context2.sent);
                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function listMethods() {
            return _listMethods.apply(this, arguments);
          }
          return listMethods;
        }()
        /**
         * Sends a JSON-RPC 2.0 notification to server.
         * @method
         * @param {String} method - RPC method name
         * @param {Object} params - optional method parameters
         * @return {Promise}
         */
      }, {
        key: "notify",
        value: function notify(method, params) {
          var _this3 = this;
          return new Promise(function(resolve, reject) {
            if (!_this3.ready)
              return reject(new Error("socket not ready"));
            var message = {
              jsonrpc: "2.0",
              method,
              params: params || null
            };
            _this3.socket.send(JSON.stringify(message), function(error) {
              if (error)
                return reject(error);
              resolve();
            });
          });
        }
        /**
         * Subscribes for a defined event.
         * @method
         * @param {String|Array} event - event name
         * @return {Undefined}
         * @throws {Error}
         */
      }, {
        key: "subscribe",
        value: function() {
          var _subscribe = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(event) {
            var result;
            return _regenerator["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (typeof event === "string")
                      event = [event];
                    _context3.next = 3;
                    return this.call("rpc.on", event);
                  case 3:
                    result = _context3.sent;
                    if (!(typeof event === "string" && result[event] !== "ok")) {
                      _context3.next = 6;
                      break;
                    }
                    throw new Error("Failed subscribing to an event '" + event + "' with: " + result[event]);
                  case 6:
                    return _context3.abrupt("return", result);
                  case 7:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function subscribe(_x2) {
            return _subscribe.apply(this, arguments);
          }
          return subscribe;
        }()
        /**
         * Unsubscribes from a defined event.
         * @method
         * @param {String|Array} event - event name
         * @return {Undefined}
         * @throws {Error}
         */
      }, {
        key: "unsubscribe",
        value: function() {
          var _unsubscribe = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4(event) {
            var result;
            return _regenerator["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (typeof event === "string")
                      event = [event];
                    _context4.next = 3;
                    return this.call("rpc.off", event);
                  case 3:
                    result = _context4.sent;
                    if (!(typeof event === "string" && result[event] !== "ok")) {
                      _context4.next = 6;
                      break;
                    }
                    throw new Error("Failed unsubscribing from an event with: " + result);
                  case 6:
                    return _context4.abrupt("return", result);
                  case 7:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function unsubscribe(_x3) {
            return _unsubscribe.apply(this, arguments);
          }
          return unsubscribe;
        }()
        /**
         * Closes a WebSocket connection gracefully.
         * @method
         * @param {Number} code - socket close code
         * @param {String} data - optional data to be sent before closing
         * @return {Undefined}
         */
      }, {
        key: "close",
        value: function close(code, data) {
          this.socket.close(code || 1e3, data);
        }
        /**
         * Connection/Message handler.
         * @method
         * @private
         * @param {String} address - WebSocket API address
         * @param {Object} options - ws options object
         * @return {Undefined}
         */
      }, {
        key: "_connect",
        value: function _connect(address, options) {
          var _this4 = this;
          clearTimeout(this.reconnect_timer_id);
          this.socket = this.webSocketFactory(address, options);
          this.socket.addEventListener("open", function() {
            _this4.ready = true;
            _this4.emit("open");
            _this4.current_reconnects = 0;
          });
          this.socket.addEventListener("message", function(_ref) {
            var message = _ref.data;
            if (message instanceof ArrayBuffer)
              message = Buffer.from(message).toString();
            try {
              message = JSON.parse(message);
            } catch (error) {
              return;
            }
            if (message.notification && _this4.listeners(message.notification).length) {
              if (!Object.keys(message.params).length)
                return _this4.emit(message.notification);
              var args = [message.notification];
              if (message.params.constructor === Object)
                args.push(message.params);
              else
                for (var i17 = 0; i17 < message.params.length; i17++) {
                  args.push(message.params[i17]);
                }
              return Promise.resolve().then(function() {
                _this4.emit.apply(_this4, args);
              });
            }
            if (!_this4.queue[message.id]) {
              if (message.method && message.params) {
                return Promise.resolve().then(function() {
                  _this4.emit(message.method, message.params);
                });
              }
              return;
            }
            if ("error" in message === "result" in message)
              _this4.queue[message.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.'));
            if (_this4.queue[message.id].timeout)
              clearTimeout(_this4.queue[message.id].timeout);
            if (message.error)
              _this4.queue[message.id].promise[1](message.error);
            else
              _this4.queue[message.id].promise[0](message.result);
            delete _this4.queue[message.id];
          });
          this.socket.addEventListener("error", function(error) {
            return _this4.emit("error", error);
          });
          this.socket.addEventListener("close", function(_ref2) {
            var code = _ref2.code, reason = _ref2.reason;
            if (_this4.ready)
              setTimeout(function() {
                return _this4.emit("close", code, reason);
              }, 0);
            _this4.ready = false;
            _this4.socket = void 0;
            if (code === 1e3)
              return;
            _this4.current_reconnects++;
            if (_this4.reconnect && (_this4.max_reconnects > _this4.current_reconnects || _this4.max_reconnects === 0))
              _this4.reconnect_timer_id = setTimeout(function() {
                return _this4._connect(address, options);
              }, _this4.reconnect_interval);
          });
        }
      }]);
      return CommonClient2;
    }(_eventemitter.EventEmitter);
    exports["default"] = CommonClient;
  }
});

// node_modules/rpc-websockets/dist/index.browser.js
var require_index_browser = __commonJS({
  "node_modules/rpc-websockets/dist/index.browser.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Client = void 0;
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _websocket = _interopRequireDefault(require_websocket_browser());
    var _client = _interopRequireDefault(require_client());
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2["default"])(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2["default"])(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e16) {
        return false;
      }
    }
    var Client = function(_CommonClient) {
      (0, _inherits2["default"])(Client2, _CommonClient);
      var _super = _createSuper(Client2);
      function Client2() {
        var address = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ws://localhost:8080";
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$autoconnect = _ref.autoconnect, autoconnect = _ref$autoconnect === void 0 ? true : _ref$autoconnect, _ref$reconnect = _ref.reconnect, reconnect = _ref$reconnect === void 0 ? true : _ref$reconnect, _ref$reconnect_interv = _ref.reconnect_interval, reconnect_interval = _ref$reconnect_interv === void 0 ? 1e3 : _ref$reconnect_interv, _ref$max_reconnects = _ref.max_reconnects, max_reconnects = _ref$max_reconnects === void 0 ? 5 : _ref$max_reconnects;
        var generate_request_id = arguments.length > 2 ? arguments[2] : void 0;
        (0, _classCallCheck2["default"])(this, Client2);
        return _super.call(this, _websocket["default"], address, {
          autoconnect,
          reconnect,
          reconnect_interval,
          max_reconnects
        }, generate_request_id);
      }
      return (0, _createClass2["default"])(Client2);
    }(_client["default"]);
    exports.Client = Client;
  }
});

// node_modules/@suchipi/femver/index.js
var require_femver = __commonJS({
  "node_modules/@suchipi/femver/index.js"(exports, module) {
    function isValid(versionString) {
      return /^\d+\.\d+\.\d+$/.test(versionString);
    }
    function parse2(versionString) {
      if (!isValid(versionString)) {
        throw new Error("Invalid semver version: " + versionString);
      }
      const [major, minor, patch] = versionString.split(".").map((part) => parseInt(part, 10));
      return { major, minor, patch };
    }
    function lt3(firstVersionString, secondVersionString) {
      const ver1 = parse2(firstVersionString);
      const ver2 = parse2(secondVersionString);
      if (ver1.major !== ver2.major) {
        return ver1.major < ver2.major;
      }
      if (ver1.minor !== ver2.minor) {
        return ver1.minor < ver2.minor;
      }
      if (ver1.patch !== ver2.patch) {
        return ver1.patch < ver2.patch;
      }
      return false;
    }
    function lte(firstVersionString, secondVersionString) {
      const ver1 = parse2(firstVersionString);
      const ver2 = parse2(secondVersionString);
      if (ver1.major !== ver2.major) {
        return ver1.major <= ver2.major;
      }
      if (ver1.minor !== ver2.minor) {
        return ver1.minor <= ver2.minor;
      }
      if (ver1.patch !== ver2.patch) {
        return ver1.patch <= ver2.patch;
      }
      return true;
    }
    function gt(firstVersionString, secondVersionString) {
      const ver1 = parse2(firstVersionString);
      const ver2 = parse2(secondVersionString);
      if (ver1.major !== ver2.major) {
        return ver1.major > ver2.major;
      }
      if (ver1.minor !== ver2.minor) {
        return ver1.minor > ver2.minor;
      }
      if (ver1.patch !== ver2.patch) {
        return ver1.patch > ver2.patch;
      }
      return false;
    }
    function gte(firstVersionString, secondVersionString) {
      const ver1 = parse2(firstVersionString);
      const ver2 = parse2(secondVersionString);
      if (ver1.major !== ver2.major) {
        return ver1.major >= ver2.major;
      }
      if (ver1.minor !== ver2.minor) {
        return ver1.minor >= ver2.minor;
      }
      if (ver1.patch !== ver2.patch) {
        return ver1.patch >= ver2.patch;
      }
      return true;
    }
    function eq(firstVersionString, secondVersionString) {
      parse2(firstVersionString);
      parse2(secondVersionString);
      return firstVersionString === secondVersionString;
    }
    module.exports = {
      isValid,
      parse: parse2,
      lt: lt3,
      lte,
      gt,
      gte,
      eq
    };
  }
});

// node_modules/store2/dist/store2.js
var require_store2 = __commonJS({
  "node_modules/store2/dist/store2.js"(exports, module) {
    (function(window2, define3) {
      var _2 = {
        version: "2.14.2",
        areas: {},
        apis: {},
        nsdelim: ".",
        // utilities
        inherit: function(api, o18) {
          for (var p12 in api) {
            if (!o18.hasOwnProperty(p12)) {
              Object.defineProperty(o18, p12, Object.getOwnPropertyDescriptor(api, p12));
            }
          }
          return o18;
        },
        stringify: function(d15, fn) {
          return d15 === void 0 || typeof d15 === "function" ? d15 + "" : JSON.stringify(d15, fn || _2.replace);
        },
        parse: function(s9, fn) {
          try {
            return JSON.parse(s9, fn || _2.revive);
          } catch (e16) {
            return s9;
          }
        },
        // extension hooks
        fn: function(name, fn) {
          _2.storeAPI[name] = fn;
          for (var api in _2.apis) {
            _2.apis[api][name] = fn;
          }
        },
        get: function(area, key) {
          return area.getItem(key);
        },
        set: function(area, key, string2) {
          area.setItem(key, string2);
        },
        remove: function(area, key) {
          area.removeItem(key);
        },
        key: function(area, i17) {
          return area.key(i17);
        },
        length: function(area) {
          return area.length;
        },
        clear: function(area) {
          area.clear();
        },
        // core functions
        Store: function(id, area, namespace) {
          var store2 = _2.inherit(_2.storeAPI, function(key, data, overwrite) {
            if (arguments.length === 0) {
              return store2.getAll();
            }
            if (typeof data === "function") {
              return store2.transact(key, data, overwrite);
            }
            if (data !== void 0) {
              return store2.set(key, data, overwrite);
            }
            if (typeof key === "string" || typeof key === "number") {
              return store2.get(key);
            }
            if (typeof key === "function") {
              return store2.each(key);
            }
            if (!key) {
              return store2.clear();
            }
            return store2.setAll(key, data);
          });
          store2._id = id;
          try {
            var testKey = "__store2_test";
            area.setItem(testKey, "ok");
            store2._area = area;
            area.removeItem(testKey);
          } catch (e16) {
            store2._area = _2.storage("fake");
          }
          store2._ns = namespace || "";
          if (!_2.areas[id]) {
            _2.areas[id] = store2._area;
          }
          if (!_2.apis[store2._ns + store2._id]) {
            _2.apis[store2._ns + store2._id] = store2;
          }
          return store2;
        },
        storeAPI: {
          // admin functions
          area: function(id, area) {
            var store2 = this[id];
            if (!store2 || !store2.area) {
              store2 = _2.Store(id, area, this._ns);
              if (!this[id]) {
                this[id] = store2;
              }
            }
            return store2;
          },
          namespace: function(namespace, singleArea, delim) {
            delim = delim || this._delim || _2.nsdelim;
            if (!namespace) {
              return this._ns ? this._ns.substring(0, this._ns.length - delim.length) : "";
            }
            var ns = namespace, store2 = this[ns];
            if (!store2 || !store2.namespace) {
              store2 = _2.Store(this._id, this._area, this._ns + ns + delim);
              store2._delim = delim;
              if (!this[ns]) {
                this[ns] = store2;
              }
              if (!singleArea) {
                for (var name in _2.areas) {
                  store2.area(name, _2.areas[name]);
                }
              }
            }
            return store2;
          },
          isFake: function(force) {
            if (force) {
              this._real = this._area;
              this._area = _2.storage("fake");
            } else if (force === false) {
              this._area = this._real || this._area;
            }
            return this._area.name === "fake";
          },
          toString: function() {
            return "store" + (this._ns ? "." + this.namespace() : "") + "[" + this._id + "]";
          },
          // storage functions
          has: function(key) {
            if (this._area.has) {
              return this._area.has(this._in(key));
            }
            return !!(this._in(key) in this._area);
          },
          size: function() {
            return this.keys().length;
          },
          each: function(fn, fill) {
            for (var i17 = 0, m12 = _2.length(this._area); i17 < m12; i17++) {
              var key = this._out(_2.key(this._area, i17));
              if (key !== void 0) {
                if (fn.call(this, key, this.get(key), fill) === false) {
                  break;
                }
              }
              if (m12 > _2.length(this._area)) {
                m12--;
                i17--;
              }
            }
            return fill || this;
          },
          keys: function(fillList) {
            return this.each(function(k4, v7, list) {
              list.push(k4);
            }, fillList || []);
          },
          get: function(key, alt) {
            var s9 = _2.get(this._area, this._in(key)), fn;
            if (typeof alt === "function") {
              fn = alt;
              alt = null;
            }
            return s9 !== null ? _2.parse(s9, fn) : alt != null ? alt : s9;
          },
          getAll: function(fillObj) {
            return this.each(function(k4, v7, all) {
              all[k4] = v7;
            }, fillObj || {});
          },
          transact: function(key, fn, alt) {
            var val = this.get(key, alt), ret = fn(val);
            this.set(key, ret === void 0 ? val : ret);
            return this;
          },
          set: function(key, data, overwrite) {
            var d15 = this.get(key), replacer;
            if (d15 != null && overwrite === false) {
              return data;
            }
            if (typeof overwrite === "function") {
              replacer = overwrite;
              overwrite = void 0;
            }
            return _2.set(this._area, this._in(key), _2.stringify(data, replacer), overwrite) || d15;
          },
          setAll: function(data, overwrite) {
            var changed, val;
            for (var key in data) {
              val = data[key];
              if (this.set(key, val, overwrite) !== val) {
                changed = true;
              }
            }
            return changed;
          },
          add: function(key, data, replacer) {
            var d15 = this.get(key);
            if (d15 instanceof Array) {
              data = d15.concat(data);
            } else if (d15 !== null) {
              var type2 = typeof d15;
              if (type2 === typeof data && type2 === "object") {
                for (var k4 in data) {
                  d15[k4] = data[k4];
                }
                data = d15;
              } else {
                data = d15 + data;
              }
            }
            _2.set(this._area, this._in(key), _2.stringify(data, replacer));
            return data;
          },
          remove: function(key, alt) {
            var d15 = this.get(key, alt);
            _2.remove(this._area, this._in(key));
            return d15;
          },
          clear: function() {
            if (!this._ns) {
              _2.clear(this._area);
            } else {
              this.each(function(k4) {
                _2.remove(this._area, this._in(k4));
              }, 1);
            }
            return this;
          },
          clearAll: function() {
            var area = this._area;
            for (var id in _2.areas) {
              if (_2.areas.hasOwnProperty(id)) {
                this._area = _2.areas[id];
                this.clear();
              }
            }
            this._area = area;
            return this;
          },
          // internal use functions
          _in: function(k4) {
            if (typeof k4 !== "string") {
              k4 = _2.stringify(k4);
            }
            return this._ns ? this._ns + k4 : k4;
          },
          _out: function(k4) {
            return this._ns ? k4 && k4.indexOf(this._ns) === 0 ? k4.substring(this._ns.length) : void 0 : (
              // so each() knows to skip it
              k4
            );
          }
        },
        // end _.storeAPI
        storage: function(name) {
          return _2.inherit(_2.storageAPI, { items: {}, name });
        },
        storageAPI: {
          length: 0,
          has: function(k4) {
            return this.items.hasOwnProperty(k4);
          },
          key: function(i17) {
            var c11 = 0;
            for (var k4 in this.items) {
              if (this.has(k4) && i17 === c11++) {
                return k4;
              }
            }
          },
          setItem: function(k4, v7) {
            if (!this.has(k4)) {
              this.length++;
            }
            this.items[k4] = v7;
          },
          removeItem: function(k4) {
            if (this.has(k4)) {
              delete this.items[k4];
              this.length--;
            }
          },
          getItem: function(k4) {
            return this.has(k4) ? this.items[k4] : null;
          },
          clear: function() {
            for (var k4 in this.items) {
              this.removeItem(k4);
            }
          }
        }
        // end _.storageAPI
      };
      var store = (
        // safely set this up (throws error in IE10/32bit mode for local files)
        _2.Store("local", function() {
          try {
            return localStorage;
          } catch (e16) {
          }
        }())
      );
      store.local = store;
      store._ = _2;
      store.area("session", function() {
        try {
          return sessionStorage;
        } catch (e16) {
        }
      }());
      store.area("page", _2.storage("page"));
      if (typeof define3 === "function" && define3.amd !== void 0) {
        define3("store2", [], function() {
          return store;
        });
      } else if (typeof module !== "undefined" && module.exports) {
        module.exports = store;
      } else {
        if (window2.store) {
          _2.conflict = window2.store;
        }
        window2.store = store;
      }
    })(exports, exports && exports.define);
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER2 = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "c",
        "": "D",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "N",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "Y",
        "": "y",
        "": "y",
        "": "Ae",
        "": "ae",
        "": "Th",
        "": "th",
        "": "ss",
        // Latin Extended-A block.
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "D",
        "": "D",
        "": "d",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "H",
        "": "H",
        "": "h",
        "": "h",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "J",
        "": "j",
        "": "K",
        "": "k",
        "": "k",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "R",
        "": "R",
        "": "R",
        "": "r",
        "": "r",
        "": "r",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "T",
        "": "T",
        "": "T",
        "": "t",
        "": "t",
        "": "t",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "W",
        "": "w",
        "": "Y",
        "": "y",
        "": "Y",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "z",
        "": "z",
        "": "z",
        "": "IJ",
        "": "ij",
        "": "Oe",
        "": "oe",
        "": "'n",
        "": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e16) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array2, setter, iteratee, accumulator) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          var value = array2[index];
          setter(accumulator, value, iteratee(value), array2);
        }
        return accumulator;
      }
      function arrayEach(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (iteratee(array2[index], index, array2) === false) {
            break;
          }
        }
        return array2;
      }
      function arrayEachRight(array2, iteratee) {
        var length = array2 == null ? 0 : array2.length;
        while (length--) {
          if (iteratee(array2[length], length, array2) === false) {
            break;
          }
        }
        return array2;
      }
      function arrayEvery(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (!predicate(array2[index], index, array2)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (predicate(value, index, array2)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array2, value) {
        var length = array2 == null ? 0 : array2.length;
        return !!length && baseIndexOf(array2, value, 0) > -1;
      }
      function arrayIncludesWith(array2, value, comparator) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (comparator(value, array2[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array2[index], index, array2);
        }
        return result;
      }
      function arrayPush(array2, values) {
        var index = -1, length = values.length, offset = array2.length;
        while (++index < length) {
          array2[offset + index] = values[index];
        }
        return array2;
      }
      function arrayReduce(array2, iteratee, accumulator, initAccum) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        if (initAccum && length) {
          accumulator = array2[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array2[index], index, array2);
        }
        return accumulator;
      }
      function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
        var length = array2 == null ? 0 : array2.length;
        if (initAccum && length) {
          accumulator = array2[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array2[length], length, array2);
        }
        return accumulator;
      }
      function arraySome(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (predicate(array2[index], index, array2)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string2) {
        return string2.split("");
      }
      function asciiWords(string2) {
        return string2.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array2, predicate, fromIndex, fromRight) {
        var length = array2.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array2[index], index, array2)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array2, value, fromIndex) {
        return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array2, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array2.length;
        while (++index < length) {
          if (comparator(array2[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array2, iteratee) {
        var length = array2 == null ? 0 : array2.length;
        return length ? baseSum(array2, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object2) {
          return object2 == null ? undefined2 : object2[key];
        };
      }
      function basePropertyOf(object2) {
        return function(key) {
          return object2 == null ? undefined2 : object2[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array2, comparer) {
        var length = array2.length;
        array2.sort(comparer);
        while (length--) {
          array2[length] = array2[length].value;
        }
        return array2;
      }
      function baseSum(array2, iteratee) {
        var result, index = -1, length = array2.length;
        while (++index < length) {
          var current = iteratee(array2[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n17, iteratee) {
        var index = -1, result = Array(n17);
        while (++index < n17) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object2, props) {
        return arrayMap(props, function(key) {
          return [key, object2[key]];
        });
      }
      function baseTrim(string2) {
        return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object2, props) {
        return arrayMap(props, function(key) {
          return object2[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array2, placeholder) {
        var length = array2.length, result = 0;
        while (length--) {
          if (array2[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object2, key) {
        return object2 == null ? undefined2 : object2[key];
      }
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      function hasUnicodeWord(string2) {
        return reHasUnicodeWord.test(string2);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array2, placeholder) {
        var index = -1, length = array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array2[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array2, value, fromIndex) {
        var index = fromIndex - 1, length = array2.length;
        while (++index < length) {
          if (array2[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array2, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array2[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string2) {
        return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
      }
      function stringToArray(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      function trimmedEndIndex(string2) {
        var index = string2.length;
        while (index-- && reWhitespace.test(string2.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string2) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string2)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string2) {
        return string2.match(reUnicode) || [];
      }
      function unicodeWords(string2) {
        return string2.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e16) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object2() {
          }
          return function(proto) {
            if (!isObject2(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object2.prototype = proto;
            var result2 = new object2();
            object2.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array2, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array2[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed = iteratee2(value);
                if (type2 == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type2 == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash2(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash2.prototype.clear = hashClear;
        Hash2.prototype["delete"] = hashDelete;
        Hash2.prototype.get = hashGet;
        Hash2.prototype.has = hashHas;
        Hash2.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash2(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash2()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array2) {
          var length = array2.length;
          return length ? array2[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array2, n17) {
          return shuffleSelf(copyArray(array2), baseClamp(n17, 0, array2.length));
        }
        function arrayShuffle(array2) {
          return shuffleSelf(copyArray(array2));
        }
        function assignMergeValue(object2, key, value) {
          if (value !== undefined2 && !eq(object2[key], value) || value === undefined2 && !(key in object2)) {
            baseAssignValue(object2, key, value);
          }
        }
        function assignValue(object2, key, value) {
          var objValue = object2[key];
          if (!(hasOwnProperty.call(object2, key) && eq(objValue, value)) || value === undefined2 && !(key in object2)) {
            baseAssignValue(object2, key, value);
          }
        }
        function assocIndexOf(array2, key) {
          var length = array2.length;
          while (length--) {
            if (eq(array2[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object2, source) {
          return object2 && copyObject(source, keys(source), object2);
        }
        function baseAssignIn(object2, source) {
          return object2 && copyObject(source, keysIn(source), object2);
        }
        function baseAssignValue(object2, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object2, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object2[key] = value;
          }
        }
        function baseAt(object2, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object2 == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get2(object2, paths[index]);
          }
          return result2;
        }
        function baseClamp(number3, lower, upper) {
          if (number3 === number3) {
            if (upper !== undefined2) {
              number3 = number3 <= upper ? number3 : upper;
            }
            if (lower !== undefined2) {
              number3 = number3 >= lower ? number3 : lower;
            }
          }
          return number3;
        }
        function baseClone(value, bitmask, customizer, key, object2, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object2 ? customizer(value, key, object2, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object2) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object2 ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object2) {
            return baseConformsTo(object2, source, props);
          };
        }
        function baseConformsTo(object2, source, props) {
          var length = props.length;
          if (object2 == null) {
            return !length;
          }
          object2 = Object2(object2);
          while (length--) {
            var key = props[length], predicate = source[key], value = object2[key];
            if (value === undefined2 && !(key in object2) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array2, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array2.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array2[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array2, iteratee2, comparator) {
          var index = -1, length = array2.length;
          while (++index < length) {
            var value = array2[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array2, value, start, end) {
          var length = array2.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array2[start++] = value;
          }
          return array2;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array2, depth, predicate, isStrict, result2) {
          var index = -1, length = array2.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array2[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object2, iteratee2) {
          return object2 && baseFor(object2, iteratee2, keys);
        }
        function baseForOwnRight(object2, iteratee2) {
          return object2 && baseForRight(object2, iteratee2, keys);
        }
        function baseFunctions(object2, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object2[key]);
          });
        }
        function baseGet(object2, path) {
          path = castPath(path, object2);
          var index = 0, length = path.length;
          while (object2 != null && index < length) {
            object2 = object2[toKey(path[index++])];
          }
          return index && index == length ? object2 : undefined2;
        }
        function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object2);
          return isArray(object2) ? result2 : arrayPush(result2, symbolsFunc(object2));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object2, key) {
          return object2 != null && hasOwnProperty.call(object2, key);
        }
        function baseHasIn(object2, key) {
          return object2 != null && key in Object2(object2);
        }
        function baseInRange(number3, start, end) {
          return number3 >= nativeMin(start, end) && number3 < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array2 = arrays[othIndex];
            if (othIndex && iteratee2) {
              array2 = arrayMap(array2, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array2.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined2;
          }
          array2 = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object2, setter, iteratee2, accumulator) {
          baseForOwn(object2, function(value, key, object3) {
            setter(accumulator, iteratee2(value), key, object3);
          });
          return accumulator;
        }
        function baseInvoke(object2, path, args) {
          path = castPath(path, object2);
          object2 = parent(object2, path);
          var func = object2 == null ? object2 : object2[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object2, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object2)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object2, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object2 == null) {
            return !length;
          }
          object2 = Object2(object2);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object2[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object2)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object2, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object2) {
          if (!isPrototype(object2)) {
            return nativeKeys(object2);
          }
          var result2 = [];
          for (var key in Object2(object2)) {
            if (hasOwnProperty.call(object2, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object2) {
          if (!isObject2(object2)) {
            return nativeKeysIn(object2);
          }
          var isProto = isPrototype(object2), result2 = [];
          for (var key in object2) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object2, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object2) {
            return object2 === source || baseIsMatch(object2, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object2) {
            var objValue = get2(object2, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object2, source, srcIndex, customizer, stack) {
          if (object2 === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject2(srcValue)) {
              baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object2, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object2, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject2(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object2, key, newValue);
        }
        function baseNth(array2, n17) {
          var length = array2.length;
          if (!length) {
            return;
          }
          n17 += n17 < 0 ? length : 0;
          return isIndex(n17, length) ? array2[n17] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object2, other) {
            return compareMultiple(object2, other, orders);
          });
        }
        function basePick(object2, paths) {
          return basePickBy(object2, paths, function(value, path) {
            return hasIn(object2, path);
          });
        }
        function basePickBy(object2, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object2, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object2), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object2) {
            return baseGet(object2, path);
          };
        }
        function basePullAll(array2, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array2;
          if (array2 === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array2, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array2) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array2, fromIndex, 1);
            }
          }
          return array2;
        }
        function basePullAt(array2, indexes) {
          var length = array2 ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array2, index, 1);
              } else {
                baseUnset(array2, index);
              }
            }
          }
          return array2;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string2, n17) {
          var result2 = "";
          if (!string2 || n17 < 1 || n17 > MAX_SAFE_INTEGER2) {
            return result2;
          }
          do {
            if (n17 % 2) {
              result2 += string2;
            }
            n17 = nativeFloor(n17 / 2);
            if (n17) {
              string2 += string2;
            }
          } while (n17);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n17) {
          var array2 = values(collection);
          return shuffleSelf(array2, baseClamp(n17, 0, array2.length));
        }
        function baseSet(object2, path, value, customizer) {
          if (!isObject2(object2)) {
            return object2;
          }
          path = castPath(path, object2);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object2;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object2;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object2;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string2) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string2),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array2, start, end) {
          var index = -1, length = array2.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array2[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array2, value, retHighest) {
          var low = 0, high = array2 == null ? low : array2.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array2[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array2, value, identity, retHighest);
        }
        function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
          var low = 0, high = array2 == null ? 0 : array2.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array2[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array2, iteratee2) {
          var index = -1, length = array2.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array2.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array2);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object2, path) {
          path = castPath(path, object2);
          object2 = parent(object2, path);
          return object2 == null || delete object2[toKey(last(path))];
        }
        function baseUpdate(object2, path, updater, customizer) {
          return baseSet(object2, path, updater(baseGet(object2, path)), customizer);
        }
        function baseWhile(array2, predicate, isDrop, fromRight) {
          var length = array2.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array2[index], index, array2)) {
          }
          return isDrop ? baseSlice(array2, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array2, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array2 = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array2, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object2) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object2) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array2, start, end) {
          var length = array2.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array2 : baseSlice(array2, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object2, other, orders) {
          var index = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object2.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array2) {
          var index = -1, length = source.length;
          array2 || (array2 = Array2(length));
          while (++index < length) {
            array2[index] = source[index];
          }
          return array2;
        }
        function copyObject(source, props, object2, customizer) {
          var isNew = !object2;
          object2 || (object2 = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object2, key, newValue);
            } else {
              assignValue(object2, key, newValue);
            }
          }
          return object2;
        }
        function copySymbols(source, object2) {
          return copyObject(source, getSymbols(source), object2);
        }
        function copySymbolsIn(source, object2) {
          return copyObject(source, getSymbolsIn(source), object2);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object2, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard2 = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard2 && isIterateeCall(sources[0], sources[1], guard2)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object2 = Object2(object2);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object2, source, index, customizer);
              }
            }
            return object2;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object2, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object2), props = keysFunc(object2), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object2;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string2) {
            string2 = toString(string2);
            var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string2) {
            return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object2, iteratee2) {
            return baseInverter(object2, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number3, precision) {
            number3 = toNumber(number3);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number3)) {
              var pair = (toString(number3) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number3);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object2) {
            var tag = getTag(object2);
            if (tag == mapTag) {
              return mapToArray(object2);
            }
            if (tag == setTag) {
              return setToPairs(object2);
            }
            return baseToPairs(object2, keysFunc(object2));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object2) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object2, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object2, source, stack) {
          if (isObject2(objValue) && isObject2(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array2);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array2;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array2, other);
          stack.set(other, array2);
          while (++index < arrLength) {
            var arrValue = array2[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array2);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
                return false;
              }
              object2 = object2.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object2, +other);
            case errorTag:
              return object2.name == other.name && object2.message == other.message;
            case regexpTag:
            case stringTag:
              return object2 == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object2.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object2);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object2, other);
              var result2 = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object2);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object2) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object2);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object2;
          }
          var result2 = true;
          stack.set(object2, other);
          stack.set(other, object2);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object2[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object2.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object2);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object2) {
          return baseGetAllKeys(object2, keys, getSymbols);
        }
        function getAllKeysIn(object2) {
          return baseGetAllKeys(object2, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array2 = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array2.length : 0;
          while (length--) {
            var data = array2[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object2 = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object2.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object2) {
          var result2 = keys(object2), length = result2.length;
          while (length--) {
            var key = result2[length], value = object2[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object2, key) {
          var value = getValue(object2, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e16) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
          if (object2 == null) {
            return [];
          }
          object2 = Object2(object2);
          return arrayFilter(nativeGetSymbols(object2), function(symbol) {
            return propertyIsEnumerable.call(object2, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
          var result2 = [];
          while (object2) {
            arrayPush(result2, getSymbols(object2));
            object2 = getPrototype(object2);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object2, path, hasFunc) {
          path = castPath(path, object2);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object2 != null && hasFunc(object2, key))) {
              break;
            }
            object2 = object2[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object2 == null ? 0 : object2.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object2) || isArguments(object2));
        }
        function initCloneArray(array2) {
          var length = array2.length, result2 = new array2.constructor(length);
          if (length && typeof array2[0] == "string" && hasOwnProperty.call(array2, "index")) {
            result2.index = array2.index;
            result2.input = array2.input;
          }
          return result2;
        }
        function initCloneObject(object2) {
          return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
        }
        function initCloneByTag(object2, tag, isDeep) {
          var Ctor = object2.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object2);
            case boolTag:
            case dateTag:
              return new Ctor(+object2);
            case dataViewTag:
              return cloneDataView(object2, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object2, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object2);
            case regexpTag:
              return cloneRegExp(object2);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object2);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type2 = typeof value;
          length = length == null ? MAX_SAFE_INTEGER2 : length;
          return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object2) {
          if (!isObject2(object2)) {
            return false;
          }
          var type2 = typeof index;
          if (type2 == "number" ? isArrayLike(object2) && isIndex(index, object2.length) : type2 == "string" && index in object2) {
            return eq(object2[index], value);
          }
          return false;
        }
        function isKey(value, object2) {
          if (isArray(value)) {
            return false;
          }
          var type2 = typeof value;
          if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object2(object2);
        }
        function isKeyable(value) {
          var type2 = typeof value;
          return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object2) {
            if (object2 == null) {
              return false;
            }
            return object2[key] === srcValue && (srcValue !== undefined2 || key in Object2(object2));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object2) {
          var result2 = [];
          if (object2 != null) {
            for (var key in Object2(object2)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array2 = Array2(length);
            while (++index < length) {
              array2[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array2);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object2, path) {
          return path.length < 2 ? object2 : baseGet(object2, baseSlice(path, 0, -1));
        }
        function reorder(array2, indexes) {
          var arrLength = array2.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array2);
          while (length--) {
            var index = indexes[length];
            array2[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array2;
        }
        function safeGet(object2, key) {
          if (key === "constructor" && typeof object2[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object2[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array2, size2) {
          var index = -1, length = array2.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array2[rand];
            array2[rand] = array2[index];
            array2[index] = value;
          }
          array2.length = size2;
          return array2;
        }
        var stringToPath = memoizeCapped(function(string2) {
          var result2 = [];
          if (string2.charCodeAt(0) === 46) {
            result2.push("");
          }
          string2.replace(rePropName, function(match, number3, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e16) {
            }
            try {
              return func + "";
            } catch (e16) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array2, size2, guard2) {
          if (guard2 ? isIterateeCall(array2, size2, guard2) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array2 == null ? 0 : array2.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array2, index, index += size2);
          }
          return result2;
        }
        function compact(array2) {
          var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array2[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array2 = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array2, values2) {
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array2, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array2, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array2, n17, guard2) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          n17 = guard2 || n17 === undefined2 ? 1 : toInteger(n17);
          return baseSlice(array2, n17 < 0 ? 0 : n17, length);
        }
        function dropRight(array2, n17, guard2) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          n17 = guard2 || n17 === undefined2 ? 1 : toInteger(n17);
          n17 = length - n17;
          return baseSlice(array2, 0, n17 < 0 ? 0 : n17);
        }
        function dropRightWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
        }
        function fill(array2, value, start, end) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array2, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array2, value, start, end);
        }
        function findIndex(array2, predicate, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array2, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array2, predicate, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array2, getIteratee(predicate, 3), index, true);
        }
        function flatten(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseFlatten(array2, 1) : [];
        }
        function flattenDeep(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseFlatten(array2, INFINITY) : [];
        }
        function flattenDepth(array2, depth) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array2, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array2) {
          return array2 && array2.length ? array2[0] : undefined2;
        }
        function indexOf(array2, value, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array2, value, index);
        }
        function initial(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseSlice(array2, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join2(array2, separator) {
          return array2 == null ? "" : nativeJoin.call(array2, separator);
        }
        function last(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? array2[length - 1] : undefined2;
        }
        function lastIndexOf(array2, value, fromIndex) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array2, value, index) : baseFindIndex(array2, baseIsNaN, index, true);
        }
        function nth(array2, n17) {
          return array2 && array2.length ? baseNth(array2, toInteger(n17)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array2, values2) {
          return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2) : array2;
        }
        function pullAllBy(array2, values2, iteratee2) {
          return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, getIteratee(iteratee2, 2)) : array2;
        }
        function pullAllWith(array2, values2, comparator) {
          return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, undefined2, comparator) : array2;
        }
        var pullAt = flatRest(function(array2, indexes) {
          var length = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
          basePullAt(array2, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array2, predicate) {
          var result2 = [];
          if (!(array2 && array2.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array2.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array2[index];
            if (predicate(value, index, array2)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array2, indexes);
          return result2;
        }
        function reverse(array2) {
          return array2 == null ? array2 : nativeReverse.call(array2);
        }
        function slice(array2, start, end) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array2, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array2, start, end);
        }
        function sortedIndex(array2, value) {
          return baseSortedIndex(array2, value);
        }
        function sortedIndexBy(array2, value, iteratee2) {
          return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array2, value) {
          var length = array2 == null ? 0 : array2.length;
          if (length) {
            var index = baseSortedIndex(array2, value);
            if (index < length && eq(array2[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array2, value) {
          return baseSortedIndex(array2, value, true);
        }
        function sortedLastIndexBy(array2, value, iteratee2) {
          return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array2, value) {
          var length = array2 == null ? 0 : array2.length;
          if (length) {
            var index = baseSortedIndex(array2, value, true) - 1;
            if (eq(array2[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array2) {
          return array2 && array2.length ? baseSortedUniq(array2) : [];
        }
        function sortedUniqBy(array2, iteratee2) {
          return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array2) {
          var length = array2 == null ? 0 : array2.length;
          return length ? baseSlice(array2, 1, length) : [];
        }
        function take(array2, n17, guard2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          n17 = guard2 || n17 === undefined2 ? 1 : toInteger(n17);
          return baseSlice(array2, 0, n17 < 0 ? 0 : n17);
        }
        function takeRight(array2, n17, guard2) {
          var length = array2 == null ? 0 : array2.length;
          if (!length) {
            return [];
          }
          n17 = guard2 || n17 === undefined2 ? 1 : toInteger(n17);
          n17 = length - n17;
          return baseSlice(array2, n17 < 0 ? 0 : n17, length);
        }
        function takeRightWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
        }
        var union2 = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array2) {
          return array2 && array2.length ? baseUniq(array2) : [];
        }
        function uniqBy(array2, iteratee2) {
          return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array2, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array2 && array2.length ? baseUniq(array2, undefined2, comparator) : [];
        }
        function unzip(array2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          var length = 0;
          array2 = arrayFilter(array2, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array2, baseProperty(index));
          });
        }
        function unzipWith(array2, iteratee2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          var result2 = unzip(array2);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array2, values2) {
          return isArrayLikeObject(array2) ? baseDifference(array2, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain2(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object2) {
            return baseAt(object2, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array2) {
            if (length && !array2.length) {
              array2.push(undefined2);
            }
            return array2;
          });
        });
        function wrapperChain() {
          return chain2(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone3 = wrapperClone(parent2);
            clone3.__index__ = 0;
            clone3.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone3;
            } else {
              result2 = clone3;
            }
            var previous = clone3;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard2) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard2 && isIterateeCall(collection, predicate, guard2)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard2) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard2 ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard2) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard2 ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n17, guard2) {
          if (guard2 ? isIterateeCall(collection, n17, guard2) : n17 === undefined2) {
            n17 = 1;
          } else {
            n17 = toInteger(n17);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n17);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard2) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard2 && isIterateeCall(collection, predicate, guard2)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n17, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n17 = toInteger(n17);
          return function() {
            if (--n17 < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n17, guard2) {
          n17 = guard2 ? undefined2 : n17;
          n17 = func && n17 == null ? func.length : n17;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n17);
        }
        function before(n17, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n17 = toInteger(n17);
          return function() {
            if (--n17 > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n17 <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object2, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object2, partials, holders);
        });
        function curry(func, arity, guard2) {
          arity = guard2 ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard2) {
          arity = guard2 ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject2(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array2 = args[start], otherArgs = castSlice(args, 0, start);
            if (array2) {
              arrayPush(otherArgs, array2);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject2(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone2(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object2, source) {
          return source == null || baseConformsTo(object2, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
        }
        function isObject2(value) {
          var type2 = typeof value;
          return value != null && (type2 == "object" || type2 == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object2, source) {
          return object2 === source || baseIsMatch(object2, source, getMatchData(source));
        }
        function isMatchWith(object2, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object2, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER2 && value <= MAX_SAFE_INTEGER2;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt3 = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign2 = createAssigner(function(object2, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object2);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object2, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object2, source) {
          copyObject(source, keysIn(source), object2);
        });
        var assignInWith = createAssigner(function(object2, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object2, customizer);
        });
        var assignWith = createAssigner(function(object2, source, srcIndex, customizer) {
          copyObject(source, keys(source), object2, customizer);
        });
        var at = flatRest(baseAt);
        function create4(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object2, sources) {
          object2 = Object2(object2);
          var index = -1;
          var length = sources.length;
          var guard2 = length > 2 ? sources[2] : undefined2;
          if (guard2 && isIterateeCall(sources[0], sources[1], guard2)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object2[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object2, key)) {
                object2[key] = source[key];
              }
            }
          }
          return object2;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object2, predicate) {
          return baseFindKey(object2, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object2, predicate) {
          return baseFindKey(object2, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object2, iteratee2) {
          return object2 == null ? object2 : baseFor(object2, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object2, iteratee2) {
          return object2 == null ? object2 : baseForRight(object2, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object2, iteratee2) {
          return object2 && baseForOwn(object2, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object2, iteratee2) {
          return object2 && baseForOwnRight(object2, getIteratee(iteratee2, 3));
        }
        function functions(object2) {
          return object2 == null ? [] : baseFunctions(object2, keys(object2));
        }
        function functionsIn(object2) {
          return object2 == null ? [] : baseFunctions(object2, keysIn(object2));
        }
        function get2(object2, path, defaultValue) {
          var result2 = object2 == null ? undefined2 : baseGet(object2, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object2, path) {
          return object2 != null && hasPath(object2, path, baseHas);
        }
        function hasIn(object2, path) {
          return object2 != null && hasPath(object2, path, baseHasIn);
        }
        var invert2 = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object2) {
          return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
        }
        function keysIn(object2) {
          return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
        }
        function mapKeys(object2, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object2, function(value, key, object3) {
            baseAssignValue(result2, iteratee2(value, key, object3), value);
          });
          return result2;
        }
        function mapValues(object2, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object2, function(value, key, object3) {
            baseAssignValue(result2, key, iteratee2(value, key, object3));
          });
          return result2;
        }
        var merge = createAssigner(function(object2, source, srcIndex) {
          baseMerge(object2, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object2, source, srcIndex, customizer) {
          baseMerge(object2, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object2, paths) {
          var result2 = {};
          if (object2 == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object2);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object2, getAllKeysIn(object2), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object2, predicate) {
          return pickBy(object2, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object2, paths) {
          return object2 == null ? {} : basePick(object2, paths);
        });
        function pickBy(object2, predicate) {
          if (object2 == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object2), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object2, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object2, path, defaultValue) {
          path = castPath(path, object2);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object2 = undefined2;
          }
          while (++index < length) {
            var value = object2 == null ? undefined2 : object2[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object2 = isFunction(value) ? value.call(object2) : value;
          }
          return object2;
        }
        function set(object2, path, value) {
          return object2 == null ? object2 : baseSet(object2, path, value);
        }
        function setWith(object2, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object2 == null ? object2 : baseSet(object2, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object2, iteratee2, accumulator) {
          var isArr = isArray(object2), isArrLike = isArr || isBuffer(object2) || isTypedArray(object2);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object2 && object2.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject2(object2)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object2)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object2, function(value, index, object3) {
            return iteratee2(accumulator, value, index, object3);
          });
          return accumulator;
        }
        function unset(object2, path) {
          return object2 == null ? true : baseUnset(object2, path);
        }
        function update(object2, path, updater) {
          return object2 == null ? object2 : baseUpdate(object2, path, castFunction(updater));
        }
        function updateWith(object2, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object2 == null ? object2 : baseUpdate(object2, path, castFunction(updater), customizer);
        }
        function values(object2) {
          return object2 == null ? [] : baseValues(object2, keys(object2));
        }
        function valuesIn(object2) {
          return object2 == null ? [] : baseValues(object2, keysIn(object2));
        }
        function clamp(number3, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number3), lower, upper);
        }
        function inRange(number3, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number3 = toNumber(number3);
          return baseInRange(number3, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string2) {
          return upperFirst(toString(string2).toLowerCase());
        }
        function deburr(string2) {
          string2 = toString(string2);
          return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string2, target, position) {
          string2 = toString(string2);
          target = baseToString(target);
          var length = string2.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string2.slice(position, end) == target;
        }
        function escape(string2) {
          string2 = toString(string2);
          return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
        }
        function escapeRegExp(string2) {
          string2 = toString(string2);
          return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string2, length, chars) {
          string2 = toString(string2);
          length = toInteger(length);
          var strLength = length ? stringSize(string2) : 0;
          if (!length || strLength >= length) {
            return string2;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string2 + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string2, length, chars) {
          string2 = toString(string2);
          length = toInteger(length);
          var strLength = length ? stringSize(string2) : 0;
          return length && strLength < length ? string2 + createPadding(length - strLength, chars) : string2;
        }
        function padStart(string2, length, chars) {
          string2 = toString(string2);
          length = toInteger(length);
          var strLength = length ? stringSize(string2) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string2 : string2;
        }
        function parseInt2(string2, radix3, guard2) {
          if (guard2 || radix3 == null) {
            radix3 = 0;
          } else if (radix3) {
            radix3 = +radix3;
          }
          return nativeParseInt(toString(string2).replace(reTrimStart, ""), radix3 || 0);
        }
        function repeat(string2, n17, guard2) {
          if (guard2 ? isIterateeCall(string2, n17, guard2) : n17 === undefined2) {
            n17 = 1;
          } else {
            n17 = toInteger(n17);
          }
          return baseRepeat(toString(string2), n17);
        }
        function replace() {
          var args = arguments, string2 = toString(args[0]);
          return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split2(string2, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string2, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string2 = toString(string2);
          if (string2 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string2)) {
              return castSlice(stringToArray(string2), 0, limit);
            }
          }
          return string2.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string2, target, position) {
          string2 = toString(string2);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string2.length);
          target = baseToString(target);
          return string2.slice(position, position + target.length) == target;
        }
        function template(string2, options, guard2) {
          var settings = lodash.templateSettings;
          if (guard2 && isIterateeCall(string2, options, guard2)) {
            options = undefined2;
          }
          string2 = toString(string2);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string2.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string2.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string2, chars, guard2) {
          string2 = toString(string2);
          if (string2 && (guard2 || chars === undefined2)) {
            return baseTrim(string2);
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string2, chars, guard2) {
          string2 = toString(string2);
          if (string2 && (guard2 || chars === undefined2)) {
            return string2.slice(0, trimmedEndIndex(string2) + 1);
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string2, chars, guard2) {
          string2 = toString(string2);
          if (string2 && (guard2 || chars === undefined2)) {
            return string2.replace(reTrimStart, "");
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string2, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string2 = toString(string2);
          var strLength = string2.length;
          if (hasUnicode(string2)) {
            var strSymbols = stringToArray(string2);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string2;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string2.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string2.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape2(string2) {
          string2 = toString(string2);
          return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string2, pattern, guard2) {
          string2 = toString(string2);
          pattern = guard2 ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
          }
          return string2.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e16) {
            return isError(e16) ? e16 : new Error2(e16);
          }
        });
        var bindAll = flatRest(function(object2, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object2, key, bind(object2[key], object2));
          });
          return object2;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object2) {
            return baseInvoke(object2, path, args);
          };
        });
        var methodOf = baseRest(function(object2, args) {
          return function(path) {
            return baseInvoke(object2, path, args);
          };
        });
        function mixin(object2, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object2;
            object2 = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain3 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object2);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object2[methodName] = func;
            if (isFunc) {
              object2.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain3 || chainAll) {
                  var result2 = object2(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object2 });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object2, arrayPush([this.value()], arguments));
              };
            }
          });
          return object2;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n17) {
          n17 = toInteger(n17);
          return baseRest(function(args) {
            return baseNth(args, n17);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object2) {
          return function(path) {
            return object2 == null ? undefined2 : baseGet(object2, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n17, iteratee2) {
          n17 = toInteger(n17);
          if (n17 < 1 || n17 > MAX_SAFE_INTEGER2) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n17, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n17 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n17) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add2 = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array2) {
          return array2 && array2.length ? baseExtremum(array2, identity, baseGt) : undefined2;
        }
        function maxBy(array2, iteratee2) {
          return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array2) {
          return baseMean(array2, identity);
        }
        function meanBy(array2, iteratee2) {
          return baseMean(array2, getIteratee(iteratee2, 2));
        }
        function min(array2) {
          return array2 && array2.length ? baseExtremum(array2, identity, baseLt) : undefined2;
        }
        function minBy(array2, iteratee2) {
          return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array2) {
          return array2 && array2.length ? baseSum(array2, identity) : 0;
        }
        function sumBy(array2, iteratee2) {
          return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign2;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain2;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create4;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert2;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split2;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union2;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add2;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone2;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get2;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject2;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join2;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt3;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n17) {
            n17 = n17 === undefined2 ? 1 : nativeMax(toInteger(n17), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n17, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n17, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n17) {
            return this.reverse()[methodName](n17).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type2 = index + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type2
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _2 = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _2;
        define(function() {
          return _2;
        });
      } else if (freeModule) {
        (freeModule.exports = _2)._ = _2;
        freeExports._ = _2;
      } else {
        root._ = _2;
      }
    }).call(exports);
  }
});

// node_modules/ethos-connect/node_modules/@mysten/sui.js/dist/index.mjs
var import_tweetnacl = __toESM(require_nacl_fast(), 1);

// node_modules/ethos-connect/node_modules/@mysten/bcs/dist/index.mjs
var import_bs58 = __toESM(require_bs58(), 1);
function b64ToUint6(nChr) {
  return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
}
function fromB64(sBase64, nBlocksSize) {
  var sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, ""), nInLen = sB64Enc.length, nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2, taBytes = new Uint8Array(nOutLen);
  for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
    nMod4 = nInIdx & 3;
    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 6 * (3 - nMod4);
    if (nMod4 === 3 || nInLen - nInIdx === 1) {
      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
        taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
      }
      nUint24 = 0;
    }
  }
  return taBytes;
}
function uint6ToB64(nUint6) {
  return nUint6 < 26 ? nUint6 + 65 : nUint6 < 52 ? nUint6 + 71 : nUint6 < 62 ? nUint6 - 4 : nUint6 === 62 ? 43 : nUint6 === 63 ? 47 : 65;
}
function toB64(aBytes) {
  var nMod3 = 2, sB64Enc = "";
  for (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {
    nMod3 = nIdx % 3;
    if (nIdx > 0 && nIdx * 4 / 3 % 76 === 0) {
      sB64Enc += "";
    }
    nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);
    if (nMod3 === 2 || aBytes.length - nIdx === 1) {
      sB64Enc += String.fromCodePoint(
        uint6ToB64(nUint24 >>> 18 & 63),
        uint6ToB64(nUint24 >>> 12 & 63),
        uint6ToB64(nUint24 >>> 6 & 63),
        uint6ToB64(nUint24 & 63)
      );
      nUint24 = 0;
    }
  }
  return sB64Enc.slice(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? "" : nMod3 === 1 ? "=" : "==");
}
function fromHEX(hexStr) {
  let intArr = hexStr.replace("0x", "").match(/.{1,2}/g).map((byte) => parseInt(byte, 16));
  if (intArr === null) {
    throw new Error(`Unable to parse HEX: ${hexStr}`);
  }
  return Uint8Array.from(intArr);
}
function toHEX(bytes2) {
  return bytes2.reduce(
    (str, byte) => str + byte.toString(16).padStart(2, "0"),
    ""
  );
}
var SUI_ADDRESS_LENGTH = 32;
function toLittleEndian(bigint, size) {
  let result = new Uint8Array(size);
  let i17 = 0;
  while (bigint > 0) {
    result[i17] = Number(bigint % BigInt(256));
    bigint = bigint / BigInt(256);
    i17 += 1;
  }
  return result;
}
var toB58 = (buffer) => import_bs58.default.encode(buffer);
var fromB58 = (str) => import_bs58.default.decode(str);
var BcsReader = class {
  /**
   * @param {Uint8Array} data Data to use as a buffer.
   */
  constructor(data) {
    this.bytePosition = 0;
    this.dataView = new DataView(data.buffer);
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes2) {
    this.bytePosition += bytes2;
    return this;
  }
  /**
   * Read U8 value from the buffer and shift cursor by 1.
   * @returns
   */
  read8() {
    let value = this.dataView.getUint8(this.bytePosition);
    this.shift(1);
    return value;
  }
  /**
   * Read U16 value from the buffer and shift cursor by 2.
   * @returns
   */
  read16() {
    let value = this.dataView.getUint16(this.bytePosition, true);
    this.shift(2);
    return value;
  }
  /**
   * Read U32 value from the buffer and shift cursor by 4.
   * @returns
   */
  read32() {
    let value = this.dataView.getUint32(this.bytePosition, true);
    this.shift(4);
    return value;
  }
  /**
   * Read U64 value from the buffer and shift cursor by 8.
   * @returns
   */
  read64() {
    let value1 = this.read32();
    let value2 = this.read32();
    let result = value2.toString(16) + value1.toString(16).padStart(8, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 16.
   */
  read128() {
    let value1 = BigInt(this.read64());
    let value2 = BigInt(this.read64());
    let result = value2.toString(16) + value1.toString(16).padStart(8, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 32.
   * @returns
   */
  read256() {
    let value1 = BigInt(this.read128());
    let value2 = BigInt(this.read128());
    let result = value2.toString(16) + value1.toString(16).padStart(16, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read `num` number of bytes from the buffer and shift cursor by `num`.
   * @param num Number of bytes to read.
   */
  readBytes(num) {
    let start = this.bytePosition + this.dataView.byteOffset;
    let value = new Uint8Array(this.dataView.buffer, start, num);
    this.shift(num);
    return value;
  }
  /**
   * Read ULEB value - an integer of varying size. Used for enum indexes and
   * vector lengths.
   * @returns {Number} The ULEB value.
   */
  readULEB() {
    let start = this.bytePosition + this.dataView.byteOffset;
    let buffer = new Uint8Array(this.dataView.buffer, start);
    let { value, length } = ulebDecode(buffer);
    this.shift(length);
    return value;
  }
  /**
   * Read a BCS vector: read a length and then apply function `cb` X times
   * where X is the length of the vector, defined as ULEB in BCS bytes.
   * @param cb Callback to process elements of vector.
   * @returns {Array<Any>} Array of the resulting values, returned by callback.
   */
  readVec(cb) {
    let length = this.readULEB();
    let result = [];
    for (let i17 = 0; i17 < length; i17++) {
      result.push(cb(this, i17, length));
    }
    return result;
  }
};
var BcsWriter = class {
  constructor({
    size = 1024,
    maxSize,
    allocateSize = 1024
  } = {}) {
    this.bytePosition = 0;
    this.size = size;
    this.maxSize = maxSize || size;
    this.allocateSize = allocateSize;
    this.dataView = new DataView(new ArrayBuffer(size));
  }
  ensureSizeOrGrow(bytes2) {
    const requiredSize = this.bytePosition + bytes2;
    if (requiredSize > this.size) {
      const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);
      if (requiredSize > nextSize) {
        throw new Error(
          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`
        );
      }
      this.size = nextSize;
      const nextBuffer = new ArrayBuffer(this.size);
      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));
      this.dataView = new DataView(nextBuffer);
    }
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes2) {
    this.bytePosition += bytes2;
    return this;
  }
  /**
   * Write a U8 value into a buffer and shift cursor position by 1.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write8(value) {
    this.ensureSizeOrGrow(1);
    this.dataView.setUint8(this.bytePosition, Number(value));
    return this.shift(1);
  }
  /**
   * Write a U16 value into a buffer and shift cursor position by 2.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write16(value) {
    this.ensureSizeOrGrow(2);
    this.dataView.setUint16(this.bytePosition, Number(value), true);
    return this.shift(2);
  }
  /**
   * Write a U32 value into a buffer and shift cursor position by 4.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write32(value) {
    this.ensureSizeOrGrow(4);
    this.dataView.setUint32(this.bytePosition, Number(value), true);
    return this.shift(4);
  }
  /**
   * Write a U64 value into a buffer and shift cursor position by 8.
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write64(value) {
    toLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a U128 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write128(value) {
    toLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a U256 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write256(value) {
    toLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a ULEB value into a buffer and shift cursor position by number of bytes
   * written.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  writeULEB(value) {
    ulebEncode(value).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a vector into a buffer by first writing the vector length and then calling
   * a callback on each passed value.
   *
   * @param {Array<Any>} vector Array of elements to write.
   * @param {WriteVecCb} cb Callback to call on each element of the vector.
   * @returns {this}
   */
  writeVec(vector, cb) {
    this.writeULEB(vector.length);
    Array.from(vector).forEach((el, i17) => cb(this, el, i17, vector.length));
    return this;
  }
  /**
   * Adds support for iterations over the object.
   * @returns {Uint8Array}
   */
  *[Symbol.iterator]() {
    for (let i17 = 0; i17 < this.bytePosition; i17++) {
      yield this.dataView.getUint8(i17);
    }
    return this.toBytes();
  }
  /**
   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
   * @returns {Uint8Array} Resulting bcs.
   */
  toBytes() {
    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
  }
  /**
   * Represent data as 'hex' or 'base64'
   * @param encoding Encoding to use: 'base64' or 'hex'
   */
  toString(encoding) {
    return encodeStr(this.toBytes(), encoding);
  }
};
function ulebEncode(num) {
  let arr = [];
  let len = 0;
  if (num === 0) {
    return [0];
  }
  while (num > 0) {
    arr[len] = num & 127;
    if (num >>= 7) {
      arr[len] |= 128;
    }
    len += 1;
  }
  return arr;
}
function ulebDecode(arr) {
  let total = 0;
  let shift = 0;
  let len = 0;
  while (true) {
    let byte = arr[len];
    len += 1;
    total |= (byte & 127) << shift;
    if ((byte & 128) === 0) {
      break;
    }
    shift += 7;
  }
  return {
    value: total,
    length: len
  };
}
var _BCS = class {
  /**
   * Construct a BCS instance with a prepared schema.
   *
   * @param schema A prepared schema with type definitions
   * @param withPrimitives Whether to register primitive types by default
   */
  constructor(schema) {
    this.types = /* @__PURE__ */ new Map();
    this.counter = 0;
    if (schema instanceof _BCS) {
      this.schema = schema.schema;
      this.types = new Map(schema.types);
      return;
    }
    this.schema = schema;
    this.registerAddressType(
      _BCS.ADDRESS,
      schema.addressLength,
      schema.addressEncoding
    );
    this.registerVectorType(schema.vectorType);
    if (schema.types && schema.types.structs) {
      for (let name of Object.keys(schema.types.structs)) {
        this.registerStructType(name, schema.types.structs[name]);
      }
    }
    if (schema.types && schema.types.enums) {
      for (let name of Object.keys(schema.types.enums)) {
        this.registerEnumType(name, schema.types.enums[name]);
      }
    }
    if (schema.types && schema.types.aliases) {
      for (let name of Object.keys(schema.types.aliases)) {
        this.registerAlias(name, schema.types.aliases[name]);
      }
    }
    if (schema.withPrimitives !== false) {
      registerPrimitives(this);
    }
  }
  /**
   * Name of the key to use for temporary struct definitions.
   * Returns a temp key + index (for a case when multiple temp
   * structs are processed).
   */
  tempKey() {
    return `bcs-struct-${++this.counter}`;
  }
  /**
   * Serialize data into bcs.
   *
   * @example
   * bcs.registerVectorType('vector<u8>', 'u8');
   *
   * let serialized = BCS
   *   .set('vector<u8>', [1,2,3,4,5,6])
   *   .toBytes();
   *
   * console.assert(toHex(serialized) === '06010203040506');
   *
   * @param type Name of the type to serialize (must be registered) or a struct type.
   * @param data Data to serialize.
   * @param size Serialization buffer size. Default 1024 = 1KB.
   * @return A BCS reader instance. Usually you'd want to call `.toBytes()`
   */
  ser(type2, data, options) {
    if (typeof type2 === "string" || Array.isArray(type2)) {
      const { name, params } = this.parseTypeName(type2);
      return this.getTypeInterface(name).encode(
        this,
        data,
        options,
        params
      );
    }
    if (typeof type2 === "object") {
      const key = this.tempKey();
      const temp = new _BCS(this);
      return temp.registerStructType(key, type2).ser(key, data, options);
    }
    throw new Error(
      `Incorrect type passed into the '.ser()' function. 
${JSON.stringify(
        type2
      )}`
    );
  }
  /**
   * Deserialize BCS into a JS type.
   *
   * @example
   * let num = bcs.ser('u64', '4294967295').toString('hex');
   * let deNum = bcs.de('u64', num, 'hex');
   * console.assert(deNum.toString(10) === '4294967295');
   *
   * @param type Name of the type to deserialize (must be registered) or a struct type definition.
   * @param data Data to deserialize.
   * @param encoding Optional - encoding to use if data is of type String
   * @return Deserialized data.
   */
  de(type2, data, encoding) {
    if (typeof data === "string") {
      if (encoding) {
        data = decodeStr(data, encoding);
      } else {
        throw new Error("To pass a string to `bcs.de`, specify encoding");
      }
    }
    if (typeof type2 === "string" || Array.isArray(type2)) {
      const { name, params } = this.parseTypeName(type2);
      return this.getTypeInterface(name).decode(this, data, params);
    }
    if (typeof type2 === "object") {
      const temp = new _BCS(this);
      const key = this.tempKey();
      return temp.registerStructType(key, type2).de(key, data, encoding);
    }
    throw new Error(
      `Incorrect type passed into the '.de()' function. 
${JSON.stringify(
        type2
      )}`
    );
  }
  /**
   * Check whether a `TypeInterface` has been loaded for a `type`.
   * @param type Name of the type to check.
   * @returns
   */
  hasType(type2) {
    return this.types.has(type2);
  }
  /**
   * Create an alias for a type.
   * WARNING: this can potentially lead to recursion
   * @param name Alias to use
   * @param forType Type to reference
   * @returns
   *
   * @example
   * ```
   * let bcs = new BCS(getSuiMoveConfig());
   * bcs.registerAlias('ObjectDigest', BCS.BASE58);
   * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');
   * ```
   */
  registerAlias(name, forType) {
    this.types.set(name, forType);
    return this;
  }
  /**
   * Method to register new types for BCS internal representation.
   * For each registered type 2 callbacks must be specified and one is optional:
   *
   * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;
   * - decodeCb(reader) - write a way to deserialize data with BcsReader;
   * - validateCb(data) - validate data - either return bool or throw an error
   *
   * @example
   * // our type would be a string that consists only of numbers
   * bcs.registerType('number_string',
   *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),
   *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8
   *    (value) => /[0-9]+/.test(value) // test that it has at least one digit
   * );
   * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);
   *
   * @param name
   * @param encodeCb Callback to encode a value.
   * @param decodeCb Callback to decode a value.
   * @param validateCb Optional validator Callback to check type before serialization.
   */
  registerType(typeName, encodeCb, decodeCb, validateCb = () => true) {
    const { name, params: generics } = this.parseTypeName(typeName);
    this.types.set(name, {
      encode(self2, data, options, typeParams) {
        const typeMap = generics.reduce(
          (acc, value, index) => {
            return Object.assign(acc, { [value]: typeParams[index] });
          },
          {}
        );
        return this._encodeRaw.call(
          self2,
          new BcsWriter(options),
          data,
          typeParams,
          typeMap
        );
      },
      decode(self2, data, typeParams) {
        const typeMap = generics.reduce(
          (acc, value, index) => {
            return Object.assign(acc, { [value]: typeParams[index] });
          },
          {}
        );
        return this._decodeRaw.call(
          self2,
          new BcsReader(data),
          typeParams,
          typeMap
        );
      },
      // these methods should always be used with caution as they require pre-defined
      // reader and writer and mainly exist to allow multi-field (de)serialization;
      _encodeRaw(writer, data, typeParams, typeMap) {
        if (validateCb(data)) {
          return encodeCb.call(this, writer, data, typeParams, typeMap);
        } else {
          throw new Error(`Validation failed for type ${name}, data: ${data}`);
        }
      },
      _decodeRaw(reader, typeParams, typeMap) {
        return decodeCb.call(this, reader, typeParams, typeMap);
      }
    });
    return this;
  }
  /**
   * Register an address type which is a sequence of U8s of specified length.
   * @example
   * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);
   * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');
   *
   * @param name Name of the address type.
   * @param length Byte length of the address.
   * @param encoding Encoding to use for the address type
   * @returns
   */
  registerAddressType(name, length, encoding = "hex") {
    switch (encoding) {
      case "base64":
        return this.registerType(
          name,
          function encodeAddress(writer, data) {
            return fromB64(data).reduce(
              (writer2, el) => writer2.write8(el),
              writer
            );
          },
          function decodeAddress(reader) {
            return toB64(reader.readBytes(length));
          }
        );
      case "hex":
        return this.registerType(
          name,
          function encodeAddress(writer, data) {
            return fromHEX(data).reduce(
              (writer2, el) => writer2.write8(el),
              writer
            );
          },
          function decodeAddress(reader) {
            return toHEX(reader.readBytes(length));
          }
        );
      default:
        throw new Error("Unsupported encoding! Use either hex or base64");
    }
  }
  /**
   * Register custom vector type inside the bcs.
   *
   * @example
   * bcs.registerVectorType('vector<T>'); // generic registration
   * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];
   * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');
   *
   * @param name Name of the type to register
   * @param elementType Optional name of the inner type of the vector
   * @return Returns self for chaining.
   */
  registerVectorType(typeName) {
    let { name, params } = this.parseTypeName(typeName);
    if (params.length > 1) {
      throw new Error("Vector can have only one type parameter; got " + name);
    }
    return this.registerType(
      typeName,
      function encodeVector(writer, data, typeParams, typeMap) {
        return writer.writeVec(data, (writer2, el) => {
          let elementType = typeParams[0];
          if (!elementType) {
            throw new Error(
              `Incorrect number of type parameters passed a to vector '${typeName}'`
            );
          }
          let { name: name2, params: params2 } = this.parseTypeName(elementType);
          if (this.hasType(name2)) {
            return this.getTypeInterface(name2)._encodeRaw.call(
              this,
              writer2,
              el,
              params2,
              typeMap
            );
          }
          if (!(name2 in typeMap)) {
            throw new Error(
              `Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`
            );
          }
          let { name: innerName, params: innerParams } = this.parseTypeName(
            typeMap[name2]
          );
          return this.getTypeInterface(innerName)._encodeRaw.call(
            this,
            writer2,
            el,
            innerParams,
            typeMap
          );
        });
      },
      function decodeVector(reader, typeParams, typeMap) {
        return reader.readVec((reader2) => {
          let elementType = typeParams[0];
          if (!elementType) {
            throw new Error(
              `Incorrect number of type parameters passed to a vector '${typeName}'`
            );
          }
          let { name: name2, params: params2 } = this.parseTypeName(elementType);
          if (this.hasType(name2)) {
            return this.getTypeInterface(name2)._decodeRaw.call(
              this,
              reader2,
              params2,
              typeMap
            );
          }
          if (!(name2 in typeMap)) {
            throw new Error(
              `Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`
            );
          }
          let { name: innerName, params: innerParams } = this.parseTypeName(
            typeMap[name2]
          );
          this.getTypeInterface(innerName)._decodeRaw.call(
            this,
            reader2,
            innerParams,
            typeMap
          );
        });
      }
    );
  }
  /**
   * Safe method to register a custom Move struct. The first argument is a name of the
   * struct which is only used on the FrontEnd and has no affect on serialization results,
   * and the second is a struct description passed as an Object.
   *
   * The description object MUST have the same order on all of the platforms (ie in Move
   * or in Rust).
   *
   * @example
   * // Move / Rust struct
   * // struct Coin {
   * //   value: u64,
   * //   owner: vector<u8>, // name // Vec<u8> in Rust
   * //   is_locked: bool,
   * // }
   *
   * bcs.registerStructType('Coin', {
   *   value: bcs.U64,
   *   owner: bcs.STRING,
   *   is_locked: bcs.BOOL
   * });
   *
   * // Created in Rust with diem/bcs
   * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';
   * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array
   *  128, 209, 177,   5,  96,  0,  0,
   *    0,  14,  66, 105, 103, 32, 87,
   *   97, 108, 108, 101, 116, 32, 71,
   *  117, 121,   0
   * ];
   *
   * // Let's encode the value as well
   * let test_set = bcs.ser('Coin', {
   *   owner: 'Big Wallet Guy',
   *   value: '412412400000',
   *   is_locked: false,
   * });
   *
   * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');
   *
   * @param name Name of the type to register.
   * @param fields Fields of the struct. Must be in the correct order.
   * @return Returns BCS for chaining.
   */
  registerStructType(typeName, fields) {
    for (let key in fields) {
      let internalName = this.tempKey();
      let value = fields[key];
      if (!Array.isArray(value) && typeof value !== "string") {
        fields[key] = internalName;
        this.registerStructType(internalName, value);
      }
    }
    let struct = Object.freeze(fields);
    let canonicalOrder = Object.keys(struct);
    let { name: structName, params: generics } = this.parseTypeName(typeName);
    return this.registerType(
      typeName,
      function encodeStruct(writer, data, typeParams, typeMap) {
        if (!data || data.constructor !== Object) {
          throw new Error(
            `Expected ${structName} to be an Object, got: ${data}`
          );
        }
        if (typeParams.length !== generics.length) {
          throw new Error(
            `Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`
          );
        }
        for (let key of canonicalOrder) {
          if (!(key in data)) {
            throw new Error(
              `Struct ${structName} requires field ${key}:${struct[key]}`
            );
          }
          const { name: fieldType, params: fieldParams } = this.parseTypeName(
            struct[key]
          );
          if (!generics.includes(fieldType)) {
            this.getTypeInterface(fieldType)._encodeRaw.call(
              this,
              writer,
              data[key],
              fieldParams,
              typeMap
            );
          } else {
            const paramIdx = generics.indexOf(fieldType);
            let { name, params } = this.parseTypeName(typeParams[paramIdx]);
            if (this.hasType(name)) {
              this.getTypeInterface(name)._encodeRaw.call(
                this,
                writer,
                data[key],
                params,
                typeMap
              );
              continue;
            }
            if (!(name in typeMap)) {
              throw new Error(
                `Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`
              );
            }
            let { name: innerName, params: innerParams } = this.parseTypeName(
              typeMap[name]
            );
            this.getTypeInterface(innerName)._encodeRaw.call(
              this,
              writer,
              data[key],
              innerParams,
              typeMap
            );
          }
        }
        return writer;
      },
      function decodeStruct(reader, typeParams, typeMap) {
        if (typeParams.length !== generics.length) {
          throw new Error(
            `Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`
          );
        }
        let result = {};
        for (let key of canonicalOrder) {
          const { name: fieldName, params: fieldParams } = this.parseTypeName(
            struct[key]
          );
          if (!generics.includes(fieldName)) {
            result[key] = this.getTypeInterface(fieldName)._decodeRaw.call(
              this,
              reader,
              fieldParams,
              typeMap
            );
          } else {
            const paramIdx = generics.indexOf(fieldName);
            let { name, params } = this.parseTypeName(typeParams[paramIdx]);
            if (this.hasType(name)) {
              result[key] = this.getTypeInterface(name)._decodeRaw.call(
                this,
                reader,
                params,
                typeMap
              );
              continue;
            }
            if (!(name in typeMap)) {
              throw new Error(
                `Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`
              );
            }
            let { name: innerName, params: innerParams } = this.parseTypeName(
              typeMap[name]
            );
            result[key] = this.getTypeInterface(innerName)._decodeRaw.call(
              this,
              reader,
              innerParams,
              typeMap
            );
          }
        }
        return result;
      }
    );
  }
  /**
   * Safe method to register custom enum type where each invariant holds the value of another type.
   * @example
   * bcs.registerStructType('Coin', { value: 'u64' });
   * bcs.registerEnumType('MyEnum', {
   *  single: 'Coin',
   *  multi: 'vector<Coin>',
   *  empty: null
   * });
   *
   * console.log(
   *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }
   *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }
   * )
   *
   * // and serialization
   * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();
   * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });
   *
   * @param name
   * @param variants
   */
  registerEnumType(typeName, variants) {
    for (let key in variants) {
      let internalName = this.tempKey();
      let value = variants[key];
      if (value !== null && !Array.isArray(value) && typeof value !== "string") {
        variants[key] = internalName;
        this.registerStructType(internalName, value);
      }
    }
    let struct = Object.freeze(variants);
    let canonicalOrder = Object.keys(struct);
    let { name, params: canonicalTypeParams } = this.parseTypeName(typeName);
    return this.registerType(
      typeName,
      function encodeEnum(writer, data, typeParams, typeMap) {
        if (!data) {
          throw new Error(
            `Unable to write enum "${name}", missing data.
Received: "${data}"`
          );
        }
        if (typeof data !== "object") {
          throw new Error(
            `Incorrect data passed into enum "${name}", expected object with properties: "${canonicalOrder.join(
              " | "
            )}".
Received: "${JSON.stringify(data)}"`
          );
        }
        let key = Object.keys(data)[0];
        if (key === void 0) {
          throw new Error(
            `Empty object passed as invariant of the enum "${name}"`
          );
        }
        let orderByte = canonicalOrder.indexOf(key);
        if (orderByte === -1) {
          throw new Error(
            `Unknown invariant of the enum "${name}", allowed values: "${canonicalOrder.join(
              " | "
            )}"; received "${key}"`
          );
        }
        let invariant = canonicalOrder[orderByte];
        let invariantType = struct[invariant];
        writer.write8(orderByte);
        if (invariantType === null) {
          return writer;
        }
        let paramIndex = canonicalTypeParams.indexOf(invariantType);
        let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];
        {
          let { name: name2, params } = this.parseTypeName(typeOrParam);
          return this.getTypeInterface(name2)._encodeRaw.call(
            this,
            writer,
            data[key],
            params,
            typeMap
          );
        }
      },
      function decodeEnum(reader, typeParams, typeMap) {
        let orderByte = reader.readULEB();
        let invariant = canonicalOrder[orderByte];
        let invariantType = struct[invariant];
        if (orderByte === -1) {
          throw new Error(
            `Decoding type mismatch, expected enum "${name}" invariant index, received "${orderByte}"`
          );
        }
        if (invariantType === null) {
          return { [invariant]: true };
        }
        let paramIndex = canonicalTypeParams.indexOf(invariantType);
        let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];
        {
          let { name: name2, params } = this.parseTypeName(typeOrParam);
          return {
            [invariant]: this.getTypeInterface(name2)._decodeRaw.call(
              this,
              reader,
              params,
              typeMap
            )
          };
        }
      }
    );
  }
  /**
   * Get a set of encoders/decoders for specific type.
   * Mainly used to define custom type de/serialization logic.
   *
   * @param type
   * @returns {TypeInterface}
   */
  getTypeInterface(type2) {
    let typeInterface = this.types.get(type2);
    if (typeof typeInterface === "string") {
      let chain2 = [];
      while (typeof typeInterface === "string") {
        if (chain2.includes(typeInterface)) {
          throw new Error(
            `Recursive definition found: ${chain2.join(
              " -> "
            )} -> ${typeInterface}`
          );
        }
        chain2.push(typeInterface);
        typeInterface = this.types.get(typeInterface);
      }
    }
    if (typeInterface === void 0) {
      throw new Error(`Type ${type2} is not registered`);
    }
    return typeInterface;
  }
  /**
   * Parse a type name and get the type's generics.
   * @example
   * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');
   * // typeName: Option
   * // typeParams: [ 'Coin<SUI>' ]
   *
   * @param name Name of the type to process
   * @returns Object with typeName and typeParams listed as Array
   */
  parseTypeName(name) {
    if (Array.isArray(name)) {
      let [typeName2, ...params2] = name;
      return { name: typeName2, params: params2 };
    }
    if (typeof name !== "string") {
      throw new Error(`Illegal type passed as a name of the type: ${name}`);
    }
    let [left, right] = this.schema.genericSeparators || ["<", ">"];
    let l_bound = name.indexOf(left);
    let r_bound = Array.from(name).reverse().indexOf(right);
    if (l_bound === -1 && r_bound === -1) {
      return { name, params: [] };
    }
    if (l_bound === -1 || r_bound === -1) {
      throw new Error(`Unclosed generic in name '${name}'`);
    }
    let typeName = name.slice(0, l_bound);
    let params = name.slice(l_bound + 1, name.length - r_bound - 1).split(",").map((e16) => e16.trim());
    return { name: typeName, params };
  }
};
var BCS = _BCS;
BCS.U8 = "u8";
BCS.U16 = "u16";
BCS.U32 = "u32";
BCS.U64 = "u64";
BCS.U128 = "u128";
BCS.U256 = "u256";
BCS.BOOL = "bool";
BCS.VECTOR = "vector";
BCS.ADDRESS = "address";
BCS.STRING = "string";
BCS.HEX = "hex-string";
BCS.BASE58 = "base58-string";
BCS.BASE64 = "base64-string";
function encodeStr(data, encoding) {
  switch (encoding) {
    case "base58":
      return toB58(data);
    case "base64":
      return toB64(data);
    case "hex":
      return toHEX(data);
    default:
      throw new Error(
        "Unsupported encoding, supported values are: base64, hex"
      );
  }
}
function decodeStr(data, encoding) {
  switch (encoding) {
    case "base58":
      return fromB58(data);
    case "base64":
      return fromB64(data);
    case "hex":
      return fromHEX(data);
    default:
      throw new Error(
        "Unsupported encoding, supported values are: base64, hex"
      );
  }
}
function registerPrimitives(bcs3) {
  bcs3.registerType(
    BCS.U8,
    function(writer, data) {
      return writer.write8(data);
    },
    function(reader) {
      return reader.read8();
    },
    (u8) => u8 < 256
  );
  bcs3.registerType(
    BCS.U16,
    function(writer, data) {
      return writer.write16(data);
    },
    function(reader) {
      return reader.read16();
    },
    (u16) => u16 < 65536
  );
  bcs3.registerType(
    BCS.U32,
    function(writer, data) {
      return writer.write32(data);
    },
    function(reader) {
      return reader.read32();
    },
    (u322) => u322 <= 4294967296n
  );
  bcs3.registerType(
    BCS.U64,
    function(writer, data) {
      return writer.write64(data);
    },
    function(reader) {
      return reader.read64();
    }
  );
  bcs3.registerType(
    BCS.U128,
    function(writer, data) {
      return writer.write128(data);
    },
    function(reader) {
      return reader.read128();
    }
  );
  bcs3.registerType(
    BCS.U256,
    function(writer, data) {
      return writer.write256(data);
    },
    function(reader) {
      return reader.read256();
    }
  );
  bcs3.registerType(
    BCS.BOOL,
    function(writer, data) {
      return writer.write8(data);
    },
    function(reader) {
      return reader.read8().toString(10) === "1";
    }
  );
  bcs3.registerType(
    BCS.STRING,
    function(writer, data) {
      return writer.writeVec(
        Array.from(data),
        (writer2, el) => writer2.write8(el.charCodeAt(0))
      );
    },
    function(reader) {
      return reader.readVec((reader2) => reader2.read8()).map((el) => String.fromCharCode(Number(el))).join("");
    },
    (_str) => true
  );
  bcs3.registerType(
    BCS.HEX,
    function(writer, data) {
      return writer.writeVec(
        Array.from(fromHEX(data)),
        (writer2, el) => writer2.write8(el)
      );
    },
    function(reader) {
      let bytes2 = reader.readVec((reader2) => reader2.read8());
      return toHEX(new Uint8Array(bytes2));
    }
  );
  bcs3.registerType(
    BCS.BASE58,
    function(writer, data) {
      return writer.writeVec(
        Array.from(fromB58(data)),
        (writer2, el) => writer2.write8(el)
      );
    },
    function(reader) {
      let bytes2 = reader.readVec((reader2) => reader2.read8());
      return toB58(new Uint8Array(bytes2));
    }
  );
  bcs3.registerType(
    BCS.BASE64,
    function(writer, data) {
      return writer.writeVec(
        Array.from(fromB64(data)),
        (writer2, el) => writer2.write8(el)
      );
    },
    function(reader) {
      let bytes2 = reader.readVec((reader2) => reader2.read8());
      return toB64(new Uint8Array(bytes2));
    }
  );
}
function getSuiMoveConfig() {
  return {
    genericSeparators: ["<", ">"],
    vectorType: "vector",
    addressLength: SUI_ADDRESS_LENGTH,
    addressEncoding: "hex"
  };
}

// node_modules/@noble/hashes/esm/_assert.js
function number(n17) {
  if (!Number.isSafeInteger(n17) || n17 < 0)
    throw new Error(`Wrong positive integer: ${n17}`);
}
function bool(b5) {
  if (typeof b5 !== "boolean")
    throw new Error(`Expected boolean, not ${b5}`);
}
function bytes(b5, ...lengths) {
  if (!(b5 instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b5.length))
    throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b5.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var assert = {
  number,
  bool,
  bytes,
  hash,
  exists,
  output
};
var assert_default = assert;

// node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@noble/hashes/esm/utils.js
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes = Array.from({ length: 256 }, (v7, i17) => i17.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex2 = "";
  for (let i17 = 0; i17 < uint8a.length; i17++) {
    hex2 += hexes[uint8a[i17]];
  }
  return hex2;
}
function utf8ToBytes(str) {
  if (typeof str !== "string") {
    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
  }
  return new TextEncoder().encode(str);
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!(data instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
  return data;
}
function concatBytes(...arrays) {
  if (!arrays.every((a10) => a10 instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a10, arr) => a10 + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i17 = 0, pad = 0; i17 < arrays.length; i17++) {
    const arr = arrays[i17];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor(hashConstructor) {
  const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
  const tmp = hashConstructor();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashConstructor();
  return hashC;
}
function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h7 = isLE2 ? 4 : 0;
  const l9 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h7, wh, isLE2);
  view.setUint32(byteOffset + l9, wl, isLE2);
}
var SHA2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    assert_default.exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i17 = pos; i17 < blockLen; i17++)
      buffer[i17] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i17 = 0; i17 < outLen; i17++)
      oview.setUint32(4 * i17, state[i17], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// node_modules/@noble/hashes/esm/sha256.js
var Chi = (a10, b5, c11) => a10 & b5 ^ ~a10 & c11;
var Maj = (a10, b5, c11) => a10 & b5 ^ a10 & c11 ^ b5 & c11;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A: A2, B: B4, C: C10, D: D4, E: E4, F: F4, G: G4, H } = this;
    return [A2, B4, C10, D4, E4, F4, G4, H];
  }
  // prettier-ignore
  set(A2, B4, C10, D4, E4, F4, G4, H) {
    this.A = A2 | 0;
    this.B = B4 | 0;
    this.C = C10 | 0;
    this.D = D4 | 0;
    this.E = E4 | 0;
    this.F = F4 | 0;
    this.G = G4 | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i17 = 0; i17 < 16; i17++, offset += 4)
      SHA256_W[i17] = view.getUint32(offset, false);
    for (let i17 = 16; i17 < 64; i17++) {
      const W15 = SHA256_W[i17 - 15];
      const W22 = SHA256_W[i17 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W22, 17) ^ rotr(W22, 19) ^ W22 >>> 10;
      SHA256_W[i17] = s1 + SHA256_W[i17 - 7] + s0 + SHA256_W[i17 - 16] | 0;
    }
    let { A: A2, B: B4, C: C10, D: D4, E: E4, F: F4, G: G4, H } = this;
    for (let i17 = 0; i17 < 64; i17++) {
      const sigma1 = rotr(E4, 6) ^ rotr(E4, 11) ^ rotr(E4, 25);
      const T1 = H + sigma1 + Chi(E4, F4, G4) + SHA256_K[i17] + SHA256_W[i17] | 0;
      const sigma0 = rotr(A2, 2) ^ rotr(A2, 13) ^ rotr(A2, 22);
      const T2 = sigma0 + Maj(A2, B4, C10) | 0;
      H = G4;
      G4 = F4;
      F4 = E4;
      E4 = D4 + T1 | 0;
      D4 = C10;
      C10 = B4;
      B4 = A2;
      A2 = T1 + T2 | 0;
    }
    A2 = A2 + this.A | 0;
    B4 = B4 + this.B | 0;
    C10 = C10 + this.C | 0;
    D4 = D4 + this.D | 0;
    E4 = E4 + this.E | 0;
    F4 = F4 + this.F | 0;
    G4 = G4 + this.G | 0;
    H = H + this.H | 0;
    this.set(A2, B4, C10, D4, E4, F4, G4, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// node_modules/@noble/hashes/esm/_blake2.js
var SIGMA = new Uint8Array([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
]);
var BLAKE2 = class extends Hash {
  constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.length = 0;
    this.pos = 0;
    this.finished = false;
    this.destroyed = false;
    assert_default.number(blockLen);
    assert_default.number(outputLen);
    assert_default.number(keyLen);
    if (outputLen < 0 || outputLen > keyLen)
      throw new Error("outputLen bigger than keyLen");
    if (opts.key !== void 0 && (opts.key.length < 1 || opts.key.length > keyLen))
      throw new Error(`key must be up 1..${keyLen} byte long or undefined`);
    if (opts.salt !== void 0 && opts.salt.length !== saltLen)
      throw new Error(`salt must be ${saltLen} byte long or undefined`);
    if (opts.personalization !== void 0 && opts.personalization.length !== persLen)
      throw new Error(`personalization must be ${persLen} byte long or undefined`);
    this.buffer32 = u32(this.buffer = new Uint8Array(blockLen));
  }
  update(data) {
    assert_default.exists(this);
    const { blockLen, buffer, buffer32 } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      if (this.pos === blockLen) {
        this.compress(buffer32, 0, false);
        this.pos = 0;
      }
      const take = Math.min(blockLen - this.pos, len - pos);
      const dataOffset = data.byteOffset + pos;
      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
        const data32 = new Uint32Array(data.buffer, dataOffset, Math.floor((len - pos) / 4));
        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
          this.length += blockLen;
          this.compress(data32, pos32, false);
        }
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      this.length += take;
      pos += take;
    }
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.output(out, this);
    const { pos, buffer32 } = this;
    this.finished = true;
    this.buffer.subarray(pos).fill(0);
    this.compress(buffer32, 0, true);
    const out32 = u32(out);
    this.get().forEach((v7, i17) => out32[i17] = v7);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    const { buffer, length, finished, destroyed, outputLen, pos } = this;
    to || (to = new this.constructor({ dkLen: outputLen }));
    to.set(...this.get());
    to.length = length;
    to.finished = finished;
    to.destroyed = destroyed;
    to.outputLen = outputLen;
    to.buffer.set(buffer);
    to.pos = pos;
    return to;
  }
};

// node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n17, le = false) {
  if (le)
    return { h: Number(n17 & U32_MASK64), l: Number(n17 >> _32n & U32_MASK64) };
  return { h: Number(n17 >> _32n & U32_MASK64) | 0, l: Number(n17 & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i17 = 0; i17 < lst.length; i17++) {
    const { h: h7, l: l9 } = fromBig(lst[i17], le);
    [Ah[i17], Al[i17]] = [h7, l9];
  }
  return [Ah, Al];
}
var toBig = (h7, l9) => BigInt(h7 >>> 0) << _32n | BigInt(l9 >>> 0);
var shrSH = (h7, l9, s9) => h7 >>> s9;
var shrSL = (h7, l9, s9) => h7 << 32 - s9 | l9 >>> s9;
var rotrSH = (h7, l9, s9) => h7 >>> s9 | l9 << 32 - s9;
var rotrSL = (h7, l9, s9) => h7 << 32 - s9 | l9 >>> s9;
var rotrBH = (h7, l9, s9) => h7 << 64 - s9 | l9 >>> s9 - 32;
var rotrBL = (h7, l9, s9) => h7 >>> s9 - 32 | l9 << 64 - s9;
var rotr32H = (h7, l9) => l9;
var rotr32L = (h7, l9) => h7;
var rotlSH = (h7, l9, s9) => h7 << s9 | l9 >>> 32 - s9;
var rotlSL = (h7, l9, s9) => l9 << s9 | h7 >>> 32 - s9;
var rotlBH = (h7, l9, s9) => l9 << s9 - 32 | h7 >>> 64 - s9;
var rotlBL = (h7, l9, s9) => h7 << s9 - 32 | l9 >>> 64 - s9;
function add(Ah, Al, Bh, Bl) {
  const l9 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l9 / 2 ** 32 | 0) | 0, l: l9 | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// node_modules/@noble/hashes/esm/blake2b.js
var IV2 = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
var BUF = new Uint32Array(32);
function G1(a10, b5, c11, d15, msg, x5) {
  const Xl = msg[x5], Xh = msg[x5 + 1];
  let Al = BUF[2 * a10], Ah = BUF[2 * a10 + 1];
  let Bl = BUF[2 * b5], Bh = BUF[2 * b5 + 1];
  let Cl = BUF[2 * c11], Ch = BUF[2 * c11 + 1];
  let Dl = BUF[2 * d15], Dh = BUF[2 * d15 + 1];
  let ll = u64_default.add3L(Al, Bl, Xl);
  Ah = u64_default.add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: u64_default.rotr32H(Dh, Dl), Dl: u64_default.rotr32L(Dh, Dl) });
  ({ h: Ch, l: Cl } = u64_default.add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: u64_default.rotrSH(Bh, Bl, 24), Bl: u64_default.rotrSL(Bh, Bl, 24) });
  BUF[2 * a10] = Al, BUF[2 * a10 + 1] = Ah;
  BUF[2 * b5] = Bl, BUF[2 * b5 + 1] = Bh;
  BUF[2 * c11] = Cl, BUF[2 * c11 + 1] = Ch;
  BUF[2 * d15] = Dl, BUF[2 * d15 + 1] = Dh;
}
function G2(a10, b5, c11, d15, msg, x5) {
  const Xl = msg[x5], Xh = msg[x5 + 1];
  let Al = BUF[2 * a10], Ah = BUF[2 * a10 + 1];
  let Bl = BUF[2 * b5], Bh = BUF[2 * b5 + 1];
  let Cl = BUF[2 * c11], Ch = BUF[2 * c11 + 1];
  let Dl = BUF[2 * d15], Dh = BUF[2 * d15 + 1];
  let ll = u64_default.add3L(Al, Bl, Xl);
  Ah = u64_default.add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: u64_default.rotrSH(Dh, Dl, 16), Dl: u64_default.rotrSL(Dh, Dl, 16) });
  ({ h: Ch, l: Cl } = u64_default.add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: u64_default.rotrBH(Bh, Bl, 63), Bl: u64_default.rotrBL(Bh, Bl, 63) });
  BUF[2 * a10] = Al, BUF[2 * a10 + 1] = Ah;
  BUF[2 * b5] = Bl, BUF[2 * b5 + 1] = Bh;
  BUF[2 * c11] = Cl, BUF[2 * c11 + 1] = Ch;
  BUF[2 * d15] = Dl, BUF[2 * d15 + 1] = Dh;
}
var BLAKE2b = class extends BLAKE2 {
  constructor(opts = {}) {
    super(128, opts.dkLen === void 0 ? 64 : opts.dkLen, opts, 64, 16, 16);
    this.v0l = IV2[0] | 0;
    this.v0h = IV2[1] | 0;
    this.v1l = IV2[2] | 0;
    this.v1h = IV2[3] | 0;
    this.v2l = IV2[4] | 0;
    this.v2h = IV2[5] | 0;
    this.v3l = IV2[6] | 0;
    this.v3h = IV2[7] | 0;
    this.v4l = IV2[8] | 0;
    this.v4h = IV2[9] | 0;
    this.v5l = IV2[10] | 0;
    this.v5h = IV2[11] | 0;
    this.v6l = IV2[12] | 0;
    this.v6h = IV2[13] | 0;
    this.v7l = IV2[14] | 0;
    this.v7h = IV2[15] | 0;
    const keyLength = opts.key ? opts.key.length : 0;
    this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (opts.salt) {
      const salt = u32(toBytes(opts.salt));
      this.v4l ^= salt[0];
      this.v4h ^= salt[1];
      this.v5l ^= salt[2];
      this.v5h ^= salt[3];
    }
    if (opts.personalization) {
      const pers = u32(toBytes(opts.personalization));
      this.v6l ^= pers[0];
      this.v6h ^= pers[1];
      this.v7l ^= pers[2];
      this.v7h ^= pers[3];
    }
    if (opts.key) {
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(toBytes(opts.key));
      this.update(tmp);
    }
  }
  // prettier-ignore
  get() {
    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
  }
  // prettier-ignore
  set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
    this.v0l = v0l | 0;
    this.v0h = v0h | 0;
    this.v1l = v1l | 0;
    this.v1h = v1h | 0;
    this.v2l = v2l | 0;
    this.v2h = v2h | 0;
    this.v3l = v3l | 0;
    this.v3h = v3h | 0;
    this.v4l = v4l | 0;
    this.v4h = v4h | 0;
    this.v5l = v5l | 0;
    this.v5h = v5h | 0;
    this.v6l = v6l | 0;
    this.v6h = v6h | 0;
    this.v7l = v7l | 0;
    this.v7h = v7h | 0;
  }
  compress(msg, offset, isLast) {
    this.get().forEach((v7, i17) => BUF[i17] = v7);
    BUF.set(IV2, 16);
    let { h: h7, l: l9 } = u64_default.fromBig(BigInt(this.length));
    BUF[24] = IV2[8] ^ l9;
    BUF[25] = IV2[9] ^ h7;
    if (isLast) {
      BUF[28] = ~BUF[28];
      BUF[29] = ~BUF[29];
    }
    let j2 = 0;
    const s9 = SIGMA;
    for (let i17 = 0; i17 < 12; i17++) {
      G1(0, 4, 8, 12, msg, offset + 2 * s9[j2++]);
      G2(0, 4, 8, 12, msg, offset + 2 * s9[j2++]);
      G1(1, 5, 9, 13, msg, offset + 2 * s9[j2++]);
      G2(1, 5, 9, 13, msg, offset + 2 * s9[j2++]);
      G1(2, 6, 10, 14, msg, offset + 2 * s9[j2++]);
      G2(2, 6, 10, 14, msg, offset + 2 * s9[j2++]);
      G1(3, 7, 11, 15, msg, offset + 2 * s9[j2++]);
      G2(3, 7, 11, 15, msg, offset + 2 * s9[j2++]);
      G1(0, 5, 10, 15, msg, offset + 2 * s9[j2++]);
      G2(0, 5, 10, 15, msg, offset + 2 * s9[j2++]);
      G1(1, 6, 11, 12, msg, offset + 2 * s9[j2++]);
      G2(1, 6, 11, 12, msg, offset + 2 * s9[j2++]);
      G1(2, 7, 8, 13, msg, offset + 2 * s9[j2++]);
      G2(2, 7, 8, 13, msg, offset + 2 * s9[j2++]);
      G1(3, 4, 9, 14, msg, offset + 2 * s9[j2++]);
      G2(3, 4, 9, 14, msg, offset + 2 * s9[j2++]);
    }
    this.v0l ^= BUF[0] ^ BUF[16];
    this.v0h ^= BUF[1] ^ BUF[17];
    this.v1l ^= BUF[2] ^ BUF[18];
    this.v1h ^= BUF[3] ^ BUF[19];
    this.v2l ^= BUF[4] ^ BUF[20];
    this.v2h ^= BUF[5] ^ BUF[21];
    this.v3l ^= BUF[6] ^ BUF[22];
    this.v3h ^= BUF[7] ^ BUF[23];
    this.v4l ^= BUF[8] ^ BUF[24];
    this.v4h ^= BUF[9] ^ BUF[25];
    this.v5l ^= BUF[10] ^ BUF[26];
    this.v5h ^= BUF[11] ^ BUF[27];
    this.v6l ^= BUF[12] ^ BUF[28];
    this.v6h ^= BUF[13] ^ BUF[29];
    this.v7l ^= BUF[14] ^ BUF[30];
    this.v7h ^= BUF[15] ^ BUF[31];
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer32.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2b = wrapConstructorWithOpts((opts) => new BLAKE2b(opts));

// node_modules/superstruct/dist/index.mjs
var StructError = class extends TypeError {
  constructor(failure, failures) {
    let cached;
    const { message, explanation, ...rest } = failure;
    const { path } = failure;
    const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
    super(explanation ?? msg);
    if (explanation != null)
      this.cause = msg;
    Object.assign(this, rest);
    this.name = this.constructor.name;
    this.failures = () => {
      return cached ?? (cached = [failure, ...failures()]);
    };
  }
};
function isIterable(x5) {
  return isObject(x5) && typeof x5[Symbol.iterator] === "function";
}
function isObject(x5) {
  return typeof x5 === "object" && x5 != null;
}
function print(value) {
  if (typeof value === "symbol") {
    return value.toString();
  }
  return typeof value === "string" ? JSON.stringify(value) : `${value}`;
}
function shiftIterator(input) {
  const { done, value } = input.next();
  return done ? void 0 : value;
}
function toFailure(result, context, struct, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = { message: result };
  }
  const { path, branch } = context;
  const { type: type2 } = struct;
  const { refinement, message = `Expected a value of type \`${type2}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print(value)}\`` } = result;
  return {
    value,
    type: type2,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
function* toFailures(result, context, struct, value) {
  if (!isIterable(result)) {
    result = [result];
  }
  for (const r17 of result) {
    const failure = toFailure(r17, context, struct, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run(value, struct, options = {}) {
  const { path = [], branch = [value], coerce = false, mask: mask2 = false } = options;
  const ctx = { path, branch };
  if (coerce) {
    value = struct.coercer(value, ctx);
    if (mask2 && struct.type !== "type" && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {
      for (const key in value) {
        if (struct.schema[key] === void 0) {
          delete value[key];
        }
      }
    }
  }
  let status = "valid";
  for (const failure of struct.validator(value, ctx)) {
    failure.explanation = options.message;
    status = "not_valid";
    yield [failure, void 0];
  }
  for (let [k4, v7, s9] of struct.entries(value, ctx)) {
    const ts = run(v7, s9, {
      path: k4 === void 0 ? path : [...path, k4],
      branch: k4 === void 0 ? branch : [...branch, v7],
      coerce,
      mask: mask2,
      message: options.message
    });
    for (const t18 of ts) {
      if (t18[0]) {
        status = t18[0].refinement != null ? "not_refined" : "not_valid";
        yield [t18[0], void 0];
      } else if (coerce) {
        v7 = t18[1];
        if (k4 === void 0) {
          value = v7;
        } else if (value instanceof Map) {
          value.set(k4, v7);
        } else if (value instanceof Set) {
          value.add(v7);
        } else if (isObject(value)) {
          if (v7 !== void 0 || k4 in value)
            value[k4] = v7;
        }
      }
    }
  }
  if (status !== "not_valid") {
    for (const failure of struct.refiner(value, ctx)) {
      failure.explanation = options.message;
      status = "not_refined";
      yield [failure, void 0];
    }
  }
  if (status === "valid") {
    yield [void 0, value];
  }
}
var Struct = class {
  constructor(props) {
    const { type: type2, schema, validator, refiner, coercer = (value) => value, entries = function* () {
    } } = props;
    this.type = type2;
    this.schema = schema;
    this.entries = entries;
    this.coercer = coercer;
    if (validator) {
      this.validator = (value, context) => {
        const result = validator(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.validator = () => [];
    }
    if (refiner) {
      this.refiner = (value, context) => {
        const result = refiner(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.refiner = () => [];
    }
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(value, message) {
    return assert2(value, this, message);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(value, message) {
    return create(value, this, message);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(value) {
    return is(value, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(value, message) {
    return mask(value, this, message);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(value, options = {}) {
    return validate(value, this, options);
  }
};
function assert2(value, struct, message) {
  const result = validate(value, struct, { message });
  if (result[0]) {
    throw result[0];
  }
}
function create(value, struct, message) {
  const result = validate(value, struct, { coerce: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask(value, struct, message) {
  const result = validate(value, struct, { coerce: true, mask: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is(value, struct) {
  const result = validate(value, struct);
  return !result[0];
}
function validate(value, struct, options = {}) {
  const tuples = run(value, struct, options);
  const tuple2 = shiftIterator(tuples);
  if (tuple2[0]) {
    const error = new StructError(tuple2[0], function* () {
      for (const t18 of tuples) {
        if (t18[0]) {
          yield t18[0];
        }
      }
    });
    return [error, void 0];
  } else {
    const v7 = tuple2[1];
    return [void 0, v7];
  }
}
function assign(...Structs) {
  const isType = Structs[0].type === "type";
  const schemas = Structs.map((s9) => s9.schema);
  const schema = Object.assign({}, ...schemas);
  return isType ? type(schema) : object(schema);
}
function define2(name, validator) {
  return new Struct({ type: name, schema: null, validator });
}
function any() {
  return define2("any", () => true);
}
function array(Element) {
  return new Struct({
    type: "array",
    schema: Element,
    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i17, v7] of value.entries()) {
          yield [i17, v7, Element];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;
    }
  });
}
function boolean() {
  return define2("boolean", (value) => {
    return typeof value === "boolean";
  });
}
function integer() {
  return define2("integer", (value) => {
    return typeof value === "number" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;
  });
}
function literal(constant) {
  const description = print(constant);
  const t18 = typeof constant;
  return new Struct({
    type: "literal",
    schema: t18 === "string" || t18 === "number" || t18 === "boolean" ? constant : null,
    validator(value) {
      return value === constant || `Expected the literal \`${description}\`, but received: ${print(value)}`;
    }
  });
}
function never() {
  return define2("never", () => false);
}
function nullable(struct) {
  return new Struct({
    ...struct,
    validator: (value, ctx) => value === null || struct.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)
  });
}
function number2() {
  return define2("number", (value) => {
    return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;
  });
}
function object(schema) {
  const knowns = schema ? Object.keys(schema) : [];
  const Never = never();
  return new Struct({
    type: "object",
    schema: schema ? schema : null,
    *entries(value) {
      if (schema && isObject(value)) {
        const unknowns = new Set(Object.keys(value));
        for (const key of knowns) {
          unknowns.delete(key);
          yield [key, value[key], schema[key]];
        }
        for (const key of unknowns) {
          yield [key, value[key], Never];
        }
      }
    },
    validator(value) {
      return isObject(value) || `Expected an object, but received: ${print(value)}`;
    },
    coercer(value) {
      return isObject(value) ? { ...value } : value;
    }
  });
}
function optional(struct) {
  return new Struct({
    ...struct,
    validator: (value, ctx) => value === void 0 || struct.validator(value, ctx),
    refiner: (value, ctx) => value === void 0 || struct.refiner(value, ctx)
  });
}
function record(Key, Value) {
  return new Struct({
    type: "record",
    schema: null,
    *entries(value) {
      if (isObject(value)) {
        for (const k4 in value) {
          const v7 = value[k4];
          yield [k4, k4, Key];
          yield [k4, v7, Value];
        }
      }
    },
    validator(value) {
      return isObject(value) || `Expected an object, but received: ${print(value)}`;
    }
  });
}
function string() {
  return define2("string", (value) => {
    return typeof value === "string" || `Expected a string, but received: ${print(value)}`;
  });
}
function tuple(Structs) {
  const Never = never();
  return new Struct({
    type: "tuple",
    schema: null,
    *entries(value) {
      if (Array.isArray(value)) {
        const length = Math.max(Structs.length, value.length);
        for (let i17 = 0; i17 < length; i17++) {
          yield [i17, value[i17], Structs[i17] || Never];
        }
      }
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;
    }
  });
}
function type(schema) {
  const keys = Object.keys(schema);
  return new Struct({
    type: "type",
    schema,
    *entries(value) {
      if (isObject(value)) {
        for (const k4 of keys) {
          yield [k4, value[k4], schema[k4]];
        }
      }
    },
    validator(value) {
      return isObject(value) || `Expected an object, but received: ${print(value)}`;
    },
    coercer(value) {
      return isObject(value) ? { ...value } : value;
    }
  });
}
function union(Structs) {
  const description = Structs.map((s9) => s9.type).join(" | ");
  return new Struct({
    type: "union",
    schema: null,
    coercer(value) {
      for (const S3 of Structs) {
        const [error, coerced] = S3.validate(value, { coerce: true });
        if (!error) {
          return coerced;
        }
      }
      return value;
    },
    validator(value, ctx) {
      const failures = [];
      for (const S3 of Structs) {
        const [...tuples] = run(value, S3, ctx);
        const [first] = tuples;
        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return [
        `Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`,
        ...failures
      ];
    }
  });
}

// node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex2,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes,
  hexToNumber: () => hexToNumber,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes2,
  validateObject: () => validateObject
});
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var u8a = (a10) => a10 instanceof Uint8Array;
var hexes2 = Array.from({ length: 256 }, (v7, i17) => i17.toString(16).padStart(2, "0"));
function bytesToHex2(bytes2) {
  if (!u8a(bytes2))
    throw new Error("Uint8Array expected");
  let hex2 = "";
  for (let i17 = 0; i17 < bytes2.length; i17++) {
    hex2 += hexes2[bytes2[i17]];
  }
  return hex2;
}
function numberToHexUnpadded(num) {
  const hex2 = num.toString(16);
  return hex2.length & 1 ? `0${hex2}` : hex2;
}
function hexToNumber(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return BigInt(hex2 === "" ? "0" : `0x${hex2}`);
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  if (hex2.length % 2)
    throw new Error("hex string is invalid: unpadded " + hex2.length);
  const array2 = new Uint8Array(hex2.length / 2);
  for (let i17 = 0; i17 < array2.length; i17++) {
    const j2 = i17 * 2;
    const hexByte = hex2.slice(j2, j2 + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("invalid byte sequence");
    array2[i17] = byte;
  }
  return array2;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex2(bytes2));
}
function bytesToNumberLE(bytes2) {
  if (!u8a(bytes2))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex2(Uint8Array.from(bytes2).reverse()));
}
var numberToBytesBE = (n17, len) => hexToBytes(n17.toString(16).padStart(len * 2, "0"));
var numberToBytesLE = (n17, len) => numberToBytesBE(n17, len).reverse();
var numberToVarBytesBE = (n17) => hexToBytes(numberToHexUnpadded(n17));
function ensureBytes(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes(hex2);
    } catch (e16) {
      throw new Error(`${title} must be valid hex string, got "${hex2}". Cause: ${e16}`);
    }
  } else if (u8a(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrs) {
  const r17 = new Uint8Array(arrs.reduce((sum, a10) => sum + a10.length, 0));
  let pad = 0;
  arrs.forEach((a10) => {
    if (!u8a(a10))
      throw new Error("Uint8Array expected");
    r17.set(a10, pad);
    pad += a10.length;
  });
  return r17;
}
function equalBytes(b1, b22) {
  if (b1.length !== b22.length)
    return false;
  for (let i17 = 0; i17 < b1.length; i17++)
    if (b1[i17] !== b22[i17])
      return false;
  return true;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string") {
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  }
  return new TextEncoder().encode(str);
}
function bitLen(n17) {
  let len;
  for (len = 0; n17 > _0n; n17 >>= _1n, len += 1)
    ;
  return len;
}
var bitGet = (n17, pos) => n17 >> BigInt(pos) & _1n;
var bitSet = (n17, pos, value) => n17 | (value ? _1n : _0n) << BigInt(pos);
var bitMask = (n17) => (_2n << BigInt(n17 - 1)) - _1n;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v7 = u8n(hashLen);
  let k4 = u8n(hashLen);
  let i17 = 0;
  const reset = () => {
    v7.fill(1);
    k4.fill(0);
    i17 = 0;
  };
  const h7 = (...b5) => hmacFn(k4, v7, ...b5);
  const reseed = (seed = u8n()) => {
    k4 = h7(u8fr([0]), seed);
    v7 = h7();
    if (seed.length === 0)
      return;
    k4 = h7(u8fr([1]), seed);
    v7 = h7();
  };
  const gen = () => {
    if (i17++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v7 = h7();
      const sl = v7.slice();
      out.push(sl);
      len += v7.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object2) => object2.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object2, validators, optValidators = {}) {
  const checkField = (fieldName, type2, isOptional) => {
    const checkVal = validatorFns[type2];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type2}", expected function`);
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type2}`);
    }
  };
  for (const [fieldName, type2] of Object.entries(validators))
    checkField(fieldName, type2, false);
  for (const [fieldName, type2] of Object.entries(optValidators))
    checkField(fieldName, type2, true);
  return object2;
}

// node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a10, b5) {
  const result = a10 % b5;
  return result >= _0n2 ? result : b5 + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n2 || power < _0n2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n2)
    return _0n2;
  let res = _1n2;
  while (power > _0n2) {
    if (power & _1n2)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n2;
  }
  return res;
}
function pow2(x5, power, modulo) {
  let res = x5;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number3, modulo) {
  if (number3 === _0n2 || modulo <= _0n2) {
    throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
  }
  let a10 = mod(number3, modulo);
  let b5 = modulo;
  let x5 = _0n2, y6 = _1n2, u5 = _1n2, v7 = _0n2;
  while (a10 !== _0n2) {
    const q2 = b5 / a10;
    const r17 = b5 % a10;
    const m12 = x5 - u5 * q2;
    const n17 = y6 - v7 * q2;
    b5 = a10, a10 = r17, x5 = u5, y6 = v7, u5 = m12, v7 = n17;
  }
  const gcd2 = b5;
  if (gcd2 !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x5, modulo);
}
function tonelliShanks(P4) {
  const legendreC = (P4 - _1n2) / _2n2;
  let Q, S3, Z;
  for (Q = P4 - _1n2, S3 = 0; Q % _2n2 === _0n2; Q /= _2n2, S3++)
    ;
  for (Z = _2n2; Z < P4 && pow(Z, legendreC, P4) !== P4 - _1n2; Z++)
    ;
  if (S3 === 1) {
    const p1div4 = (P4 + _1n2) / _4n;
    return function tonelliFast(Fp2, n17) {
      const root = Fp2.pow(n17, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n17))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n2) / _2n2;
  return function tonelliSlow(Fp2, n17) {
    if (Fp2.pow(n17, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r17 = S3;
    let g10 = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
    let x5 = Fp2.pow(n17, Q1div2);
    let b5 = Fp2.pow(n17, Q);
    while (!Fp2.eql(b5, Fp2.ONE)) {
      if (Fp2.eql(b5, Fp2.ZERO))
        return Fp2.ZERO;
      let m12 = 1;
      for (let t22 = Fp2.sqr(b5); m12 < r17; m12++) {
        if (Fp2.eql(t22, Fp2.ONE))
          break;
        t22 = Fp2.sqr(t22);
      }
      const ge2 = Fp2.pow(g10, _1n2 << BigInt(r17 - m12 - 1));
      g10 = Fp2.sqr(ge2);
      x5 = Fp2.mul(x5, ge2);
      b5 = Fp2.mul(b5, g10);
      r17 = m12;
    }
    return x5;
  };
}
function FpSqrt(P4) {
  if (P4 % _4n === _3n) {
    const p1div4 = (P4 + _1n2) / _4n;
    return function sqrt3mod4(Fp2, n17) {
      const root = Fp2.pow(n17, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n17))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P4 % _8n === _5n) {
    const c1 = (P4 - _5n) / _8n;
    return function sqrt5mod8(Fp2, n17) {
      const n22 = Fp2.mul(n17, _2n2);
      const v7 = Fp2.pow(n22, c1);
      const nv = Fp2.mul(n17, v7);
      const i17 = Fp2.mul(Fp2.mul(nv, _2n2), v7);
      const root = Fp2.mul(nv, Fp2.sub(i17, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n17))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P4 % _16n === _9n) {
  }
  return tonelliShanks(P4);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f11, num, power) {
  if (power < _0n2)
    throw new Error("Expected power > 0");
  if (power === _0n2)
    return f11.ONE;
  if (power === _1n2)
    return num;
  let p12 = f11.ONE;
  let d15 = num;
  while (power > _0n2) {
    if (power & _1n2)
      p12 = f11.mul(p12, d15);
    d15 = f11.sqr(d15);
    power >>= _1n2;
  }
  return p12;
}
function FpInvertBatch(f11, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i17) => {
    if (f11.is0(num))
      return acc;
    tmp[i17] = acc;
    return f11.mul(acc, num);
  }, f11.ONE);
  const inverted = f11.inv(lastMultiplied);
  nums.reduceRight((acc, num, i17) => {
    if (f11.is0(num))
      return acc;
    tmp[i17] = f11.mul(acc, tmp[i17]);
    return f11.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n17, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n17.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n2)
    throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f11 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f11, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n17) => sqrtP(f11, n17)),
    invertBatch: (lst) => FpInvertBatch(f11, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a10, b5, c11) => c11 ? b5 : a10,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f11);
}
function hashToPrivateScalar(hash2, groupOrder, isLE2 = false) {
  hash2 = ensureBytes("privateHash", hash2);
  const hashLen = hash2.length;
  const minLen = nLength(groupOrder).nByteLength + 8;
  if (minLen < 24 || hashLen < minLen || hashLen > 1024)
    throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
  const num = isLE2 ? bytesToNumberLE(hash2) : bytesToNumberBE(hash2);
  return mod(num, groupOrder - _1n2) + _1n2;
}

// node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function wNAF(c11, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W5) => {
    const windows = Math.ceil(bits / W5) + 1;
    const windowSize = 2 ** (W5 - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n17) {
      let p12 = c11.ZERO;
      let d15 = elm;
      while (n17 > _0n3) {
        if (n17 & _1n3)
          p12 = p12.add(d15);
        d15 = d15.double();
        n17 >>= _1n3;
      }
      return p12;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W5) {
      const { windows, windowSize } = opts(W5);
      const points = [];
      let p12 = elm;
      let base = p12;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p12;
        points.push(base);
        for (let i17 = 1; i17 < windowSize; i17++) {
          base = base.add(p12);
          points.push(base);
        }
        p12 = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W5, precomputes, n17) {
      const { windows, windowSize } = opts(W5);
      let p12 = c11.ZERO;
      let f11 = c11.BASE;
      const mask2 = BigInt(2 ** W5 - 1);
      const maxNumber = 2 ** W5;
      const shiftBy = BigInt(W5);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n17 & mask2);
        n17 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n17 += _1n3;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f11 = f11.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p12 = p12.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p: p12, f: f11 };
    },
    wNAFCached(P4, precomputesMap, n17, transform) {
      const W5 = P4._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P4);
      if (!comp) {
        comp = this.precomputeWindow(P4, W5);
        if (W5 !== 1) {
          precomputesMap.set(P4, transform(comp));
        }
      }
      return this.wNAF(W5, comp, n17);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a: a10 } = opts;
  if (endo) {
    if (!Fp2.eql(a10, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m12 = "") {
      super(m12);
    }
  },
  _parseInt(data) {
    const { Err: E4 } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E4("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E4("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E4("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E4("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex2) {
    const { Err: E4 } = DER;
    const data = typeof hex2 === "string" ? h2b(hex2) : hex2;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l9 = data.length;
    if (l9 < 2 || data[0] != 48)
      throw new E4("Invalid signature tag");
    if (data[1] !== l9 - 2)
      throw new E4("Invalid signature: incorrect length");
    const { d: r17, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s9, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E4("Invalid signature: left bytes after parsing");
    return { r: r17, s: s9 };
  },
  hexFromSig(sig) {
    const slice = (s10) => Number.parseInt(s10[0], 16) & 8 ? "00" + s10 : s10;
    const h7 = (num) => {
      const hex2 = num.toString(16);
      return hex2.length & 1 ? `0${hex2}` : hex2;
    };
    const s9 = slice(h7(sig.s));
    const r17 = slice(h7(sig.r));
    const shl = s9.length / 2;
    const rhl = r17.length / 2;
    const sl = h7(shl);
    const rl = h7(rhl);
    return `30${h7(rhl + shl + 4)}02${rl}${r17}02${sl}${s9}`;
  }
};
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n3 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((c11, point, isCompressed) => {
    const a10 = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a10.x), Fp2.toBytes(a10.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x5 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y6 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x: x5, y: y6 };
  });
  function weierstrassEquation(x5) {
    const { a: a10, b: b5 } = CURVE;
    const x22 = Fp2.sqr(x5);
    const x32 = Fp2.mul(x22, x5);
    return Fp2.add(Fp2.add(x32, Fp2.mul(x5, a10)), b5);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n4 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n17 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n17);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ProjectivePoint expected");
  }
  class Point3 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p12) {
      const { x: x5, y: y6 } = p12 || {};
      if (!p12 || !Fp2.isValid(x5) || !Fp2.isValid(y6))
        throw new Error("invalid affine point");
      if (p12 instanceof Point3)
        throw new Error("projective point not allowed");
      const is0 = (i17) => Fp2.eql(i17, Fp2.ZERO);
      if (is0(x5) && is0(y6))
        return Point3.ZERO;
      return new Point3(x5, y6, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p12) => p12.pz));
      return points.map((p12, i17) => p12.toAffine(toInv[i17])).map(Point3.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex2) {
      const P4 = Point3.fromAffine(fromBytes(ensureBytes("pointHex", hex2)));
      P4.assertValidity();
      return P4;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint)
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: x5, y: y6 } = this.toAffine();
      if (!Fp2.isValid(x5) || !Fp2.isValid(y6))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y6);
      const right = weierstrassEquation(x5);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: y6 } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y6);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y22, pz: Z2 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y22, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point3(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a10, b: b5 } = CURVE;
      const b32 = Fp2.mul(b5, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t22 = Fp2.mul(Z1, Z1);
      let t32 = Fp2.mul(X1, Y1);
      t32 = Fp2.add(t32, t32);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a10, Z3);
      Y3 = Fp2.mul(b32, t22);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t32, X3);
      Z3 = Fp2.mul(b32, Z3);
      t22 = Fp2.mul(a10, t22);
      t32 = Fp2.sub(t0, t22);
      t32 = Fp2.mul(a10, t32);
      t32 = Fp2.add(t32, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t22);
      t0 = Fp2.mul(t0, t32);
      Y3 = Fp2.add(Y3, t0);
      t22 = Fp2.mul(Y1, Z1);
      t22 = Fp2.add(t22, t22);
      t0 = Fp2.mul(t22, t32);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t22, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point3(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y22, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a10 = CURVE.a;
      const b32 = Fp2.mul(CURVE.b, _3n2);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y22);
      let t22 = Fp2.mul(Z1, Z2);
      let t32 = Fp2.add(X1, Y1);
      let t42 = Fp2.add(X2, Y22);
      t32 = Fp2.mul(t32, t42);
      t42 = Fp2.add(t0, t1);
      t32 = Fp2.sub(t32, t42);
      t42 = Fp2.add(X1, Z1);
      let t52 = Fp2.add(X2, Z2);
      t42 = Fp2.mul(t42, t52);
      t52 = Fp2.add(t0, t22);
      t42 = Fp2.sub(t42, t52);
      t52 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y22, Z2);
      t52 = Fp2.mul(t52, X3);
      X3 = Fp2.add(t1, t22);
      t52 = Fp2.sub(t52, X3);
      Z3 = Fp2.mul(a10, t42);
      X3 = Fp2.mul(b32, t22);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t22 = Fp2.mul(a10, t22);
      t42 = Fp2.mul(b32, t42);
      t1 = Fp2.add(t1, t22);
      t22 = Fp2.sub(t0, t22);
      t22 = Fp2.mul(a10, t22);
      t42 = Fp2.add(t42, t22);
      t0 = Fp2.mul(t1, t42);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t52, t42);
      X3 = Fp2.mul(t32, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t32, t1);
      Z3 = Fp2.mul(t52, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point3(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    wNAF(n17) {
      return wnaf.wNAFCached(this, pointPrecomputes, n17, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p12) => p12.pz));
        return comp.map((p12, i17) => p12.toAffine(toInv[i17])).map(Point3.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n17) {
      const I6 = Point3.ZERO;
      if (n17 === _0n4)
        return I6;
      assertGE(n17);
      if (n17 === _1n4)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n17);
      let { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n17);
      let k1p = I6;
      let k2p = I6;
      let d15 = this;
      while (k1 > _0n4 || k22 > _0n4) {
        if (k1 & _1n4)
          k1p = k1p.add(d15);
        if (k22 & _1n4)
          k2p = k2p.add(d15);
        d15 = d15.double();
        k1 >>= _1n4;
        k22 >>= _1n4;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point3(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n17 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n17);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k22);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point3(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p12, f: f11 } = this.wNAF(n17);
        point = p12;
        fake = f11;
      }
      return Point3.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a10, b5) {
      const G4 = Point3.BASE;
      const mul = (P4, a11) => a11 === _0n4 || a11 === _1n4 || !P4.equals(G4) ? P4.multiplyUnsafe(a11) : P4.multiply(a11);
      const sum = mul(this, a10).add(mul(Q, b5));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x5, py: y6, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x5, iz);
      const ay = Fp2.mul(y6, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point3, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point3, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point3, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex2(this.toRawBytes(isCompressed));
    }
  }
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point3.ZERO = new Point3(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point3, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point3,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n4 < num && num < Fp2.ORDER;
  }
  function modN2(a10) {
    return mod(a10, CURVE_ORDER);
  }
  function invN(a10) {
    return invert(a10, CURVE_ORDER);
  }
  const { ProjectivePoint: Point3, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(c11, point, isCompressed) {
      const a10 = point.toAffine();
      const x5 = Fp2.toBytes(a10.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x5);
      } else {
        return cat(Uint8Array.from([4]), x5, Fp2.toBytes(a10.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x5 = bytesToNumberBE(tail);
        if (!isValidFieldElement(x5))
          throw new Error("Point is not on curve");
        const y22 = weierstrassEquation(x5);
        let y6 = Fp2.sqrt(y22);
        const isYOdd = (y6 & _1n4) === _1n4;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y6 = Fp2.neg(y6);
        return { x: x5, y: y6 };
      } else if (len === uncompressedLen && head === 4) {
        const x5 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y6 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x: x5, y: y6 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex2(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number3) {
    const HALF = CURVE_ORDER >> _1n4;
    return number3 > HALF;
  }
  function normalizeS(s9) {
    return isBiggerThanHalfOrder(s9) ? modN2(-s9) : s9;
  }
  const slcNum = (b5, from, to) => bytesToNumberBE(b5.slice(from, to));
  class Signature {
    constructor(r17, s9, recovery) {
      this.r = r17;
      this.s = s9;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const l9 = CURVE.nByteLength;
      hex2 = ensureBytes("compactSignature", hex2, l9 * 2);
      return new Signature(slcNum(hex2, 0, l9), slcNum(hex2, l9, 2 * l9));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r: r17, s: s9 } = DER.toSig(ensureBytes("DER", hex2));
      return new Signature(r17, s9);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r17, s: s9, recovery: rec } = this;
      const h7 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r17 + CURVE.n : r17;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R3 = Point3.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN2(-h7 * ir);
      const u22 = modN2(s9 * ir);
      const Q = Point3.BASE.multiplyAndAddUnsafe(R3, u1, u22);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size (nBitLength+64)
     * as per FIPS 186 B.4.1 with modulo bias being neglible.
     */
    randomPrivateKey: () => {
      const rand = CURVE.randomBytes(Fp2.BYTES + 8);
      const num = hashToPrivateScalar(rand, CURVE_ORDER);
      return numberToBytesBE(num, CURVE.nByteLength);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point3.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point3.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point3)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b5 = Point3.fromHex(publicB);
    return b5.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN2(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n4 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k4) => k4 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d15 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d15), int2octets(h1int)];
    if (ent != null) {
      const e16 = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e16, Fp2.BYTES));
    }
    const seed = concatBytes2(...seedArgs);
    const m12 = h1int;
    function k2sig(kBytes) {
      const k4 = bits2int(kBytes);
      if (!isWithinCurveOrder(k4))
        return;
      const ik = invN(k4);
      const q2 = Point3.BASE.multiply(k4).toAffine();
      const r17 = modN2(q2.x);
      if (r17 === _0n4)
        return;
      const s9 = modN2(ik * modN2(m12 + r17 * d15));
      if (s9 === _0n4)
        return;
      let recovery = (q2.x === r17 ? 0 : 2) | Number(q2.y & _1n4);
      let normS = s9;
      if (lowS && isBiggerThanHalfOrder(s9)) {
        normS = normalizeS(s9);
        recovery ^= 1;
      }
      return new Signature(r17, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const drbg = createHmacDrbg(CURVE.hash.outputLen, CURVE.nByteLength, CURVE.hmac);
    return drbg(seed, k2sig);
  }
  Point3.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    var _a;
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P4;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r18, s: s10 } = sg;
        _sig = new Signature(r18, s10);
      } else {
        throw new Error("PARSE");
      }
      P4 = Point3.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r17, s: s9 } = _sig;
    const h7 = bits2int_modN(msgHash);
    const is2 = invN(s9);
    const u1 = modN2(h7 * is2);
    const u22 = modN2(r17 * is2);
    const R3 = (_a = Point3.BASE.multiplyAndAddUnsafe(P4, u1, u22)) == null ? void 0 : _a.toAffine();
    if (!R3)
      return false;
    const v7 = modN2(R3.x);
    return v7 === r17;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point3,
    Signature,
    utils
  };
}
function SWUFpSqrtRatio(Fp2, Z) {
  const q2 = Fp2.ORDER;
  let l9 = _0n4;
  for (let o18 = q2 - _1n4; o18 % _2n3 === _0n4; o18 /= _2n3)
    l9 += _1n4;
  const c1 = l9;
  const c22 = (q2 - _1n4) / _2n3 ** c1;
  const c32 = (c22 - _1n4) / _2n3;
  const c42 = _2n3 ** c1 - _1n4;
  const c52 = _2n3 ** (c1 - _1n4);
  const c62 = Fp2.pow(Z, c22);
  const c72 = Fp2.pow(Z, (c22 + _1n4) / _2n3);
  let sqrtRatio = (u5, v7) => {
    let tv1 = c62;
    let tv2 = Fp2.pow(v7, c42);
    let tv3 = Fp2.sqr(tv2);
    tv3 = Fp2.mul(tv3, v7);
    let tv5 = Fp2.mul(u5, tv3);
    tv5 = Fp2.pow(tv5, c32);
    tv5 = Fp2.mul(tv5, tv2);
    tv2 = Fp2.mul(tv5, v7);
    tv3 = Fp2.mul(tv5, u5);
    let tv4 = Fp2.mul(tv3, tv2);
    tv5 = Fp2.pow(tv4, c52);
    let isQR = Fp2.eql(tv5, Fp2.ONE);
    tv2 = Fp2.mul(tv3, c72);
    tv5 = Fp2.mul(tv4, tv1);
    tv3 = Fp2.cmov(tv2, tv3, isQR);
    tv4 = Fp2.cmov(tv5, tv4, isQR);
    for (let i17 = c1; i17 > _1n4; i17--) {
      let tv52 = _2n3 ** (i17 - _2n3);
      let tvv5 = Fp2.pow(tv4, tv52);
      const e1 = Fp2.eql(tvv5, Fp2.ONE);
      tv2 = Fp2.mul(tv3, tv1);
      tv1 = Fp2.mul(tv1, tv1);
      tvv5 = Fp2.mul(tv4, tv1);
      tv3 = Fp2.cmov(tv2, tv3, e1);
      tv4 = Fp2.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp2.ORDER % _4n2 === _3n2) {
    const c12 = (Fp2.ORDER - _3n2) / _4n2;
    const c23 = Fp2.sqrt(Fp2.neg(Z));
    sqrtRatio = (u5, v7) => {
      let tv1 = Fp2.sqr(v7);
      const tv2 = Fp2.mul(u5, v7);
      tv1 = Fp2.mul(tv1, tv2);
      let y1 = Fp2.pow(tv1, c12);
      y1 = Fp2.mul(y1, tv2);
      const y22 = Fp2.mul(y1, c23);
      const tv3 = Fp2.mul(Fp2.sqr(y1), v7);
      const isQR = Fp2.eql(tv3, u5);
      let y6 = Fp2.cmov(y22, y1, isQR);
      return { isValid: isQR, value: y6 };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp2, opts) {
  validateField(Fp2);
  if (!Fp2.isValid(opts.A) || !Fp2.isValid(opts.B) || !Fp2.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp2, opts.Z);
  if (!Fp2.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u5) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x5, y6;
    tv1 = Fp2.sqr(u5);
    tv1 = Fp2.mul(tv1, opts.Z);
    tv2 = Fp2.sqr(tv1);
    tv2 = Fp2.add(tv2, tv1);
    tv3 = Fp2.add(tv2, Fp2.ONE);
    tv3 = Fp2.mul(tv3, opts.B);
    tv4 = Fp2.cmov(opts.Z, Fp2.neg(tv2), !Fp2.eql(tv2, Fp2.ZERO));
    tv4 = Fp2.mul(tv4, opts.A);
    tv2 = Fp2.sqr(tv3);
    tv6 = Fp2.sqr(tv4);
    tv5 = Fp2.mul(tv6, opts.A);
    tv2 = Fp2.add(tv2, tv5);
    tv2 = Fp2.mul(tv2, tv3);
    tv6 = Fp2.mul(tv6, tv4);
    tv5 = Fp2.mul(tv6, opts.B);
    tv2 = Fp2.add(tv2, tv5);
    x5 = Fp2.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y6 = Fp2.mul(tv1, u5);
    y6 = Fp2.mul(y6, value);
    x5 = Fp2.cmov(x5, tv3, isValid);
    y6 = Fp2.cmov(y6, value, isValid);
    const e1 = Fp2.isOdd(u5) === Fp2.isOdd(y6);
    y6 = Fp2.cmov(Fp2.neg(y6), y6, e1);
    x5 = Fp2.div(x5, tv4);
    return { x: x5, y: y6 };
  };
}

// node_modules/@noble/curves/esm/abstract/hash-to-curve.js
function validateDST(dst) {
  if (dst instanceof Uint8Array)
    return dst;
  if (typeof dst === "string")
    return utf8ToBytes2(dst);
  throw new Error("DST must be Uint8Array or string");
}
var os2ip = bytesToNumberBE;
function i2osp(value, length) {
  if (value < 0 || value >= 1 << 8 * length) {
    throw new Error(`bad I2OSP call: value=${value} length=${length}`);
  }
  const res = Array.from({ length }).fill(0);
  for (let i17 = length - 1; i17 >= 0; i17--) {
    res[i17] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a10, b5) {
  const arr = new Uint8Array(a10.length);
  for (let i17 = 0; i17 < a10.length; i17++) {
    arr[i17] = a10[i17] ^ b5[i17];
  }
  return arr;
}
function isBytes(item) {
  if (!(item instanceof Uint8Array))
    throw new Error("Uint8Array expected");
}
function isNum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  isBytes(msg);
  isBytes(DST);
  isNum(lenInBytes);
  if (DST.length > 255)
    DST = H(concatBytes2(utf8ToBytes2("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255)
    throw new Error("Invalid xmd length");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b5 = new Array(ell);
  const b_0 = H(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b5[0] = H(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i17 = 1; i17 <= ell; i17++) {
    const args = [strxor(b_0, b5[i17 - 1]), i2osp(i17 + 1, 1), DST_prime];
    b5[i17] = H(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b5);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k4, H) {
  isBytes(msg);
  isBytes(DST);
  isNum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k4 / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes2("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "string",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: p12, k: k4, m: m12, hash: hash2, expand, DST: _DST } = options;
  isBytes(msg);
  isNum(count);
  const DST = validateDST(_DST);
  const log2p = p12.toString(2).length;
  const L3 = Math.ceil((log2p + k4) / 8);
  const len_in_bytes = count * m12 * L3;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k4, hash2);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u5 = new Array(count);
  for (let i17 = 0; i17 < count; i17++) {
    const e16 = new Array(m12);
    for (let j2 = 0; j2 < m12; j2++) {
      const elm_offset = L3 * (j2 + i17 * m12);
      const tv = prb.subarray(elm_offset, elm_offset + L3);
      e16[j2] = mod(os2ip(tv), p12);
    }
    u5[i17] = e16;
  }
  return u5;
}
function isogenyMap(field, map) {
  const COEFF = map.map((i17) => Array.from(i17).reverse());
  return (x5, y6) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i17) => field.add(field.mul(acc, x5), i17)));
    x5 = field.div(xNum, xDen);
    y6 = field.mul(y6, field.div(yNum, yDen));
    return { x: x5, y: y6 };
  };
}
function createHasher(Point3, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve
    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
    hashToCurve(msg, options) {
      const u5 = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point3.fromAffine(mapToCurve(u5[0]));
      const u1 = Point3.fromAffine(mapToCurve(u5[1]));
      const P4 = u0.add(u1).clearCofactor();
      P4.assertValidity();
      return P4;
    },
    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3
    encodeToCurve(msg, options) {
      const u5 = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P4 = Point3.fromAffine(mapToCurve(u5[0])).clearCofactor();
      P4.assertValidity();
      return P4;
    }
  };
}

// node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    assert_default.hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i17 = 0; i17 < pad.length; i17++)
      pad[i17] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i17 = 0; i17 < pad.length; i17++)
      pad[i17] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    assert_default.exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create4 = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create4(defHash), create: create4 });
}

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var divNearest = (a10, b5) => (a10 + b5 / _2n4) / b5;
function sqrtMod(y6) {
  const P4 = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b22 = y6 * y6 * y6 % P4;
  const b32 = b22 * b22 * y6 % P4;
  const b6 = pow2(b32, _3n3, P4) * b32 % P4;
  const b9 = pow2(b6, _3n3, P4) * b32 % P4;
  const b11 = pow2(b9, _2n4, P4) * b22 % P4;
  const b222 = pow2(b11, _11n, P4) * b11 % P4;
  const b44 = pow2(b222, _22n, P4) * b222 % P4;
  const b88 = pow2(b44, _44n, P4) * b44 % P4;
  const b176 = pow2(b88, _88n, P4) * b88 % P4;
  const b220 = pow2(b176, _44n, P4) * b44 % P4;
  const b223 = pow2(b220, _3n3, P4) * b32 % P4;
  const t1 = pow2(b223, _23n, P4) * b222 % P4;
  const t22 = pow2(t1, _6n, P4) * b22 % P4;
  const root = pow2(t22, _2n4, P4);
  if (!Fp.eql(Fp.sqr(root), y6))
    throw new Error("Cannot find square root");
  return root;
}
var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k4) => {
      const n17 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a22 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b22 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b22 * k4, n17);
      const c22 = divNearest(-b1 * k4, n17);
      let k1 = mod(k4 - c1 * a1 - c22 * a22, n17);
      let k22 = mod(-c1 * b1 - c22 * b22, n17);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n17 - k1;
      if (k2neg)
        k22 = n17 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k4);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha256);
var _0n5 = BigInt(0);
var fe = (x5) => typeof x5 === "bigint" && _0n5 < x5 && x5 < secp256k1P;
var ge = (x5) => typeof x5 === "bigint" && _0n5 < x5 && x5 < secp256k1N;
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(Uint8Array.from(tag, (c11) => c11.charCodeAt(0)));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes2(tagP, ...messages));
}
var pointToBytes = (point) => point.toRawBytes(true).slice(1);
var numTo32b = (n17) => numberToBytesBE(n17, 32);
var modP = (x5) => mod(x5, secp256k1P);
var modN = (x5) => mod(x5, secp256k1N);
var Point = secp256k1.ProjectivePoint;
var GmulAdd = (Q, a10, b5) => Point.BASE.multiplyAndAddUnsafe(Q, a10, b5);
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p12 = Point.fromPrivateKey(d_);
  const scalar = p12.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p12) };
}
function lift_x(x5) {
  if (!fe(x5))
    throw new Error("bad x: need 0 < x < p");
  const xx = modP(x5 * x5);
  const c11 = modP(xx * x5 + BigInt(7));
  let y6 = sqrtMod(c11);
  if (y6 % _2n4 !== _0n5)
    y6 = modP(-y6);
  const p12 = new Point(x5, y6, _1n5);
  p12.assertValidity();
  return p12;
}
function challenge(...args) {
  return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m12 = ensureBytes("message", message);
  const { bytes: px, scalar: d15 } = schnorrGetExtPubKey(privateKey);
  const a10 = ensureBytes("auxRand", auxRand, 32);
  const t18 = numTo32b(d15 ^ bytesToNumberBE(taggedHash("BIP0340/aux", a10)));
  const rand = taggedHash("BIP0340/nonce", t18, px, m12);
  const k_ = modN(bytesToNumberBE(rand));
  if (k_ === _0n5)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k4 } = schnorrGetExtPubKey(k_);
  const e16 = challenge(rx, px, m12);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k4 + e16 * d15)), 32);
  if (!schnorrVerify(sig, m12, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m12 = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P4 = lift_x(bytesToNumberBE(pub));
    const r17 = bytesToNumberBE(sig.subarray(0, 32));
    if (!fe(r17))
      return false;
    const s9 = bytesToNumberBE(sig.subarray(32, 64));
    if (!ge(s9))
      return false;
    const e16 = challenge(numTo32b(r17), pointToBytes(P4), m12);
    const R3 = GmulAdd(P4, s9, modN(-e16));
    if (!R3 || !R3.hasEvenY() || R3.toAffine().x !== r17)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = {
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
};
var isoMap = isogenyMap(Fp, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i17) => i17.map((j2) => BigInt(j2))));
var mapSWU = mapToCurveSimpleSWU(Fp, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fp.create(BigInt("-11"))
});
var { hashToCurve, encodeToCurve } = createHasher(secp256k1.ProjectivePoint, (scalars) => {
  const { x: x5, y: y6 } = mapSWU(Fp.create(scalars[0]));
  return isoMap(x5, y6);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
});

// node_modules/ethos-connect/node_modules/@mysten/sui.js/dist/index.mjs
var import_bip39 = __toESM(require_bip39(), 1);

// node_modules/@noble/hashes/esm/ripemd160.js
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = Uint8Array.from({ length: 16 }, (_2, i17) => i17);
var Pi = Id.map((i17) => (9 * i17 + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i17 = 0; i17 < 4; i17++)
  for (let j2 of [idxL, idxR])
    j2.push(j2[i17].map((k4) => Rho[k4]));
var shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i17) => new Uint8Array(i17));
var shiftsL = idxL.map((idx, i17) => idx.map((j2) => shifts[i17][j2]));
var shiftsR = idxR.map((idx, i17) => idx.map((j2) => shifts[i17][j2]));
var Kl = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]);
var Kr = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]);
var rotl = (word, shift) => word << shift | word >>> 32 - shift;
function f(group, x5, y6, z) {
  if (group === 0)
    return x5 ^ y6 ^ z;
  else if (group === 1)
    return x5 & y6 | ~x5 & z;
  else if (group === 2)
    return (x5 | ~y6) ^ z;
  else if (group === 3)
    return x5 & z | y6 & ~z;
  else
    return x5 ^ (y6 | ~z);
}
var BUF2 = new Uint32Array(16);
var RIPEMD160 = class extends SHA2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2: h22, h3: h32, h4: h42 } = this;
    return [h0, h1, h22, h32, h42];
  }
  set(h0, h1, h22, h32, h42) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h22 | 0;
    this.h3 = h32 | 0;
    this.h4 = h42 | 0;
  }
  process(view, offset) {
    for (let i17 = 0; i17 < 16; i17++, offset += 4)
      BUF2[i17] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL[group], sr = shiftsR[group];
      for (let i17 = 0; i17 < 16; i17++) {
        const tl = rotl(al + f(group, bl, cl, dl) + BUF2[rl[i17]] + hbl, sl[i17]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i17 = 0; i17 < 16; i17++) {
        const tr = rotl(ar + f(rGroup, br, cr, dr) + BUF2[rr[i17]] + hbr, sr[i17]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    BUF2.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = wrapConstructor(() => new RIPEMD160());

// node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n17) => BigInt(n17)));
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i17 = 0; i17 < 16; i17++, offset += 4) {
      SHA512_W_H[i17] = view.getUint32(offset);
      SHA512_W_L[i17] = view.getUint32(offset += 4);
    }
    for (let i17 = 16; i17 < 80; i17++) {
      const W15h = SHA512_W_H[i17 - 15] | 0;
      const W15l = SHA512_W_L[i17 - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i17 - 2] | 0;
      const W2l = SHA512_W_L[i17 - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i17 - 7], SHA512_W_L[i17 - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i17 - 7], SHA512_W_H[i17 - 16]);
      SHA512_W_H[i17] = SUMh | 0;
      SHA512_W_L[i17] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i17 = 0; i17 < 80; i17++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i17], SHA512_W_L[i17]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i17], SHA512_W_H[i17]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_224 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 2352822216 | 0;
    this.Al = 424955298 | 0;
    this.Bh = 1944164710 | 0;
    this.Bl = 2312950998 | 0;
    this.Ch = 502970286 | 0;
    this.Cl = 855612546 | 0;
    this.Dh = 1738396948 | 0;
    this.Dl = 1479516111 | 0;
    this.Eh = 258812777 | 0;
    this.El = 2077511080 | 0;
    this.Fh = 2011393907 | 0;
    this.Fl = 79989058 | 0;
    this.Gh = 1067287976 | 0;
    this.Gl = 1780299464 | 0;
    this.Hh = 286451373 | 0;
    this.Hl = 2446758561 | 0;
    this.outputLen = 28;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
};
var sha512 = wrapConstructor(() => new SHA512());
var sha512_224 = wrapConstructor(() => new SHA512_224());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// node_modules/@scure/base/lib/esm/index.js
function assertNumber(n17) {
  if (!Number.isSafeInteger(n17))
    throw new Error(`Wrong integer: ${n17}`);
}
function chain(...args) {
  const wrap = (a10, b5) => (c11) => a10(b5(c11));
  const encode3 = Array.from(args).reverse().reduce((acc, i17) => acc ? wrap(acc, i17.encode) : i17.encode, void 0);
  const decode3 = args.reduce((acc, i17) => acc ? wrap(acc, i17.decode) : i17.decode, void 0);
  return { encode: encode3, decode: decode3 };
}
function alphabet(alphabet2) {
  return {
    encode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return digits.map((i17) => {
        assertNumber(i17);
        if (i17 < 0 || i17 >= alphabet2.length)
          throw new Error(`Digit index outside alphabet: ${i17} (alphabet: ${alphabet2.length})`);
        return alphabet2[i17];
      });
    },
    decode: (input) => {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("alphabet.decode input should be array of strings");
      return input.map((letter) => {
        if (typeof letter !== "string")
          throw new Error(`alphabet.decode: not string element=${letter}`);
        const index = alphabet2.indexOf(letter);
        if (index === -1)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
        return index;
      });
    }
  };
}
function join(separator = "") {
  if (typeof separator !== "string")
    throw new Error("join separator should be string");
  return {
    encode: (from) => {
      if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
        throw new Error("join.encode input should be array of strings");
      for (let i17 of from)
        if (typeof i17 !== "string")
          throw new Error(`join.encode: non-string input=${i17}`);
      return from.join(separator);
    },
    decode: (to) => {
      if (typeof to !== "string")
        throw new Error("join.decode input should be string");
      return to.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  assertNumber(bits);
  if (typeof chr !== "string")
    throw new Error("padding chr should be string");
  return {
    encode(data) {
      if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i17 of data)
        if (typeof i17 !== "string")
          throw new Error(`padding.encode: non-string input=${i17}`);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i17 of input)
        if (typeof i17 !== "string")
          throw new Error(`padding.decode: non-string input=${i17}`);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        if (!((end - 1) * bits % 8))
          throw new Error("Invalid padding: string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn) {
  if (typeof fn !== "function")
    throw new Error("normalize fn should be function");
  return { encode: (from) => from, decode: (to) => fn(to) };
}
function convertRadix(data, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
  if (!Array.isArray(data))
    throw new Error("convertRadix: data should be array");
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data);
  digits.forEach((d15) => {
    assertNumber(d15);
    if (d15 < 0 || d15 >= from)
      throw new Error(`Wrong integer: ${d15}`);
  });
  while (true) {
    let carry = 0;
    let done = true;
    for (let i17 = pos; i17 < digits.length; i17++) {
      const digit = digits[i17];
      const digitBase = from * carry + digit;
      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
        throw new Error("convertRadix: carry overflow");
      }
      carry = digitBase % to;
      digits[i17] = Math.floor(digitBase / to);
      if (!Number.isSafeInteger(digits[i17]) || digits[i17] * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!digits[i17])
        pos = i17;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i17 = 0; i17 < data.length - 1 && data[i17] === 0; i17++)
    res.push(0);
  return res.reverse();
}
var gcd = (a10, b5) => !b5 ? a10 : gcd(b5, a10 % b5);
var radix2carry = (from, to) => from + (to - gcd(from, to));
function convertRadix2(data, from, to, padding2) {
  if (!Array.isArray(data))
    throw new Error("convertRadix2: data should be array");
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry(from, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const mask2 = 2 ** to - 1;
  const res = [];
  for (const n17 of data) {
    assertNumber(n17);
    if (n17 >= 2 ** from)
      throw new Error(`convertRadix2: invalid data word=${n17} from=${from}`);
    carry = carry << from | n17;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask2) >>> 0);
    carry &= 2 ** pos - 1;
  }
  carry = carry << to - pos & mask2;
  if (!padding2 && pos >= from)
    throw new Error("Excess padding");
  if (!padding2 && carry)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  assertNumber(num);
  return {
    encode: (bytes2) => {
      if (!(bytes2 instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes2), 2 ** 8, num);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
    }
  };
}
function radix2(bits, revPadding = false) {
  assertNumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes2) => {
      if (!(bytes2 instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn) {
  if (typeof fn !== "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e16) {
    }
  };
}
function checksum(len, fn) {
  assertNumber(len);
  if (typeof fn !== "function")
    throw new Error("checksum fn should be function");
  return {
    encode(data) {
      if (!(data instanceof Uint8Array))
        throw new Error("checksum.encode: input should be Uint8Array");
      const checksum2 = fn(data).slice(0, len);
      const res = new Uint8Array(data.length + len);
      res.set(data);
      res.set(checksum2, data.length);
      return res;
    },
    decode(data) {
      if (!(data instanceof Uint8Array))
        throw new Error("checksum.decode: input should be Uint8Array");
      const payload = data.slice(0, -len);
      const newChecksum = fn(payload).slice(0, len);
      const oldChecksum = data.slice(-len);
      for (let i17 = 0; i17 < len; i17++)
        if (newChecksum[i17] !== oldChecksum[i17])
          throw new Error("Invalid checksum");
      return payload;
    }
  };
}
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s9) => s9.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
var base58xmr = {
  encode(data) {
    let res = "";
    for (let i17 = 0; i17 < data.length; i17 += 8) {
      const block = data.subarray(i17, i17 + 8);
      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
    }
    return res;
  },
  decode(str) {
    let res = [];
    for (let i17 = 0; i17 < str.length; i17 += 11) {
      const slice = str.slice(i17, i17 + 11);
      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
      const block = base58.decode(slice);
      for (let j2 = 0; j2 < block.length - blockLen; j2++) {
        if (block[j2] !== 0)
          throw new Error("base58xmr: wrong padding");
      }
      res = res.concat(Array.from(block.slice(block.length - blockLen)));
    }
    return Uint8Array.from(res);
  }
};
var base58check = (sha2562) => chain(checksum(4, (data) => sha2562(sha2562(data))), base58);
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b5 = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i17 = 0; i17 < POLYMOD_GENERATORS.length; i17++) {
    if ((b5 >> i17 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i17];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i17 = 0; i17 < len; i17++) {
    const c11 = prefix.charCodeAt(i17);
    if (c11 < 33 || c11 > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c11 >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i17 = 0; i17 < len; i17++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i17) & 31;
  for (let v7 of words)
    chk = bech32Polymod(chk) ^ v7;
  for (let i17 = 0; i17 < 6; i17++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode3(prefix, words, limit = 90) {
    if (typeof prefix !== "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
    if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
    const actualLength = prefix.length + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    prefix = prefix.toLowerCase();
    return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;
  }
  function decode3(str, limit = 90) {
    if (typeof str !== "string")
      throw new Error(`bech32.decode input should be string, not ${typeof str}`);
    if (str.length < 8 || limit !== false && str.length > limit)
      throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    str = lowered;
    const sepIndex = str.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = str.slice(0, sepIndex);
    const _words2 = str.slice(sepIndex + 1);
    if (_words2.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(_words2).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!_words2.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode3);
  function decodeToBytes(str) {
    const { prefix, words } = decode3(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  return { encode: encode3, decode: decode3, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var utf8 = {
  encode: (data) => new TextDecoder().decode(data),
  decode: (str) => new TextEncoder().encode(str)
};
var hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s9) => {
  if (typeof s9 !== "string" || s9.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof s9} with length ${s9.length}`);
  return s9.toLowerCase();
}));
var CODERS = {
  utf8,
  hex,
  base16,
  base32,
  base64,
  base64url,
  base58,
  base58xmr
};
var coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(", ")}`;

// node_modules/@scure/bip32/lib/esm/index.js
var Point2 = secp256k1.ProjectivePoint;
var base58check2 = base58check(sha256);
var MASTER_SECRET = utf8ToBytes("Bitcoin seed");

// node_modules/ethos-connect/node_modules/@mysten/sui.js/dist/index.mjs
var import_tweetnacl2 = __toESM(require_nacl_fast(), 1);
var import_browser = __toESM(require_browser(), 1);
var import_rpc_websockets = __toESM(require_index_browser(), 1);
var import_femver = __toESM(require_femver(), 1);
var import_tweetnacl3 = __toESM(require_nacl_fast(), 1);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var TransactionDigest = string();
var TransactionEffectsDigest = string();
var TransactionEventDigest = string();
var ObjectId = string();
var SuiAddress = string();
var SequenceNumber = string();
var ObjectOwner = union([
  object({
    AddressOwner: SuiAddress
  }),
  object({
    ObjectOwner: SuiAddress
  }),
  object({
    Shared: object({
      initial_shared_version: number2()
    })
  }),
  literal("Immutable")
]);
var SuiJsonValue = define2("SuiJsonValue", () => true);
var TX_DIGEST_LENGTH = 32;
function isValidTransactionDigest(value) {
  try {
    const buffer = fromB58(value);
    return buffer.length === TX_DIGEST_LENGTH;
  } catch (e16) {
    return false;
  }
}
var SUI_ADDRESS_LENGTH2 = 32;
function isValidSuiAddress(value) {
  return isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH2;
}
function isValidSuiObjectId(value) {
  return isValidSuiAddress(value);
}
function normalizeSuiAddress(value, forceAdd0x = false) {
  let address = value.toLowerCase();
  if (!forceAdd0x && address.startsWith("0x")) {
    address = address.slice(2);
  }
  return `0x${address.padStart(SUI_ADDRESS_LENGTH2 * 2, "0")}`;
}
function normalizeSuiObjectId(value, forceAdd0x = false) {
  return normalizeSuiAddress(value, forceAdd0x);
}
function isHex(value) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;
}
function getHexByteLength(value) {
  return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
}
var ObjectType = union([string(), literal("package")]);
var SuiObjectRef = object({
  /** Base64 string representing the object digest */
  digest: TransactionDigest,
  /** Hex code as string representing the object id */
  objectId: string(),
  /** Object version */
  version: union([number2(), string()])
});
var SuiGasData = object({
  payment: array(SuiObjectRef),
  /** Gas Object's owner */
  owner: string(),
  price: string(),
  budget: string()
});
var SuiObjectInfo = assign(
  SuiObjectRef,
  object({
    type: string(),
    owner: ObjectOwner,
    previousTransaction: TransactionDigest
  })
);
var ObjectContentFields = record(string(), any());
var MovePackageContent = record(string(), string());
var SuiMoveObject = object({
  /** Move type (e.g., "0x2::coin::Coin<0x2::sui::SUI>") */
  type: string(),
  /** Fields and values stored inside the Move object */
  fields: ObjectContentFields,
  hasPublicTransfer: boolean()
});
var SuiMovePackage = object({
  /** A mapping from module name to disassembled Move bytecode */
  disassembled: MovePackageContent
});
var SuiParsedData = union([
  assign(SuiMoveObject, object({ dataType: literal("moveObject") })),
  assign(SuiMovePackage, object({ dataType: literal("package") }))
]);
var SuiRawMoveObject = object({
  /** Move type (e.g., "0x2::coin::Coin<0x2::sui::SUI>") */
  type: string(),
  hasPublicTransfer: boolean(),
  version: SequenceNumber,
  bcsBytes: array(number2())
});
var SuiRawMovePackage = object({
  id: ObjectId,
  /** A mapping from module name to Move bytecode enocded in base64*/
  moduleMap: record(string(), string())
});
var SuiRawData = union([
  assign(SuiMoveObject, object({ dataType: literal("moveObject") })),
  assign(SuiRawMovePackage, object({ dataType: literal("package") }))
]);
var MIST_PER_SUI = BigInt(1e9);
var ObjectDigest = string();
var SuiObjectResponseError = object({
  code: string(),
  error: optional(string()),
  object_id: optional(ObjectId),
  version: optional(SequenceNumber),
  digest: optional(ObjectDigest)
});
var DisplayFieldsResponse = object({
  data: nullable(record(string(), string())),
  error: nullable(SuiObjectResponseError)
});
var DisplayFieldsBackwardCompatibleResponse = union([
  DisplayFieldsResponse,
  optional(record(string(), string()))
]);
var SuiObjectData = object({
  objectId: ObjectId,
  version: SequenceNumber,
  digest: ObjectDigest,
  /**
   * Type of the object, default to be undefined unless SuiObjectDataOptions.showType is set to true
   */
  type: optional(string()),
  /**
   * Move object content or package content, default to be undefined unless SuiObjectDataOptions.showContent is set to true
   */
  content: optional(SuiParsedData),
  /**
   * Move object content or package content in BCS bytes, default to be undefined unless SuiObjectDataOptions.showBcs is set to true
   */
  bcs: optional(SuiRawData),
  /**
   * The owner of this object. Default to be undefined unless SuiObjectDataOptions.showOwner is set to true
   */
  owner: optional(ObjectOwner),
  /**
   * The digest of the transaction that created or last mutated this object.
   * Default to be undefined unless SuiObjectDataOptions.showPreviousTransaction is set to true
   */
  previousTransaction: optional(TransactionDigest),
  /**
   * The amount of SUI we would rebate if this object gets deleted.
   * This number is re-calculated each time the object is mutated based on
   * the present storage gas price.
   * Default to be undefined unless SuiObjectDataOptions.showStorageRebate is set to true
   */
  storageRebate: optional(string()),
  /**
   * Display metadata for this object, default to be undefined unless SuiObjectDataOptions.showDisplay is set to true
   * This can also be None if the struct type does not have Display defined
   * See more details in https://forums.sui.io/t/nft-object-display-proposal/4872
   */
  display: optional(DisplayFieldsBackwardCompatibleResponse)
});
var SuiObjectDataOptions = object({
  /* Whether to fetch the object type, default to be true */
  showType: optional(boolean()),
  /* Whether to fetch the object content, default to be false */
  showContent: optional(boolean()),
  /* Whether to fetch the object content in BCS bytes, default to be false */
  showBcs: optional(boolean()),
  /* Whether to fetch the object owner, default to be false */
  showOwner: optional(boolean()),
  /* Whether to fetch the previous transaction digest, default to be false */
  showPreviousTransaction: optional(boolean()),
  /* Whether to fetch the storage rebate, default to be false */
  showStorageRebate: optional(boolean()),
  /* Whether to fetch the display metadata, default to be false */
  showDisplay: optional(boolean())
});
var ObjectStatus = union([
  literal("Exists"),
  literal("notExists"),
  literal("Deleted")
]);
var GetOwnedObjectsResponse = array(SuiObjectInfo);
var SuiObjectResponse = object({
  data: optional(SuiObjectData),
  error: optional(SuiObjectResponseError)
});
function getSuiObjectData(resp) {
  return resp.data;
}
function getObjectDeletedResponse(resp) {
  if (resp.error && "object_id" in resp.error && "version" in resp.error && "digest" in resp.error) {
    const error = resp.error;
    return {
      objectId: error.object_id,
      version: error.version,
      digest: error.digest
    };
  }
  return void 0;
}
function getObjectReference(resp) {
  if ("reference" in resp) {
    return resp.reference;
  }
  const exists2 = getSuiObjectData(resp);
  if (exists2) {
    return {
      objectId: exists2.objectId,
      version: exists2.version,
      digest: exists2.digest
    };
  }
  return getObjectDeletedResponse(resp);
}
function getObjectOwner(resp) {
  var _a;
  if (is(resp, ObjectOwner)) {
    return resp;
  }
  return (_a = getSuiObjectData(resp)) == null ? void 0 : _a.owner;
}
function getSharedObjectInitialVersion(resp) {
  const owner = getObjectOwner(resp);
  if (typeof owner === "object" && "Shared" in owner) {
    return owner.Shared.initial_shared_version;
  } else {
    return void 0;
  }
}
function getObjectFields(resp) {
  var _a;
  if ("fields" in resp) {
    return resp.fields;
  }
  return (_a = getMoveObject(resp)) == null ? void 0 : _a.fields;
}
function isSuiObjectDataWithContent(data) {
  return data.content !== void 0;
}
function getMoveObject(data) {
  const suiObject = "data" in data ? getSuiObjectData(data) : data;
  if (!suiObject || !isSuiObjectDataWithContent(suiObject) || suiObject.content.dataType !== "moveObject") {
    return void 0;
  }
  return suiObject.content;
}
var CheckpointedObjectId = object({
  objectId: ObjectId,
  atCheckpoint: optional(number2())
});
var PaginatedObjectsResponse = object({
  data: array(SuiObjectResponse),
  // TODO: remove union after 0.30.0 is released
  nextCursor: union([nullable(ObjectId), nullable(CheckpointedObjectId)]),
  hasNextPage: boolean()
});
var EventId = object({
  txDigest: TransactionDigest,
  eventSeq: SequenceNumber
});
var SuiEvent = object({
  id: EventId,
  // Move package where this event was emitted.
  packageId: ObjectId,
  // Move module where this event was emitted.
  transactionModule: string(),
  // Sender's Sui address.
  sender: SuiAddress,
  // Move event type.
  type: string(),
  // Parsed json value of the event
  parsedJson: optional(record(string(), any())),
  // Base 58 encoded bcs bytes of the move event
  bcs: optional(string()),
  timestampMs: optional(string())
});
var PaginatedEvents = object({
  data: array(SuiEvent),
  nextCursor: nullable(EventId),
  hasNextPage: boolean()
});
var SubscriptionId = number2();
var SubscriptionEvent = object({
  subscription: SubscriptionId,
  result: SuiEvent
});
var EpochId = string();
var SuiChangeEpoch = object({
  epoch: EpochId,
  storage_charge: string(),
  computation_charge: string(),
  storage_rebate: string(),
  epoch_start_timestamp_ms: optional(string())
});
var SuiConsensusCommitPrologue = object({
  epoch: EpochId,
  round: string(),
  commit_timestamp_ms: string()
});
var Genesis = object({
  objects: array(ObjectId)
});
var SuiArgument = union([
  literal("GasCoin"),
  object({ Input: number2() }),
  object({ Result: number2() }),
  object({ NestedResult: tuple([number2(), number2()]) })
]);
var MoveCallSuiTransaction = object({
  arguments: optional(array(SuiArgument)),
  type_arguments: optional(array(string())),
  package: ObjectId,
  module: string(),
  function: string()
});
var SuiTransaction = union([
  object({ MoveCall: MoveCallSuiTransaction }),
  object({ TransferObjects: tuple([array(SuiArgument), SuiArgument]) }),
  object({ SplitCoins: tuple([SuiArgument, array(SuiArgument)]) }),
  object({ MergeCoins: tuple([SuiArgument, array(SuiArgument)]) }),
  object({ Publish: tuple([SuiMovePackage, array(ObjectId)]) }),
  object({
    Upgrade: tuple([SuiMovePackage, array(ObjectId), ObjectId, SuiArgument])
  }),
  object({ MakeMoveVec: tuple([nullable(string()), array(SuiArgument)]) })
]);
var SuiCallArg = union([
  object({
    type: literal("pure"),
    valueType: optional(string()),
    value: SuiJsonValue
  }),
  object({
    type: literal("object"),
    objectType: literal("immOrOwnedObject"),
    objectId: ObjectId,
    version: SequenceNumber,
    digest: ObjectDigest
  }),
  object({
    type: literal("object"),
    objectType: literal("sharedObject"),
    objectId: ObjectId,
    initialSharedVersion: SequenceNumber,
    mutable: boolean()
  })
]);
var ProgrammableTransaction = object({
  transactions: array(SuiTransaction),
  inputs: array(SuiCallArg)
});
var SuiTransactionBlockKind = union([
  assign(SuiChangeEpoch, object({ kind: literal("ChangeEpoch") })),
  assign(
    SuiConsensusCommitPrologue,
    object({
      kind: literal("ConsensusCommitPrologue")
    })
  ),
  assign(Genesis, object({ kind: literal("Genesis") })),
  assign(
    ProgrammableTransaction,
    object({ kind: literal("ProgrammableTransaction") })
  )
]);
var SuiTransactionBlockData = object({
  // Eventually this will become union(literal('v1'), literal('v2'), ...)
  messageVersion: literal("v1"),
  transaction: SuiTransactionBlockKind,
  sender: SuiAddress,
  gasData: SuiGasData
  // this shit is diff bw wallet and explorer
});
var AuthoritySignature = string();
var GenericAuthoritySignature = union([
  AuthoritySignature,
  array(AuthoritySignature)
]);
var AuthorityQuorumSignInfo = object({
  epoch: EpochId,
  signature: GenericAuthoritySignature,
  signers_map: array(number2())
});
var GasCostSummary = object({
  computationCost: string(),
  storageCost: string(),
  storageRebate: string(),
  nonRefundableStorageFee: string()
});
var ExecutionStatusType = union([
  literal("success"),
  literal("failure")
]);
var ExecutionStatus = object({
  status: ExecutionStatusType,
  error: optional(string())
});
var OwnedObjectRef = object({
  owner: ObjectOwner,
  reference: SuiObjectRef
});
var TransactionEffectsModifiedAtVersions = object({
  objectId: ObjectId,
  sequenceNumber: SequenceNumber
});
var TransactionEffects = object({
  // Eventually this will become union(literal('v1'), literal('v2'), ...)
  messageVersion: literal("v1"),
  /** The status of the execution */
  status: ExecutionStatus,
  /** The epoch when this transaction was executed */
  executedEpoch: EpochId,
  /** The version that every modified (mutated or deleted) object had before it was modified by this transaction. **/
  modifiedAtVersions: optional(array(TransactionEffectsModifiedAtVersions)),
  gasUsed: GasCostSummary,
  /** The object references of the shared objects used in this transaction. Empty if no shared objects were used. */
  sharedObjects: optional(array(SuiObjectRef)),
  /** The transaction digest */
  transactionDigest: TransactionDigest,
  /** ObjectRef and owner of new objects created */
  created: optional(array(OwnedObjectRef)),
  /** ObjectRef and owner of mutated objects, including gas object */
  mutated: optional(array(OwnedObjectRef)),
  /**
   * ObjectRef and owner of objects that are unwrapped in this transaction.
   * Unwrapped objects are objects that were wrapped into other objects in the past,
   * and just got extracted out.
   */
  unwrapped: optional(array(OwnedObjectRef)),
  /** Object Refs of objects now deleted (the old refs) */
  deleted: optional(array(SuiObjectRef)),
  /** Object Refs of objects now deleted (the old refs) */
  unwrapped_then_deleted: optional(array(SuiObjectRef)),
  /** Object refs of objects now wrapped in other objects */
  wrapped: optional(array(SuiObjectRef)),
  /**
   * The updated gas object reference. Have a dedicated field for convenient access.
   * It's also included in mutated.
   */
  gasObject: OwnedObjectRef,
  /** The events emitted during execution. Note that only successful transactions emit events */
  eventsDigest: optional(TransactionEventDigest),
  /** The set of transaction digests this transaction depends on */
  dependencies: optional(array(TransactionDigest))
});
var TransactionEvents = array(SuiEvent);
var ReturnValueType = tuple([array(number2()), string()]);
var MutableReferenceOutputType = tuple([
  SuiArgument,
  array(number2()),
  string()
]);
var ExecutionResultType = object({
  mutableReferenceOutputs: optional(array(MutableReferenceOutputType)),
  returnValues: optional(array(ReturnValueType))
});
var DevInspectResults = object({
  effects: TransactionEffects,
  events: TransactionEvents,
  results: optional(array(ExecutionResultType)),
  error: optional(string())
});
var AuthorityName = string();
var SuiTransactionBlock = object({
  data: SuiTransactionBlockData,
  txSignatures: array(string())
});
var SuiObjectChangePublished = object({
  type: literal("published"),
  packageId: ObjectId,
  version: SequenceNumber,
  digest: ObjectDigest,
  modules: array(string())
});
var SuiObjectChangeTransferred = object({
  type: literal("transferred"),
  sender: SuiAddress,
  recipient: ObjectOwner,
  objectType: string(),
  objectId: ObjectId,
  version: SequenceNumber,
  digest: ObjectDigest
});
var SuiObjectChangeMutated = object({
  type: literal("mutated"),
  sender: SuiAddress,
  owner: ObjectOwner,
  objectType: string(),
  objectId: ObjectId,
  version: SequenceNumber,
  previousVersion: SequenceNumber,
  digest: ObjectDigest
});
var SuiObjectChangeDeleted = object({
  type: literal("deleted"),
  sender: SuiAddress,
  objectType: string(),
  objectId: ObjectId,
  version: SequenceNumber
});
var SuiObjectChangeWrapped = object({
  type: literal("wrapped"),
  sender: SuiAddress,
  objectType: string(),
  objectId: ObjectId,
  version: SequenceNumber
});
var SuiObjectChangeCreated = object({
  type: literal("created"),
  sender: SuiAddress,
  owner: ObjectOwner,
  objectType: string(),
  objectId: ObjectId,
  version: SequenceNumber,
  digest: ObjectDigest
});
var SuiObjectChange = union([
  SuiObjectChangePublished,
  SuiObjectChangeTransferred,
  SuiObjectChangeMutated,
  SuiObjectChangeDeleted,
  SuiObjectChangeWrapped,
  SuiObjectChangeCreated
]);
var BalanceChange = object({
  owner: ObjectOwner,
  coinType: string(),
  /* Coin balance change(positive means receive, negative means send) */
  amount: string()
});
var SuiTransactionBlockResponse = object({
  digest: TransactionDigest,
  transaction: optional(SuiTransactionBlock),
  effects: optional(TransactionEffects),
  events: optional(TransactionEvents),
  timestampMs: optional(string()),
  checkpoint: optional(string()),
  confirmedLocalExecution: optional(boolean()),
  objectChanges: optional(array(SuiObjectChange)),
  balanceChanges: optional(array(BalanceChange)),
  /* Errors that occurred in fetching/serializing the transaction. */
  errors: optional(array(string()))
});
var SuiTransactionBlockResponseOptions = object({
  /* Whether to show transaction input data. Default to be false. */
  showInput: optional(boolean()),
  /* Whether to show transaction effects. Default to be false. */
  showEffects: optional(boolean()),
  /* Whether to show transaction events. Default to be false. */
  showEvents: optional(boolean()),
  /* Whether to show object changes. Default to be false. */
  showObjectChanges: optional(boolean()),
  /* Whether to show coin balance changes. Default to be false. */
  showBalanceChanges: optional(boolean())
});
var PaginatedTransactionResponse = object({
  data: array(SuiTransactionBlockResponse),
  nextCursor: nullable(TransactionDigest),
  hasNextPage: boolean()
});
var DryRunTransactionBlockResponse = object({
  effects: TransactionEffects,
  events: TransactionEvents,
  objectChanges: array(SuiObjectChange),
  balanceChanges: array(BalanceChange),
  // TODO: Remove optional when this is rolled out to all networks:
  input: optional(SuiTransactionBlockData)
});
function getOption(option22) {
  if (typeof option22 === "object" && option22 !== null && "type" in option22 && option22.type.startsWith("0x1::option::Option<")) {
    return void 0;
  }
  return option22;
}
var SUI_FRAMEWORK_ADDRESS = "0x2";
var MOVE_STDLIB_ADDRESS = "0x1";
var OBJECT_MODULE_NAME = "object";
var ID_STRUCT_NAME = "ID";
var SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;
var SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId("0x6");
var CoinMetadataStruct = object({
  decimals: number2(),
  name: string(),
  symbol: string(),
  description: string(),
  iconUrl: nullable(string()),
  id: nullable(ObjectId)
});
var _Delegation = class {
  static isDelegationSuiObject(obj) {
    return "type" in obj && obj.type === _Delegation.SUI_OBJECT_TYPE;
  }
  constructor(obj) {
    this.suiObject = obj;
  }
  nextRewardUnclaimedEpoch() {
    return this.suiObject.data.fields.next_reward_unclaimed_epoch;
  }
  activeDelegation() {
    return BigInt(getOption(this.suiObject.data.fields.active_delegation) || 0);
  }
  delegateAmount() {
    return this.suiObject.data.fields.delegate_amount;
  }
  endingEpoch() {
    return getOption(this.suiObject.data.fields.ending_epoch);
  }
  validatorAddress() {
    return this.suiObject.data.fields.validator_address;
  }
  isActive() {
    return this.activeDelegation() > 0 && !this.endingEpoch();
  }
  hasUnclaimedRewards(epoch) {
    return this.nextRewardUnclaimedEpoch() <= epoch && (this.isActive() || (this.endingEpoch() || 0) > epoch);
  }
};
var Delegation = _Delegation;
Delegation.SUI_OBJECT_TYPE = "0x2::delegation::Delegation";
var VECTOR = "vector";
var TransactionDataV1 = {
  kind: "TransactionKind",
  sender: BCS.ADDRESS,
  gasData: "GasData",
  expiration: "TransactionExpiration"
};
var BCS_SPEC = {
  enums: {
    "Option<T>": {
      None: null,
      Some: "T"
    },
    ObjectArg: {
      ImmOrOwned: "SuiObjectRef",
      Shared: "SharedObjectRef"
    },
    CallArg: {
      Pure: [VECTOR, BCS.U8],
      Object: "ObjectArg",
      ObjVec: [VECTOR, "ObjectArg"]
    },
    TypeTag: {
      bool: null,
      u8: null,
      u64: null,
      u128: null,
      address: null,
      signer: null,
      vector: "TypeTag",
      struct: "StructTag",
      u16: null,
      u32: null,
      u256: null
    },
    TransactionKind: {
      // can not be called from sui.js; dummy placement
      // to set the enum counter right for ProgrammableTransact
      ProgrammableTransaction: "ProgrammableTransaction",
      ChangeEpoch: null,
      Genesis: null,
      ConsensusCommitPrologue: null
    },
    TransactionExpiration: {
      None: null,
      Epoch: BCS.U64
    },
    TransactionData: {
      V1: "TransactionDataV1"
    }
  },
  structs: {
    SuiObjectRef: {
      objectId: BCS.ADDRESS,
      version: BCS.U64,
      digest: "ObjectDigest"
    },
    SharedObjectRef: {
      objectId: BCS.ADDRESS,
      initialSharedVersion: BCS.U64,
      mutable: BCS.BOOL
    },
    StructTag: {
      address: BCS.ADDRESS,
      module: BCS.STRING,
      name: BCS.STRING,
      typeParams: [VECTOR, "TypeTag"]
    },
    GasData: {
      payment: [VECTOR, "SuiObjectRef"],
      owner: BCS.ADDRESS,
      price: BCS.U64,
      budget: BCS.U64
    },
    // Signed transaction data needed to generate transaction digest.
    SenderSignedData: {
      data: "TransactionData",
      txSignatures: [VECTOR, [VECTOR, BCS.U8]]
    },
    TransactionDataV1
  },
  aliases: {
    ObjectDigest: BCS.BASE58
  }
};
var bcs = new BCS({ ...getSuiMoveConfig(), types: BCS_SPEC });
bcs.registerType(
  "utf8string",
  (writer, str) => {
    const bytes2 = Array.from(new TextEncoder().encode(str));
    return writer.writeVec(bytes2, (writer2, el) => writer2.write8(el));
  },
  (reader) => {
    let bytes2 = reader.readVec((reader2) => reader2.read8());
    return new TextDecoder().decode(new Uint8Array(bytes2));
  }
);
var FaucetCoinInfo = object({
  amount: number2(),
  id: ObjectId,
  transferTxDigest: TransactionDigest
});
var FaucetResponse = object({
  transferredGasObjects: array(FaucetCoinInfo),
  error: nullable(string())
});
var SuiMoveFunctionArgType = union([
  string(),
  object({ Object: string() })
]);
var SuiMoveFunctionArgTypes = array(SuiMoveFunctionArgType);
var SuiMoveModuleId = object({
  address: string(),
  name: string()
});
var SuiMoveVisibility = union([
  literal("Private"),
  literal("Public"),
  literal("Friend")
]);
var SuiMoveAbilitySet = object({
  abilities: array(string())
});
var SuiMoveStructTypeParameter = object({
  constraints: SuiMoveAbilitySet,
  isPhantom: boolean()
});
var SuiMoveNormalizedTypeParameterType = object({
  TypeParameter: number2()
});
function isSuiMoveNormalizedType(value) {
  if (!value)
    return false;
  if (typeof value === "string")
    return true;
  if (is(value, SuiMoveNormalizedTypeParameterType))
    return true;
  if (isSuiMoveNormalizedStructType(value))
    return true;
  if (typeof value !== "object")
    return false;
  const valueProperties = value;
  if (is(valueProperties.Reference, SuiMoveNormalizedType))
    return true;
  if (is(valueProperties.MutableReference, SuiMoveNormalizedType))
    return true;
  if (is(valueProperties.Vector, SuiMoveNormalizedType))
    return true;
  return false;
}
var SuiMoveNormalizedType = define2(
  "SuiMoveNormalizedType",
  isSuiMoveNormalizedType
);
function isSuiMoveNormalizedStructType(value) {
  if (!value || typeof value !== "object")
    return false;
  const valueProperties = value;
  if (!valueProperties.Struct || typeof valueProperties.Struct !== "object")
    return false;
  const structProperties = valueProperties.Struct;
  if (typeof structProperties.address !== "string" || typeof structProperties.module !== "string" || typeof structProperties.name !== "string" || !Array.isArray(structProperties.typeArguments) || !structProperties.typeArguments.every(
    (value2) => isSuiMoveNormalizedType(value2)
  )) {
    return false;
  }
  return true;
}
var SuiMoveNormalizedStructType = define2(
  "SuiMoveNormalizedStructType",
  isSuiMoveNormalizedStructType
);
var SuiMoveNormalizedFunction = object({
  visibility: SuiMoveVisibility,
  isEntry: boolean(),
  typeParameters: array(SuiMoveAbilitySet),
  parameters: array(SuiMoveNormalizedType),
  return: array(SuiMoveNormalizedType)
});
var SuiMoveNormalizedField = object({
  name: string(),
  type: SuiMoveNormalizedType
});
var SuiMoveNormalizedStruct = object({
  abilities: SuiMoveAbilitySet,
  typeParameters: array(SuiMoveStructTypeParameter),
  fields: array(SuiMoveNormalizedField)
});
var SuiMoveNormalizedModule = object({
  fileFormatVersion: number2(),
  address: string(),
  name: string(),
  friends: array(SuiMoveModuleId),
  structs: record(string(), SuiMoveNormalizedStruct),
  exposedFunctions: record(string(), SuiMoveNormalizedFunction)
});
var SuiMoveNormalizedModules = record(
  string(),
  SuiMoveNormalizedModule
);
function extractMutableReference(normalizedType) {
  return typeof normalizedType === "object" && "MutableReference" in normalizedType ? normalizedType.MutableReference : void 0;
}
function extractReference(normalizedType) {
  return typeof normalizedType === "object" && "Reference" in normalizedType ? normalizedType.Reference : void 0;
}
function extractStructTag(normalizedType) {
  if (typeof normalizedType === "object" && "Struct" in normalizedType) {
    return normalizedType;
  }
  const ref = extractReference(normalizedType);
  const mutRef = extractMutableReference(normalizedType);
  if (typeof ref === "object" && "Struct" in ref) {
    return ref;
  }
  if (typeof mutRef === "object" && "Struct" in mutRef) {
    return mutRef;
  }
  return void 0;
}
var Balance = object({
  value: number2()
});
var StakeObject = object({
  stakedSuiId: ObjectId,
  stakeRequestEpoch: EpochId,
  stakeActiveEpoch: EpochId,
  principal: string(),
  status: union([literal("Active"), literal("Pending"), literal("Unstaked")]),
  estimatedReward: optional(string())
});
var DelegatedStake = object({
  validatorAddress: SuiAddress,
  stakingPool: ObjectId,
  stakes: array(StakeObject)
});
var StakeSubsidyFields = object({
  balance: object({ value: number2() }),
  distribution_counter: number2(),
  current_distribution_amount: number2(),
  stake_subsidy_period_length: number2(),
  stake_subsidy_decrease_rate: number2()
});
var StakeSubsidy = object({
  type: string(),
  fields: StakeSubsidyFields
});
var SuiSupplyFields = object({
  value: number2()
});
var ContentsFields = object({
  id: string(),
  size: number2(),
  head: object({ vec: array() }),
  tail: object({ vec: array() })
});
var ContentsFieldsWithdraw = object({
  id: string(),
  size: number2()
});
var Contents = object({
  type: string(),
  fields: ContentsFields
});
var DelegationStakingPoolFields = object({
  exchangeRates: object({
    id: string(),
    size: number2()
  }),
  id: string(),
  pendingStake: number2(),
  pendingPoolTokenWithdraw: number2(),
  pendingTotalSuiWithdraw: number2(),
  poolTokenBalance: number2(),
  rewardsPool: object({ value: number2() }),
  activationEpoch: object({ vec: array() }),
  deactivationEpoch: object({ vec: array() }),
  suiBalance: number2()
});
var DelegationStakingPool = object({
  type: string(),
  fields: DelegationStakingPoolFields
});
var Validators = array(tuple([AuthorityName, string()]));
var CommitteeInfo = object({
  epoch: EpochId,
  /** Array of (validator public key, stake unit) tuple */
  validators: Validators
});
var SuiValidatorSummary = object({
  suiAddress: SuiAddress,
  protocolPubkeyBytes: string(),
  networkPubkeyBytes: string(),
  workerPubkeyBytes: string(),
  proofOfPossessionBytes: string(),
  operationCapId: string(),
  name: string(),
  description: string(),
  imageUrl: string(),
  projectUrl: string(),
  p2pAddress: string(),
  netAddress: string(),
  primaryAddress: string(),
  workerAddress: string(),
  nextEpochProtocolPubkeyBytes: nullable(string()),
  nextEpochProofOfPossession: nullable(string()),
  nextEpochNetworkPubkeyBytes: nullable(string()),
  nextEpochWorkerPubkeyBytes: nullable(string()),
  nextEpochNetAddress: nullable(string()),
  nextEpochP2pAddress: nullable(string()),
  nextEpochPrimaryAddress: nullable(string()),
  nextEpochWorkerAddress: nullable(string()),
  votingPower: string(),
  gasPrice: string(),
  commissionRate: string(),
  nextEpochStake: string(),
  nextEpochGasPrice: string(),
  nextEpochCommissionRate: string(),
  stakingPoolId: string(),
  stakingPoolActivationEpoch: nullable(string()),
  stakingPoolDeactivationEpoch: nullable(string()),
  stakingPoolSuiBalance: string(),
  rewardsPool: string(),
  poolTokenBalance: string(),
  pendingStake: string(),
  pendingPoolTokenWithdraw: string(),
  pendingTotalSuiWithdraw: string(),
  exchangeRatesId: string(),
  exchangeRatesSize: string()
});
var SuiSystemStateSummary = object({
  epoch: string(),
  protocolVersion: string(),
  systemStateVersion: string(),
  storageFundTotalObjectStorageRebates: string(),
  storageFundNonRefundableBalance: string(),
  referenceGasPrice: string(),
  safeMode: boolean(),
  safeModeStorageRewards: string(),
  safeModeComputationRewards: string(),
  safeModeStorageRebates: string(),
  safeModeNonRefundableStorageFee: string(),
  epochStartTimestampMs: string(),
  epochDurationMs: string(),
  stakeSubsidyStartEpoch: string(),
  maxValidatorCount: string(),
  minValidatorJoiningStake: string(),
  validatorLowStakeThreshold: string(),
  validatorVeryLowStakeThreshold: string(),
  validatorLowStakeGracePeriod: string(),
  stakeSubsidyBalance: string(),
  stakeSubsidyDistributionCounter: string(),
  stakeSubsidyCurrentDistributionAmount: string(),
  stakeSubsidyPeriodLength: string(),
  stakeSubsidyDecreaseRate: number2(),
  totalStake: string(),
  activeValidators: array(SuiValidatorSummary),
  pendingActiveValidatorsId: string(),
  pendingActiveValidatorsSize: string(),
  pendingRemovals: array(string()),
  stakingPoolMappingsId: string(),
  stakingPoolMappingsSize: string(),
  inactivePoolsId: string(),
  inactivePoolsSize: string(),
  validatorCandidatesId: string(),
  validatorCandidatesSize: string(),
  atRiskValidators: array(tuple([SuiAddress, string()])),
  validatorReportRecords: array(tuple([SuiAddress, array(SuiAddress)]))
});
var CoinStruct = object({
  coinType: string(),
  // TODO(chris): rename this to objectId
  coinObjectId: ObjectId,
  version: string(),
  digest: TransactionDigest,
  balance: string(),
  lockedUntilEpoch: nullable(number2()),
  previousTransaction: TransactionDigest
});
var PaginatedCoins = object({
  data: array(CoinStruct),
  nextCursor: nullable(ObjectId),
  hasNextPage: boolean()
});
var CoinBalance = object({
  coinType: string(),
  coinObjectCount: number2(),
  totalBalance: string(),
  lockedBalance: object({
    epochId: optional(number2()),
    number: optional(number2())
  })
});
var CoinSupply = object({
  value: string()
});
var GasCostSummary2 = object({
  computationCost: string(),
  storageCost: string(),
  storageRebate: string(),
  nonRefundableStorageFee: string()
});
var CheckPointContentsDigest = string();
var CheckpointDigest = string();
var ECMHLiveObjectSetDigest = object({
  digest: array(number2())
});
var CheckpointCommitment = any();
var ValidatorSignature = string();
var EndOfEpochData = object({
  nextEpochCommittee: array(tuple([string(), string()])),
  nextEpochProtocolVersion: string(),
  epochCommitments: array(CheckpointCommitment)
});
var ExecutionDigests = object({
  transaction: TransactionDigest,
  effects: TransactionEffectsDigest
});
var Checkpoint = object({
  epoch: string(),
  sequenceNumber: string(),
  digest: CheckpointDigest,
  networkTotalTransactions: string(),
  previousDigest: optional(CheckpointDigest),
  epochRollingGasCostSummary: GasCostSummary2,
  timestampMs: string(),
  endOfEpochData: optional(EndOfEpochData),
  // TODO(jian): remove optional after 0.30.0 is released
  validatorSignature: optional(ValidatorSignature),
  transactions: array(TransactionDigest),
  checkpointCommitments: array(CheckpointCommitment)
});
var CheckpointPage = object({
  data: array(Checkpoint),
  nextCursor: nullable(string()),
  hasNextPage: boolean()
});
var SIGNATURE_SCHEME_TO_FLAG = {
  ED25519: 0,
  Secp256k1: 1
};
var SIGNATURE_FLAG_TO_SCHEME = {
  0: "ED25519",
  1: "Secp256k1"
};
function fromSerializedSignature(serializedSignature) {
  const bytes2 = fromB64(serializedSignature);
  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes2[0]];
  const PublicKey2 = signatureScheme === "ED25519" ? Ed25519PublicKey : Secp256k1PublicKey;
  const signature = bytes2.slice(1, bytes2.length - PublicKey2.SIZE);
  const pubkeyBytes = bytes2.slice(1 + signature.length);
  const pubKey = new PublicKey2(pubkeyBytes);
  return {
    signatureScheme,
    signature,
    pubKey
  };
}
var PUBLIC_KEY_SIZE = 32;
var Ed25519PublicKey = class {
  /**
   * Create a new Ed25519PublicKey object
   * @param value ed25519 public key as buffer or base-64 encoded string
   */
  constructor(value) {
    if (typeof value === "string") {
      this.data = fromB64(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Ed25519 public keys are equal
   */
  equals(publicKey) {
    return bytesEqual(this.toBytes(), publicKey.toBytes());
  }
  /**
   * Return the base-64 representation of the Ed25519 public key
   */
  toBase64() {
    return toB64(this.toBytes());
  }
  /**
   * Return the byte array representation of the Ed25519 public key
   */
  toBytes() {
    return this.data;
  }
  /**
   * Return the base-64 representation of the Ed25519 public key
   */
  toString() {
    return this.toBase64();
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  toSuiAddress() {
    let tmp = new Uint8Array(PUBLIC_KEY_SIZE + 1);
    tmp.set([SIGNATURE_SCHEME_TO_FLAG["ED25519"]]);
    tmp.set(this.toBytes(), 1);
    return normalizeSuiAddress(
      bytesToHex(blake2b(tmp, { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH2 * 2)
    );
  }
};
Ed25519PublicKey.SIZE = PUBLIC_KEY_SIZE;
function bytesEqual(a10, b5) {
  if (a10 === b5)
    return true;
  if (a10.length !== b5.length) {
    return false;
  }
  for (let i17 = 0; i17 < a10.length; i17++) {
    if (a10[i17] !== b5[i17]) {
      return false;
    }
  }
  return true;
}
var SECP256K1_PUBLIC_KEY_SIZE = 33;
var Secp256k1PublicKey = class {
  /**
   * Create a new Secp256k1PublicKey object
   * @param value secp256k1 public key as buffer or base-64 encoded string
   */
  constructor(value) {
    if (typeof value === "string") {
      this.data = fromB64(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== SECP256K1_PUBLIC_KEY_SIZE) {
      throw new Error(
        `Invalid public key input. Expected ${SECP256K1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Secp256k1 public keys are equal
   */
  equals(publicKey) {
    return bytesEqual(this.toBytes(), publicKey.toBytes());
  }
  /**
   * Return the base-64 representation of the Secp256k1 public key
   */
  toBase64() {
    return toB64(this.toBytes());
  }
  /**
   * Return the byte array representation of the Secp256k1 public key
   */
  toBytes() {
    return this.data;
  }
  /**
   * Return the base-64 representation of the Secp256k1 public key
   */
  toString() {
    return this.toBase64();
  }
  /**
   * Return the Sui address associated with this Secp256k1 public key
   */
  toSuiAddress() {
    let tmp = new Uint8Array(SECP256K1_PUBLIC_KEY_SIZE + 1);
    tmp.set([SIGNATURE_SCHEME_TO_FLAG["Secp256k1"]]);
    tmp.set(this.toBytes(), 1);
    return normalizeSuiAddress(
      bytesToHex(blake2b(tmp, { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH2 * 2)
    );
  }
};
Secp256k1PublicKey.SIZE = SECP256K1_PUBLIC_KEY_SIZE;
var pathRegex = new RegExp("^m(\\/[0-9]+')+$");
var PACKAGE_VERSION = "0.0.0-experimental-20230418011747";
var TARGETED_RPC_VERSION = "0.33.0";
var RPCError = class extends Error {
  constructor(options) {
    super("RPC Error", { cause: options.cause });
    this.req = options.req;
    this.code = options.code;
    this.data = options.data;
  }
};
var RPCValidationError = class extends Error {
  constructor(options) {
    super(
      "RPC Validation Error: The response returned from RPC server does not match the TypeScript definition. This is likely because the SDK version is not compatible with the RPC server.",
      { cause: options.cause }
    );
    this.req = options.req;
    this.result = options.result;
    this.message = this.toString();
  }
  toString() {
    let str = super.toString();
    if (this.cause) {
      str += `
Cause: ${this.cause}`;
    }
    if (this.result) {
      str += `
Reponse Received: ${JSON.stringify(this.result, null, 2)}`;
    }
    return str;
  }
};
var FaucetRateLimitError = class extends Error {
};
var ValidResponse = object({
  jsonrpc: literal("2.0"),
  id: string(),
  result: any()
});
var ErrorResponse = object({
  jsonrpc: literal("2.0"),
  id: string(),
  error: object({
    code: any(),
    message: string(),
    data: optional(any())
  })
});
var JsonRpcClient = class {
  constructor(url, httpHeaders) {
    this.rpcClient = new import_browser.default(
      async (request, callback) => {
        const options = {
          method: "POST",
          body: request,
          headers: {
            "Content-Type": "application/json",
            "Client-Sdk-Type": "typescript",
            "Client-Sdk-Version": PACKAGE_VERSION,
            "Client-Target-Api-Version": TARGETED_RPC_VERSION,
            ...httpHeaders
          }
        };
        try {
          let res = await fetch(url, options);
          const result = await res.text();
          if (res.ok) {
            callback(null, result);
          } else {
            const isHtml = res.headers.get("content-type") === "text/html";
            callback(
              new Error(
                `${res.status} ${res.statusText}${isHtml ? "" : `: ${result}`}`
              )
            );
          }
        } catch (err) {
          callback(err);
        }
      },
      {}
    );
  }
  async requestWithType(method, args, struct) {
    const req = { method, args };
    const response = await this.request(method, args);
    if (is(response, ErrorResponse)) {
      throw new RPCError({
        req,
        code: response.error.code,
        data: response.error.data,
        cause: new Error(response.error.message)
      });
    } else if (is(response, ValidResponse)) {
      const [err] = validate(response.result, struct);
      if (err) {
        console.warn(
          new RPCValidationError({
            req,
            result: response.result,
            cause: err
          })
        );
        return response.result;
      }
      return response.result;
    }
    throw new RPCError({ req, data: response });
  }
  async request(method, args) {
    return new Promise((resolve, reject) => {
      this.rpcClient.request(method, args, (err, response) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  }
};
var DynamicFieldType = union([
  literal("DynamicField"),
  literal("DynamicObject")
]);
var DynamicFieldName = object({
  type: string(),
  value: any()
});
var DynamicFieldInfo = object({
  name: DynamicFieldName,
  bcsName: string(),
  type: DynamicFieldType,
  objectType: string(),
  objectId: ObjectId,
  version: number2(),
  digest: string()
});
var DynamicFieldPage = object({
  data: array(DynamicFieldInfo),
  nextCursor: nullable(ObjectId),
  hasNextPage: boolean()
});
var getWebsocketUrl = (httpUrl, port) => {
  const url = new URL(httpUrl);
  url.protocol = url.protocol.replace("http", "ws");
  if (port) {
    url.port = port.toString();
  }
  return url.toString();
};
var isMinimumSubscriptionMessage = (msg) => msg && "subscription" in msg && typeof msg["subscription"] === "number" && "result" in msg && typeof msg["result"] === "object";
var DEFAULT_CLIENT_OPTIONS = {
  connectTimeout: 15e3,
  callTimeout: 3e4,
  reconnectInterval: 3e3,
  maxReconnects: 5
};
var SUBSCRIBE_EVENT_METHOD = "suix_subscribeEvent";
var UNSUBSCRIBE_EVENT_METHOD = "suix_unsubscribeEvent";
var WebsocketClient = class {
  /**
   * @param endpoint Sui node endpoint to connect to (accepts websocket & http)
   * @param options Configuration options, such as timeouts & connection behavior
   */
  constructor(endpoint, options = DEFAULT_CLIENT_OPTIONS) {
    this.endpoint = endpoint;
    this.options = options;
    this.connectionState = 0;
    this.connectionTimeout = null;
    this.isSetup = false;
    this.connectionPromise = null;
    this.eventSubscriptions = /* @__PURE__ */ new Map();
    if (this.endpoint.startsWith("http"))
      this.endpoint = getWebsocketUrl(this.endpoint);
    this.rpcClient = new import_rpc_websockets.Client(this.endpoint, {
      reconnect_interval: this.options.reconnectInterval,
      max_reconnects: this.options.maxReconnects,
      autoconnect: false
    });
  }
  setupSocket() {
    if (this.isSetup)
      return;
    this.rpcClient.on("open", () => {
      if (this.connectionTimeout) {
        clearTimeout(this.connectionTimeout);
        this.connectionTimeout = null;
      }
      this.connectionState = 2;
      this.rpcClient.socket.on(
        "message",
        this.onSocketMessage.bind(this)
      );
    });
    this.rpcClient.on("close", () => {
      this.connectionState = 0;
    });
    this.rpcClient.on("error", console.error);
    this.isSetup = true;
  }
  // called for every message received from the node over websocket
  onSocketMessage(rawMessage) {
    const msg = JSON.parse(rawMessage);
    const params = msg.params;
    if (msg.method === SUBSCRIBE_EVENT_METHOD) {
      if (isMinimumSubscriptionMessage(params)) {
        const sub = this.eventSubscriptions.get(params.subscription);
        if (sub)
          sub.onMessage(params.result);
      } else if (is(params, SubscriptionEvent)) {
        const sub = this.eventSubscriptions.get(params.subscription);
        if (sub)
          sub.onMessage(params.result);
      }
    }
  }
  async connect() {
    if (this.connectionPromise)
      return this.connectionPromise;
    if (this.connectionState === 2)
      return Promise.resolve();
    this.setupSocket();
    this.rpcClient.connect();
    this.connectionState = 1;
    this.connectionPromise = new Promise((resolve, reject) => {
      this.connectionTimeout = setTimeout(
        () => reject(new Error("timeout")),
        this.options.connectTimeout
      );
      this.rpcClient.once("open", () => {
        this.refreshSubscriptions();
        this.connectionPromise = null;
        resolve();
      });
      this.rpcClient.once("error", (err) => {
        this.connectionPromise = null;
        reject(err);
      });
    });
    return this.connectionPromise;
  }
  /**
    call only upon reconnecting to a node over websocket.
    calling multiple times on the same connection will result
    in multiple message handlers firing each time
  */
  async refreshSubscriptions() {
    if (this.eventSubscriptions.size === 0)
      return;
    try {
      let newSubs = /* @__PURE__ */ new Map();
      let newSubsArr = await Promise.all(
        Array.from(this.eventSubscriptions.values()).map(async (sub) => {
          const onMessage = sub.onMessage;
          const filter = sub.filter;
          if (!filter || !onMessage)
            return Promise.resolve(null);
          const id = await this.subscribeEvent(filter, onMessage);
          return { id, onMessage, filter };
        })
      );
      newSubsArr.forEach((entry) => {
        if (entry === null)
          return;
        const filter = entry.filter;
        const onMessage = entry.onMessage;
        newSubs.set(entry.id, { filter, onMessage });
      });
      this.eventSubscriptions = newSubs;
    } catch (err) {
      throw new Error(`error refreshing event subscriptions: ${err}`);
    }
  }
  async subscribeEvent(filter, onMessage) {
    try {
      if (this.connectionState !== 2)
        await this.connect();
      let subId = await this.rpcClient.call(
        SUBSCRIBE_EVENT_METHOD,
        [filter],
        this.options.callTimeout
      );
      this.eventSubscriptions.set(subId, { filter, onMessage });
      return subId;
    } catch (err) {
      throw new Error(
        `Error subscribing to event: ${JSON.stringify(
          err,
          null,
          2
        )}, filter: ${JSON.stringify(filter)}`
      );
    }
  }
  async unsubscribeEvent(id) {
    try {
      if (this.connectionState !== 2)
        await this.connect();
      let removedOnNode = await this.rpcClient.call(
        UNSUBSCRIBE_EVENT_METHOD,
        [id],
        this.options.callTimeout
      );
      return this.eventSubscriptions.delete(id) || removedOnNode;
    } catch (err) {
      throw new Error(
        `Error unsubscribing from event: ${err}, subscription: ${id}`
      );
    }
  }
};
async function requestSuiFromFaucet(endpoint, recipient, httpHeaders) {
  const res = await fetch(endpoint, {
    method: "POST",
    body: JSON.stringify({
      FixedAmountRequest: {
        recipient
      }
    }),
    headers: {
      "Content-Type": "application/json",
      ...httpHeaders || {}
    }
  });
  if (res.status === 429) {
    throw new FaucetRateLimitError(
      `Too many requests from this client have been sent to the faucet. Please retry later`
    );
  }
  let parsed;
  try {
    parsed = await res.json();
  } catch (e16) {
    throw new Error(
      `Encountered error when parsing response from faucet, error: ${e16}, status ${res.status}, response ${res}`
    );
  }
  if (parsed.error) {
    throw new Error(`Faucet returns error: ${parsed.error}`);
  }
  return parsed;
}
var _options;
var Connection = class {
  constructor(options) {
    __privateAdd(this, _options, void 0);
    __privateSet(this, _options, options);
  }
  get fullnode() {
    return __privateGet(this, _options).fullnode;
  }
  // TODO: Decide if we should default the websocket URL like this:
  get websocket() {
    return __privateGet(this, _options).websocket || __privateGet(this, _options).fullnode;
  }
  get faucet() {
    return __privateGet(this, _options).faucet;
  }
};
_options = /* @__PURE__ */ new WeakMap();
var localnetConnection = new Connection({
  fullnode: "http://127.0.0.1:9000",
  faucet: "http://127.0.0.1:9123/gas"
});
var devnetConnection = new Connection({
  fullnode: "https://fullnode.devnet.sui.io:443/",
  faucet: "https://faucet.devnet.sui.io/gas"
});
var testnetConnection = new Connection({
  fullnode: "https://fullnode.testnet.sui.io:443/",
  faucet: "https://faucet.testnet.sui.io/gas"
});
function create2(value, struct) {
  return create(value, struct);
}
var TRANSACTION_TYPE = Symbol("transaction-argument-type");
var option = (some) => union([object({ None: literal(null) }), object({ Some: some })]);
var TransactionBlockInput = object({
  kind: literal("Input"),
  index: integer(),
  value: optional(any()),
  type: optional(union([literal("pure"), literal("object")]))
});
var TransactionArgumentTypes = [
  TransactionBlockInput,
  object({ kind: literal("GasCoin") }),
  object({ kind: literal("Result"), index: integer() }),
  object({
    kind: literal("NestedResult"),
    index: integer(),
    resultIndex: integer()
  })
];
var TransactionArgument = union([...TransactionArgumentTypes]);
var ObjectTransactionArgument = union([...TransactionArgumentTypes]);
ObjectTransactionArgument[TRANSACTION_TYPE] = {
  kind: "object"
};
var PureTransactionArgument = (type2) => {
  const struct = union([...TransactionArgumentTypes]);
  struct[TRANSACTION_TYPE] = {
    kind: "pure",
    type: type2
  };
  return struct;
};
var MoveCallTransaction = object({
  kind: literal("MoveCall"),
  target: define2(
    "target",
    string().validator
  ),
  typeArguments: array(string()),
  arguments: array(TransactionArgument)
});
var TransferObjectsTransaction = object({
  kind: literal("TransferObjects"),
  objects: array(ObjectTransactionArgument),
  address: PureTransactionArgument(BCS.ADDRESS)
});
var SplitCoinsTransaction = object({
  kind: literal("SplitCoins"),
  coin: ObjectTransactionArgument,
  amounts: array(PureTransactionArgument("u64"))
});
var MergeCoinsTransaction = object({
  kind: literal("MergeCoins"),
  destination: ObjectTransactionArgument,
  sources: array(ObjectTransactionArgument)
});
var MakeMoveVecTransaction = object({
  kind: literal("MakeMoveVec"),
  type: optional(option(string())),
  objects: array(ObjectTransactionArgument)
});
var PublishTransaction = object({
  kind: literal("Publish"),
  modules: array(array(integer())),
  dependencies: array(ObjectId)
});
var UpgradePolicy = ((UpgradePolicy22) => {
  UpgradePolicy22[UpgradePolicy22["COMPATIBLE"] = 0] = "COMPATIBLE";
  UpgradePolicy22[UpgradePolicy22["ADDITIVE"] = 128] = "ADDITIVE";
  UpgradePolicy22[UpgradePolicy22["DEP_ONLY"] = 192] = "DEP_ONLY";
  return UpgradePolicy22;
})(UpgradePolicy || {});
var UpgradeTransaction = object({
  kind: literal("Upgrade"),
  modules: array(array(integer())),
  dependencies: array(ObjectId),
  packageId: ObjectId,
  ticket: ObjectTransactionArgument
});
var TransactionTypes = [
  MoveCallTransaction,
  TransferObjectsTransaction,
  SplitCoinsTransaction,
  MergeCoinsTransaction,
  PublishTransaction,
  UpgradeTransaction,
  MakeMoveVecTransaction
];
var TransactionType = union([...TransactionTypes]);
function getTransactionType(data) {
  assert2(data, TransactionType);
  return TransactionTypes.find((schema) => is(data, schema));
}
var Transactions = {
  MoveCall(input) {
    return create2(
      {
        kind: "MoveCall",
        target: input.target,
        arguments: input.arguments ?? [],
        typeArguments: input.typeArguments ?? []
      },
      MoveCallTransaction
    );
  },
  TransferObjects(objects, address) {
    return create2(
      { kind: "TransferObjects", objects, address },
      TransferObjectsTransaction
    );
  },
  SplitCoins(coin, amounts) {
    return create2({ kind: "SplitCoins", coin, amounts }, SplitCoinsTransaction);
  },
  MergeCoins(destination, sources) {
    return create2(
      { kind: "MergeCoins", destination, sources },
      MergeCoinsTransaction
    );
  },
  Publish({
    modules,
    dependencies
  }) {
    return create2(
      {
        kind: "Publish",
        modules: modules.map(
          (module) => typeof module === "string" ? Array.from(fromB64(module)) : module
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep))
      },
      PublishTransaction
    );
  },
  Upgrade({
    modules,
    dependencies,
    packageId,
    ticket
  }) {
    return create2(
      {
        kind: "Upgrade",
        modules: modules.map(
          (module) => typeof module === "string" ? Array.from(fromB64(module)) : module
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),
        packageId,
        ticket
      },
      UpgradeTransaction
    );
  },
  MakeMoveVec({
    type: type2,
    objects
  }) {
    return create2(
      {
        kind: "MakeMoveVec",
        type: type2 ? { Some: type2 } : { None: null },
        objects
      },
      MakeMoveVecTransaction
    );
  }
};
var VECTOR_REGEX = /^vector<(.+)>$/;
var STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
var TypeTagSerializer = class {
  static parseFromStr(str, normalizeAddress = false) {
    if (str === "address") {
      return { address: null };
    } else if (str === "bool") {
      return { bool: null };
    } else if (str === "u8") {
      return { u8: null };
    } else if (str === "u16") {
      return { u16: null };
    } else if (str === "u32") {
      return { u32: null };
    } else if (str === "u64") {
      return { u64: null };
    } else if (str === "u128") {
      return { u128: null };
    } else if (str === "u256") {
      return { u256: null };
    } else if (str === "signer") {
      return { signer: null };
    }
    const vectorMatch = str.match(VECTOR_REGEX);
    if (vectorMatch) {
      return {
        vector: TypeTagSerializer.parseFromStr(
          vectorMatch[1],
          normalizeAddress
        )
      };
    }
    const structMatch = str.match(STRUCT_REGEX);
    if (structMatch) {
      const address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];
      return {
        struct: {
          address,
          module: structMatch[2],
          name: structMatch[3],
          typeParams: structMatch[5] === void 0 ? [] : TypeTagSerializer.parseStructTypeArgs(
            structMatch[5],
            normalizeAddress
          )
        }
      };
    }
    throw new Error(
      `Encountered unexpected token when parsing type args for ${str}`
    );
  }
  static parseStructTypeArgs(str, normalizeAddress = false) {
    const tok = [];
    let word = "";
    let nestedAngleBrackets = 0;
    for (let i17 = 0; i17 < str.length; i17++) {
      const char = str[i17];
      if (char === "<") {
        nestedAngleBrackets++;
      }
      if (char === ">") {
        nestedAngleBrackets--;
      }
      if (nestedAngleBrackets === 0 && char === ",") {
        tok.push(word.trim());
        word = "";
        continue;
      }
      word += char;
    }
    tok.push(word.trim());
    return tok.map(
      (tok2) => TypeTagSerializer.parseFromStr(tok2, normalizeAddress)
    );
  }
  static tagToString(tag) {
    if ("bool" in tag) {
      return "bool";
    }
    if ("u8" in tag) {
      return "u8";
    }
    if ("u16" in tag) {
      return "u16";
    }
    if ("u32" in tag) {
      return "u32";
    }
    if ("u64" in tag) {
      return "u64";
    }
    if ("u128" in tag) {
      return "u128";
    }
    if ("u256" in tag) {
      return "u256";
    }
    if ("address" in tag) {
      return "address";
    }
    if ("signer" in tag) {
      return "signer";
    }
    if ("vector" in tag) {
      return `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;
    }
    if ("struct" in tag) {
      const struct = tag.struct;
      const typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(", ");
      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
};
var ARGUMENT_INNER = "Argument";
var VECTOR2 = "vector";
var OPTION = "Option";
var CALL_ARG = "CallArg";
var TYPE_TAG = "TypeTag";
var PROGRAMMABLE_TX_BLOCK = "ProgrammableTransaction";
var PROGRAMMABLE_CALL_INNER = "ProgrammableMoveCall";
var TRANSACTION_INNER = "Transaction";
var ENUM_KIND = "EnumKind";
var TRANSACTION = [ENUM_KIND, TRANSACTION_INNER];
var ARGUMENT = [ENUM_KIND, ARGUMENT_INNER];
var PROGRAMMABLE_CALL = "SimpleProgrammableMoveCall";
var builder = new BCS(bcs).registerStructType(PROGRAMMABLE_TX_BLOCK, {
  inputs: [VECTOR2, CALL_ARG],
  transactions: [VECTOR2, TRANSACTION]
}).registerEnumType(ARGUMENT_INNER, {
  GasCoin: null,
  Input: { index: BCS.U16 },
  Result: { index: BCS.U16 },
  NestedResult: { index: BCS.U16, resultIndex: BCS.U16 }
}).registerStructType(PROGRAMMABLE_CALL_INNER, {
  package: BCS.ADDRESS,
  module: BCS.STRING,
  function: BCS.STRING,
  type_arguments: [VECTOR2, TYPE_TAG],
  arguments: [VECTOR2, ARGUMENT]
}).registerEnumType(TRANSACTION_INNER, {
  /**
   * A Move Call - any public Move function can be called via
   * this transaction. The results can be used that instant to pass
   * into the next transaction.
   */
  MoveCall: PROGRAMMABLE_CALL,
  /**
   * Transfer vector of objects to a receiver.
   */
  TransferObjects: {
    objects: [VECTOR2, ARGUMENT],
    address: ARGUMENT
  },
  /**
   * Split `amount` from a `coin`.
   */
  SplitCoins: { coin: ARGUMENT, amounts: [VECTOR2, ARGUMENT] },
  /**
   * Merge Vector of Coins (`sources`) into a `destination`.
   */
  MergeCoins: { destination: ARGUMENT, sources: [VECTOR2, ARGUMENT] },
  /**
   * Publish a Move module.
   */
  Publish: {
    modules: [VECTOR2, [VECTOR2, BCS.U8]],
    dependencies: [VECTOR2, BCS.ADDRESS]
  },
  /**
   * Build a vector of objects using the input arguments.
   * It is impossible to construct a `vector<T: key>` otherwise,
   * so this call serves a utility function.
   */
  MakeMoveVec: {
    type: [OPTION, TYPE_TAG],
    objects: [VECTOR2, ARGUMENT]
  },
  /**  */
  Upgrade: {
    modules: [VECTOR2, [VECTOR2, BCS.U8]],
    dependencies: [VECTOR2, BCS.ADDRESS],
    packageId: BCS.ADDRESS,
    ticket: ARGUMENT
  }
});
builder.registerType(
  [ENUM_KIND, "T"],
  function encode(writer, data, typeParams, typeMap) {
    const kind = data.kind;
    const invariant = { [kind]: data };
    const [enumType] = typeParams;
    return this.getTypeInterface(enumType)._encodeRaw.call(
      this,
      writer,
      invariant,
      typeParams,
      typeMap
    );
  },
  function decode(reader, typeParams, typeMap) {
    const [enumType] = typeParams;
    const data = this.getTypeInterface(enumType)._decodeRaw.call(
      this,
      reader,
      typeParams,
      typeMap
    );
    const kind = Object.keys(data)[0];
    return { kind, ...data[kind] };
  },
  (data) => {
    if (typeof data !== "object" && !("kind" in data)) {
      throw new Error(
        `EnumKind: Missing property "kind" in the input ${JSON.stringify(
          data
        )}`
      );
    }
    return true;
  }
);
builder.registerType(
  PROGRAMMABLE_CALL,
  function encodeProgrammableTx(writer, data, typeParams, typeMap) {
    const [pkg, module, fun] = data.target.split("::");
    const type_arguments = data.typeArguments.map(
      (tag) => TypeTagSerializer.parseFromStr(tag, true)
    );
    return this.getTypeInterface(PROGRAMMABLE_CALL_INNER)._encodeRaw.call(
      this,
      writer,
      {
        package: normalizeSuiAddress(pkg),
        module,
        function: fun,
        type_arguments,
        arguments: data.arguments
      },
      typeParams,
      typeMap
    );
  },
  function decodeProgrammableTx(reader, typeParams, typeMap) {
    let data = builder.getTypeInterface(PROGRAMMABLE_CALL_INNER)._decodeRaw.call(this, reader, typeParams, typeMap);
    return {
      target: [data.package, data.module, data.function].join("::"),
      arguments: data.arguments,
      typeArguments: data.type_arguments.map(TypeTagSerializer.tagToString)
    };
  },
  // Validation callback to error out if the data format is invalid.
  // TODO: make sure TypeTag can be parsed.
  (data) => {
    return data.target.split("::").length === 3;
  }
);
var ObjectArg = union([
  object({ ImmOrOwned: SuiObjectRef }),
  object({
    Shared: object({
      objectId: string(),
      initialSharedVersion: union([integer(), string()]),
      mutable: boolean()
    })
  })
]);
var PureCallArg = object({ Pure: array(integer()) });
var ObjectCallArg = object({ Object: ObjectArg });
var BuilderCallArg = union([PureCallArg, ObjectCallArg]);
var Inputs = {
  Pure(data, type2) {
    return {
      Pure: Array.from(
        data instanceof Uint8Array ? data : builder.ser(type2, data).toBytes()
      )
    };
  },
  ObjectRef({ objectId, digest, version: version2 }) {
    return {
      Object: {
        ImmOrOwned: {
          digest,
          version: version2,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  },
  SharedObjectRef({
    objectId,
    mutable,
    initialSharedVersion
  }) {
    return {
      Object: {
        Shared: {
          mutable,
          initialSharedVersion,
          objectId: normalizeSuiAddress(objectId)
        }
      }
    };
  }
};
function getIdFromCallArg(arg) {
  if (typeof arg === "string") {
    return normalizeSuiAddress(arg);
  }
  if ("ImmOrOwned" in arg.Object) {
    return normalizeSuiAddress(arg.Object.ImmOrOwned.objectId);
  }
  return normalizeSuiAddress(arg.Object.Shared.objectId);
}
function getSharedObjectInput(arg) {
  return typeof arg === "object" && "Object" in arg && "Shared" in arg.Object ? arg.Object.Shared : void 0;
}
function isMutableSharedObjectInput(arg) {
  var _a;
  return ((_a = getSharedObjectInput(arg)) == null ? void 0 : _a.mutable) ?? false;
}
var STD_ASCII_MODULE_NAME = "ascii";
var STD_ASCII_STRUCT_NAME = "String";
var STD_UTF8_MODULE_NAME = "string";
var STD_UTF8_STRUCT_NAME = "String";
var STD_OPTION_MODULE_NAME = "option";
var STD_OPTION_STRUCT_NAME = "Option";
var RESOLVED_SUI_ID = {
  address: SUI_FRAMEWORK_ADDRESS,
  module: OBJECT_MODULE_NAME,
  name: ID_STRUCT_NAME
};
var RESOLVED_ASCII_STR = {
  address: MOVE_STDLIB_ADDRESS,
  module: STD_ASCII_MODULE_NAME,
  name: STD_ASCII_STRUCT_NAME
};
var RESOLVED_UTF8_STR = {
  address: MOVE_STDLIB_ADDRESS,
  module: STD_UTF8_MODULE_NAME,
  name: STD_UTF8_STRUCT_NAME
};
var RESOLVED_STD_OPTION = {
  address: MOVE_STDLIB_ADDRESS,
  module: STD_OPTION_MODULE_NAME,
  name: STD_OPTION_STRUCT_NAME
};
var isSameStruct = (a10, b5) => a10.address === b5.address && a10.module === b5.module && a10.name === b5.name;
function isTxContext(param) {
  var _a;
  const struct = (_a = extractStructTag(param)) == null ? void 0 : _a.Struct;
  return (struct == null ? void 0 : struct.address) === "0x2" && (struct == null ? void 0 : struct.module) === "tx_context" && (struct == null ? void 0 : struct.name) === "TxContext";
}
function expectType(typeName, argVal) {
  if (typeof argVal === "undefined") {
    return;
  }
  if (typeof argVal !== typeName) {
    throw new Error(
      `Expect ${argVal} to be ${typeName}, received ${typeof argVal}`
    );
  }
}
var allowedTypes = [
  "Address",
  "Bool",
  "U8",
  "U16",
  "U32",
  "U64",
  "U128",
  "U256"
];
function getPureSerializationType(normalizedType, argVal) {
  if (typeof normalizedType === "string" && allowedTypes.includes(normalizedType)) {
    if (normalizedType in ["U8", "U16", "U32", "U64", "U128", "U256"]) {
      expectType("number", argVal);
    } else if (normalizedType === "Bool") {
      expectType("boolean", argVal);
    } else if (normalizedType === "Address") {
      expectType("string", argVal);
      if (argVal && !isValidSuiAddress(argVal)) {
        throw new Error("Invalid Sui Address");
      }
    }
    return normalizedType.toLowerCase();
  } else if (typeof normalizedType === "string") {
    throw new Error(
      `Unknown pure normalized type ${JSON.stringify(normalizedType, null, 2)}`
    );
  }
  if ("Vector" in normalizedType) {
    if ((argVal === void 0 || typeof argVal === "string") && normalizedType.Vector === "U8") {
      return "string";
    }
    if (argVal !== void 0 && !Array.isArray(argVal)) {
      throw new Error(
        `Expect ${argVal} to be a array, received ${typeof argVal}`
      );
    }
    const innerType = getPureSerializationType(
      normalizedType.Vector,
      // undefined when argVal is empty
      argVal ? argVal[0] : void 0
    );
    if (innerType === void 0) {
      return;
    }
    return `vector<${innerType}>`;
  }
  if ("Struct" in normalizedType) {
    if (isSameStruct(normalizedType.Struct, RESOLVED_ASCII_STR)) {
      return "string";
    } else if (isSameStruct(normalizedType.Struct, RESOLVED_UTF8_STR)) {
      return "utf8string";
    } else if (isSameStruct(normalizedType.Struct, RESOLVED_SUI_ID)) {
      return "address";
    } else if (isSameStruct(normalizedType.Struct, RESOLVED_STD_OPTION)) {
      const optionToVec = {
        Vector: normalizedType.Struct.typeArguments[0]
      };
      return getPureSerializationType(optionToVec, argVal);
    }
  }
  return void 0;
}
function hashTypedData(typeTag, data) {
  const typeTagBytes = Array.from(`${typeTag}::`).map((e16) => e16.charCodeAt(0));
  const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);
  dataWithTag.set(typeTagBytes);
  dataWithTag.set(data, typeTagBytes.length);
  return blake2b(dataWithTag, { dkLen: 32 });
}
var TransactionExpiration = optional(
  nullable(
    union([
      object({ Epoch: integer() }),
      object({ None: union([literal(true), literal(null)]) })
    ])
  )
);
var SuiAddress3 = string();
var StringEncodedBigint = define2("StringEncodedBigint", (val) => {
  if (!["string", "number", "bigint"].includes(typeof val))
    return false;
  try {
    BigInt(val);
    return true;
  } catch {
    return false;
  }
});
var GasConfig = object({
  budget: optional(StringEncodedBigint),
  price: optional(StringEncodedBigint),
  payment: optional(array(SuiObjectRef)),
  owner: optional(SuiAddress3)
});
var SerializedTransactionDataBuilder = object({
  version: literal(1),
  sender: optional(SuiAddress3),
  expiration: TransactionExpiration,
  gasConfig: GasConfig,
  inputs: array(TransactionBlockInput),
  transactions: array(TransactionType)
});
function prepareSuiAddress(address) {
  return normalizeSuiAddress(address).replace("0x", "");
}
var TRANSACTION_DATA_MAX_SIZE = 128 * 1024;
var TransactionBlockDataBuilder = class {
  constructor(clone2) {
    this.version = 1;
    this.sender = clone2 == null ? void 0 : clone2.sender;
    this.expiration = clone2 == null ? void 0 : clone2.expiration;
    this.gasConfig = (clone2 == null ? void 0 : clone2.gasConfig) ?? {};
    this.inputs = (clone2 == null ? void 0 : clone2.inputs) ?? [];
    this.transactions = (clone2 == null ? void 0 : clone2.transactions) ?? [];
  }
  static fromKindBytes(bytes2) {
    const kind = builder.de("TransactionKind", bytes2);
    const programmableTx = kind == null ? void 0 : kind.ProgrammableTransaction;
    if (!programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    const serialized = create2(
      {
        version: 1,
        gasConfig: {},
        inputs: programmableTx.inputs.map(
          (value, index) => create2(
            {
              kind: "Input",
              value,
              index,
              type: is(value, PureCallArg) ? "pure" : "object"
            },
            TransactionBlockInput
          )
        ),
        transactions: programmableTx.transactions
      },
      SerializedTransactionDataBuilder
    );
    return TransactionBlockDataBuilder.restore(serialized);
  }
  static fromBytes(bytes2) {
    var _a;
    const rawData = builder.de("TransactionData", bytes2);
    const data = rawData == null ? void 0 : rawData.V1;
    const programmableTx = (_a = data == null ? void 0 : data.kind) == null ? void 0 : _a.ProgrammableTransaction;
    if (!data || !programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    const serialized = create2(
      {
        version: 1,
        sender: data.sender,
        expiration: data.expiration,
        gasConfig: data.gasData,
        inputs: programmableTx.inputs.map(
          (value, index) => create2(
            {
              kind: "Input",
              value,
              index,
              type: is(value, PureCallArg) ? "pure" : "object"
            },
            TransactionBlockInput
          )
        ),
        transactions: programmableTx.transactions
      },
      SerializedTransactionDataBuilder
    );
    return TransactionBlockDataBuilder.restore(serialized);
  }
  static restore(data) {
    assert2(data, SerializedTransactionDataBuilder);
    const transactionData = new TransactionBlockDataBuilder();
    Object.assign(transactionData, data);
    return transactionData;
  }
  /**
   * Generate transaction digest.
   *
   * @param bytes BCS serialized transaction data
   * @returns transaction digest.
   */
  static getDigestFromBytes(bytes2) {
    const hash2 = hashTypedData("TransactionData", bytes2);
    return toB58(hash2);
  }
  build({
    overrides,
    onlyTransactionKind
  } = {}) {
    const inputs = this.inputs.map((input) => {
      assert2(input.value, BuilderCallArg);
      return input.value;
    });
    const kind = {
      ProgrammableTransaction: {
        inputs,
        transactions: this.transactions
      }
    };
    if (onlyTransactionKind) {
      return builder.ser("TransactionKind", kind, { maxSize: TRANSACTION_DATA_MAX_SIZE }).toBytes();
    }
    const expiration = (overrides == null ? void 0 : overrides.expiration) ?? this.expiration;
    const sender = (overrides == null ? void 0 : overrides.sender) ?? this.sender;
    const gasConfig = { ...this.gasConfig, ...overrides == null ? void 0 : overrides.gasConfig };
    if (!sender) {
      throw new Error("Missing transaction sender");
    }
    if (!gasConfig.budget) {
      throw new Error("Missing gas budget");
    }
    if (!gasConfig.payment) {
      throw new Error("Missing gas payment");
    }
    if (!gasConfig.price) {
      throw new Error("Missing gas price");
    }
    const transactionData = {
      sender: prepareSuiAddress(sender),
      expiration: expiration ? expiration : { None: true },
      gasData: {
        payment: gasConfig.payment,
        owner: prepareSuiAddress(this.gasConfig.owner ?? sender),
        price: BigInt(gasConfig.price),
        budget: BigInt(gasConfig.budget)
      },
      kind: {
        ProgrammableTransaction: {
          inputs,
          transactions: this.transactions
        }
      }
    };
    return builder.ser(
      "TransactionData",
      { V1: transactionData },
      { maxSize: TRANSACTION_DATA_MAX_SIZE }
    ).toBytes();
  }
  getDigest() {
    const bytes2 = this.build({ onlyTransactionKind: false });
    return TransactionBlockDataBuilder.getDigestFromBytes(bytes2);
  }
  snapshot() {
    return create2(this, SerializedTransactionDataBuilder);
  }
};
function createTransactionResult(index) {
  const baseResult = { kind: "Result", index };
  const nestedResults = [];
  const nestedResultFor = (resultIndex) => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {
    kind: "NestedResult",
    index,
    resultIndex
  });
  return new Proxy(baseResult, {
    set() {
      throw new Error(
        "The transaction result is a proxy, and does not support setting properties directly"
      );
    },
    // TODO: Instead of making this return a concrete argument, we should ideally
    // make it reference-based (so that this gets resolved at build-time), which
    // allows re-ordering transactions.
    get(target, property) {
      if (property in target) {
        return Reflect.get(target, property);
      }
      if (property === Symbol.iterator) {
        return function* () {
          let i17 = 0;
          while (true) {
            yield nestedResultFor(i17);
            i17++;
          }
        };
      }
      if (typeof property === "symbol")
        return;
      const resultIndex = parseInt(property, 10);
      if (Number.isNaN(resultIndex) || resultIndex < 0)
        return;
      return nestedResultFor(resultIndex);
    }
  });
}
function expectProvider(provider) {
  if (!provider) {
    throw new Error(
      `No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`
    );
  }
  return provider;
}
var TRANSACTION_BRAND = Symbol.for("@mysten/transaction");
var MAX_GAS_OBJECTS = 256;
var MAX_GAS = 1e9;
var GAS_OVERHEAD_PER_COIN = 10n;
var _blockData;
var _input;
var input_fn;
var _selectGasPayment;
var selectGasPayment_fn;
var _prepare;
var prepare_fn;
var _TransactionBlock = class {
  constructor(transaction) {
    __privateAdd(this, _input);
    __privateAdd(this, _selectGasPayment);
    __privateAdd(this, _prepare);
    __privateAdd(this, _blockData, void 0);
    __privateSet(this, _blockData, new TransactionBlockDataBuilder(
      transaction ? transaction.blockData : void 0
    ));
  }
  /** Returns `true` if the object is an instance of the Transaction builder class. */
  static is(obj) {
    return !!obj && typeof obj === "object" && obj[TRANSACTION_BRAND] === true;
  }
  /**
   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.
   * Supports either a byte array, or base64-encoded bytes.
   */
  static fromKind(serialized) {
    const tx = new _TransactionBlock();
    __privateSet(tx, _blockData, TransactionBlockDataBuilder.fromKindBytes(
      typeof serialized === "string" ? fromB64(serialized) : serialized
    ));
    return tx;
  }
  /**
   * Converts from a serialized transaction format to a `Transaction` class.
   * There are two supported serialized formats:
   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.
   * - A byte array (or base64-encoded bytes) containing BCS transaction data.
   */
  static from(serialized) {
    const tx = new _TransactionBlock();
    if (typeof serialized !== "string" || !serialized.startsWith("{")) {
      __privateSet(tx, _blockData, TransactionBlockDataBuilder.fromBytes(
        typeof serialized === "string" ? fromB64(serialized) : serialized
      ));
    } else {
      __privateSet(tx, _blockData, TransactionBlockDataBuilder.restore(
        JSON.parse(serialized)
      ));
    }
    return tx;
  }
  /** A helper to retrieve the Transaction builder `Transactions` */
  static get Transactions() {
    return Transactions;
  }
  /** A helper to retrieve the Transaction builder `Inputs` */
  static get Inputs() {
    return Inputs;
  }
  setSender(sender) {
    __privateGet(this, _blockData).sender = sender;
  }
  /**
   * Sets the sender only if it has not already been set.
   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.
   */
  setSenderIfNotSet(sender) {
    if (!__privateGet(this, _blockData).sender) {
      __privateGet(this, _blockData).sender = sender;
    }
  }
  setExpiration(expiration) {
    __privateGet(this, _blockData).expiration = expiration;
  }
  setGasPrice(price) {
    __privateGet(this, _blockData).gasConfig.price = String(price);
  }
  setGasBudget(budget) {
    __privateGet(this, _blockData).gasConfig.budget = String(budget);
  }
  setGasOwner(owner) {
    __privateGet(this, _blockData).gasConfig.owner = owner;
  }
  setGasPayment(payments) {
    if (payments.length >= MAX_GAS_OBJECTS) {
      throw new Error(
        `Payment objects exceed maximum amount ${MAX_GAS_OBJECTS}`
      );
    }
    __privateGet(this, _blockData).gasConfig.payment = payments.map(
      (payment) => mask(payment, SuiObjectRef)
    );
  }
  /** Get a snapshot of the transaction data, in JSON form: */
  get blockData() {
    return __privateGet(this, _blockData).snapshot();
  }
  // Used to brand transaction classes so that they can be identified, even between multiple copies
  // of the builder.
  get [TRANSACTION_BRAND]() {
    return true;
  }
  /** Returns an argument for the gas coin, to be used in a transaction. */
  get gas() {
    return { kind: "GasCoin" };
  }
  /**
   * Add a new object input to the transaction.
   */
  object(value) {
    const id = getIdFromCallArg(value);
    const inserted = __privateGet(this, _blockData).inputs.find(
      (i17) => i17.type === "object" && id === getIdFromCallArg(i17.value)
    );
    return inserted ?? __privateMethod(this, _input, input_fn).call(this, "object", value);
  }
  /**
   * Add a new object input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  objectRef(...args) {
    return this.object(Inputs.ObjectRef(...args));
  }
  /**
   * Add a new shared object input to the transaction using the fully-resolved shared object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  sharedObjectRef(...args) {
    return this.object(Inputs.SharedObjectRef(...args));
  }
  /**
   * Add a new non-object input to the transaction.
   */
  pure(value, type2) {
    return __privateMethod(this, _input, input_fn).call(this, "pure", value instanceof Uint8Array ? Inputs.Pure(value) : type2 ? Inputs.Pure(value, type2) : value);
  }
  /** Add a transaction to the transaction block. */
  add(transaction) {
    const index = __privateGet(this, _blockData).transactions.push(transaction);
    return createTransactionResult(index - 1);
  }
  // Method shorthands:
  splitCoins(...args) {
    return this.add(Transactions.SplitCoins(...args));
  }
  mergeCoins(...args) {
    return this.add(Transactions.MergeCoins(...args));
  }
  publish(...args) {
    return this.add(Transactions.Publish(...args));
  }
  upgrade(...args) {
    return this.add(Transactions.Upgrade(...args));
  }
  moveCall(...args) {
    return this.add(Transactions.MoveCall(...args));
  }
  transferObjects(...args) {
    return this.add(Transactions.TransferObjects(...args));
  }
  makeMoveVec(...args) {
    return this.add(Transactions.MakeMoveVec(...args));
  }
  /**
   * Serialize the transaction to a string so that it can be sent to a separate context.
   * This is different from `build` in that it does not serialize to BCS bytes, and instead
   * uses a separate format that is unique to the transaction builder. This allows
   * us to serialize partially-complete transactions, that can then be completed and
   * built in a separate context.
   *
   * For example, a dapp can construct a transaction, but not provide gas objects
   * or a gas budget. The transaction then can be sent to the wallet, where this
   * information is automatically filled in (e.g. by querying for coin objects
   * and performing a dry run).
   */
  serialize() {
    return JSON.stringify(__privateGet(this, _blockData).snapshot());
  }
  /** Build the transaction to BCS bytes. */
  async build({
    provider,
    onlyTransactionKind
  } = {}) {
    await __privateMethod(this, _prepare, prepare_fn).call(this, { provider, onlyTransactionKind });
    return __privateGet(this, _blockData).build({ onlyTransactionKind });
  }
  /** Derive transaction digest */
  async getDigest({
    provider
  } = {}) {
    await __privateMethod(this, _prepare, prepare_fn).call(this, { provider });
    return __privateGet(this, _blockData).getDigest();
  }
};
var TransactionBlock = _TransactionBlock;
_blockData = /* @__PURE__ */ new WeakMap();
_input = /* @__PURE__ */ new WeakSet();
input_fn = function(type2, value) {
  const index = __privateGet(this, _blockData).inputs.length;
  const input = create2(
    {
      kind: "Input",
      // bigints can't be serialized to JSON, so just string-convert them here:
      value: typeof value === "bigint" ? String(value) : value,
      index,
      type: type2
    },
    TransactionBlockInput
  );
  __privateGet(this, _blockData).inputs.push(input);
  return input;
};
_selectGasPayment = /* @__PURE__ */ new WeakSet();
selectGasPayment_fn = async function(provider) {
  const gasOwner = __privateGet(this, _blockData).gasConfig.owner ?? __privateGet(this, _blockData).sender;
  const coins = await expectProvider(provider).getCoins({
    owner: gasOwner,
    coinType: SUI_TYPE_ARG
  });
  const paymentCoins = coins.data.filter((coin) => {
    const matchingInput = __privateGet(this, _blockData).inputs.find((input) => {
      if (is(input.value, BuilderCallArg) && "Object" in input.value && "ImmOrOwned" in input.value.Object) {
        return coin.coinObjectId === input.value.Object.ImmOrOwned.objectId;
      }
      return false;
    });
    return !matchingInput;
  }).slice(0, MAX_GAS_OBJECTS - 1).map((coin) => ({
    objectId: coin.coinObjectId,
    digest: coin.digest,
    version: coin.version
  }));
  if (!paymentCoins.length) {
    throw new Error("No valid gas coins found for the transaction.");
  }
  return paymentCoins;
};
_prepare = /* @__PURE__ */ new WeakSet();
prepare_fn = async function({ provider, onlyTransactionKind }) {
  var _a;
  if (!onlyTransactionKind && !__privateGet(this, _blockData).sender) {
    throw new Error("Missing transaction sender");
  }
  const { inputs, transactions } = __privateGet(this, _blockData);
  const moveModulesToResolve = [];
  const objectsToResolve = [];
  transactions.forEach((transaction) => {
    if (transaction.kind === "MoveCall") {
      const needsResolution = transaction.arguments.some(
        (arg) => arg.kind === "Input" && !is(inputs[arg.index].value, BuilderCallArg)
      );
      if (needsResolution) {
        moveModulesToResolve.push(transaction);
      }
      return;
    }
    const transactionType = getTransactionType(transaction);
    if (!transactionType.schema)
      return;
    Object.entries(transaction).forEach(([key, value]) => {
      if (key === "kind")
        return;
      const keySchema = transactionType.schema[key];
      const isArray = keySchema.type === "array";
      const wellKnownEncoding = isArray ? keySchema.schema[TRANSACTION_TYPE] : keySchema[TRANSACTION_TYPE];
      if (!wellKnownEncoding)
        return;
      const encodeInput = (index) => {
        const input = inputs[index];
        if (!input) {
          throw new Error(`Missing input ${value.index}`);
        }
        if (is(input.value, BuilderCallArg))
          return;
        if (wellKnownEncoding.kind === "object" && typeof input.value === "string") {
          objectsToResolve.push({ id: input.value, input });
        } else if (wellKnownEncoding.kind === "pure") {
          input.value = Inputs.Pure(input.value, wellKnownEncoding.type);
        } else {
          throw new Error("Unexpected input format.");
        }
      };
      if (isArray) {
        value.forEach((arrayItem) => {
          if (arrayItem.kind !== "Input")
            return;
          encodeInput(arrayItem.index);
        });
      } else {
        if (value.kind !== "Input")
          return;
        encodeInput(value.index);
      }
    });
  });
  if (moveModulesToResolve.length) {
    await Promise.all(
      moveModulesToResolve.map(async (moveCall) => {
        const [packageId, moduleName, functionName] = moveCall.target.split("::");
        const normalized = await expectProvider(
          provider
        ).getNormalizedMoveFunction({
          package: normalizeSuiObjectId(packageId),
          module: moduleName,
          function: functionName
        });
        const hasTxContext = normalized.parameters.length > 0 && isTxContext(normalized.parameters.at(-1));
        const params = hasTxContext ? normalized.parameters.slice(0, normalized.parameters.length - 1) : normalized.parameters;
        if (params.length !== moveCall.arguments.length) {
          throw new Error("Incorrect number of arguments.");
        }
        params.forEach((param, i17) => {
          const arg = moveCall.arguments[i17];
          if (arg.kind !== "Input")
            return;
          const input = inputs[arg.index];
          if (is(input.value, BuilderCallArg))
            return;
          const inputValue = input.value;
          const serType = getPureSerializationType(param, inputValue);
          if (serType) {
            input.value = Inputs.Pure(inputValue, serType);
            return;
          }
          const structVal = extractStructTag(param);
          if (structVal != null || typeof param === "object" && "TypeParameter" in param) {
            if (typeof inputValue !== "string") {
              throw new Error(
                `Expect the argument to be an object id string, got ${JSON.stringify(
                  inputValue,
                  null,
                  2
                )}`
              );
            }
            objectsToResolve.push({
              id: inputValue,
              input,
              normalizedType: param
            });
            return;
          }
          throw new Error(
            `Unknown call arg type ${JSON.stringify(
              param,
              null,
              2
            )} for value ${JSON.stringify(inputValue, null, 2)}`
          );
        });
      })
    );
  }
  if (objectsToResolve.length) {
    const dedupedIds = [...new Set(objectsToResolve.map(({ id }) => id))];
    const objects = await expectProvider(provider).multiGetObjects({
      ids: dedupedIds,
      options: { showOwner: true }
    });
    let objectsById = new Map(
      dedupedIds.map((id, index) => {
        return [id, objects[index]];
      })
    );
    const invalidObjects = Array.from(objectsById).filter(([_2, obj]) => obj.error).map(([id, _2]) => id);
    if (invalidObjects.length) {
      throw new Error(
        `The following input objects are not invalid: ${invalidObjects.join(
          ", "
        )}`
      );
    }
    objectsToResolve.forEach(({ id, input, normalizedType }) => {
      const object18 = objectsById.get(id);
      const initialSharedVersion = getSharedObjectInitialVersion(object18);
      if (initialSharedVersion) {
        const mutable = isMutableSharedObjectInput(input.value) || normalizedType != null && extractMutableReference(normalizedType) != null;
        input.value = Inputs.SharedObjectRef({
          objectId: id,
          initialSharedVersion,
          mutable
        });
      } else {
        input.value = Inputs.ObjectRef(getObjectReference(object18));
      }
    });
  }
  if (!onlyTransactionKind) {
    if (!__privateGet(this, _blockData).gasConfig.price) {
      this.setGasPrice(await expectProvider(provider).getReferenceGasPrice());
    }
    if (!__privateGet(this, _blockData).gasConfig.payment) {
      __privateGet(this, _blockData).gasConfig.payment = await __privateMethod(this, _selectGasPayment, selectGasPayment_fn).call(this, provider);
    }
    if (!this.blockData.gasConfig.budget) {
      const dryRunResult = await expectProvider(
        provider
      ).dryRunTransactionBlock({
        transactionBlock: __privateGet(this, _blockData).build({
          overrides: {
            gasConfig: {
              budget: String(MAX_GAS),
              payment: []
            }
          }
        })
      });
      if (dryRunResult.effects.status.status !== "success") {
        throw new Error(
          `Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,
          { cause: dryRunResult }
        );
      }
      const coinOverhead = GAS_OVERHEAD_PER_COIN * BigInt(((_a = this.blockData.gasConfig.payment) == null ? void 0 : _a.length) || 0n) * BigInt(this.blockData.gasConfig.price || 1n);
      this.setGasBudget(
        BigInt(dryRunResult.effects.gasUsed.computationCost) + BigInt(dryRunResult.effects.gasUsed.storageCost) + coinOverhead
      );
    }
  }
};
var NetworkMetrics = object({
  currentTps: number2(),
  tps30Days: number2(),
  currentCheckpoint: string(),
  currentEpoch: string(),
  totalAddresses: string(),
  totalObjects: string(),
  totalPackages: string()
});
var EndOfEpochInfo = object({
  lastCheckpointId: string(),
  epochEndTimestamp: string(),
  protocolVersion: string(),
  referenceGasPrice: string(),
  totalStake: string(),
  storageFundReinvestment: string(),
  storageCharge: string(),
  storageRebate: string(),
  storageFundBalance: string(),
  stakeSubsidyAmount: string(),
  totalGasFees: string(),
  totalStakeRewardsDistributed: string(),
  leftoverStorageFundInflow: string()
});
var EpochInfo = object({
  epoch: string(),
  validators: array(SuiValidatorSummary),
  epochTotalTransactions: string(),
  firstCheckpointId: string(),
  epochStartTimestamp: string(),
  endOfEpochInfo: nullable(EndOfEpochInfo)
});
var EpochPage = object({
  data: array(EpochInfo),
  nextCursor: nullable(string()),
  hasNextPage: boolean()
});
var DEFAULT_OPTIONS = {
  socketOptions: DEFAULT_CLIENT_OPTIONS,
  versionCacheTimeoutInSeconds: 600
};
var JsonRpcProvider = class {
  /**
   * Establish a connection to a Sui RPC endpoint
   *
   * @param connection The `Connection` object containing configuration for the network.
   * @param options configuration options for the provider
   */
  constructor(connection = devnetConnection, options = DEFAULT_OPTIONS) {
    this.options = options;
    this.connection = connection;
    const opts = { ...DEFAULT_OPTIONS, ...options };
    this.options = opts;
    this.client = opts.rpcClient ?? new JsonRpcClient(this.connection.fullnode);
    this.wsClient = opts.websocketClient ?? new WebsocketClient(this.connection.websocket, opts.socketOptions);
  }
  async getRpcApiVersion() {
    if (this.rpcApiVersion && this.cacheExpiry && this.cacheExpiry <= Date.now()) {
      return this.rpcApiVersion;
    }
    try {
      const resp = await this.client.requestWithType("rpc.discover", [], any());
      this.rpcApiVersion = resp.info.version;
      this.cacheExpiry = // Date.now() is in milliseconds, but the timeout is in seconds
      Date.now() + (this.options.versionCacheTimeoutInSeconds ?? 0) * 1e3;
      return this.rpcApiVersion;
    } catch (err) {
      console.warn("Error fetching version number of the RPC API", err);
    }
    return void 0;
  }
  async requestSuiFromFaucet(recipient, httpHeaders) {
    if (!this.connection.faucet) {
      throw new Error("Faucet URL is not specified");
    }
    return requestSuiFromFaucet(this.connection.faucet, recipient, httpHeaders);
  }
  /**
   * Get all Coin<`coin_type`> objects owned by an address.
   */
  async getCoins(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.client.requestWithType(
      "suix_getCoins",
      [input.owner, input.coinType, input.cursor, input.limit],
      PaginatedCoins
    );
  }
  /**
   * Get all Coin objects owned by an address.
   */
  async getAllCoins(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.client.requestWithType(
      "suix_getAllCoins",
      [input.owner, input.cursor, input.limit],
      PaginatedCoins
    );
  }
  /**
   * Get the total coin balance for one coin type, owned by the address owner.
   */
  async getBalance(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.client.requestWithType(
      "suix_getBalance",
      [input.owner, input.coinType],
      CoinBalance
    );
  }
  /**
   * Get the total coin balance for all coin types, owned by the address owner.
   */
  async getAllBalances(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.client.requestWithType(
      "suix_getAllBalances",
      [input.owner],
      array(CoinBalance)
    );
  }
  /**
   * Fetch CoinMetadata for a given coin type
   */
  async getCoinMetadata(input) {
    return await this.client.requestWithType(
      "suix_getCoinMetadata",
      [input.coinType],
      CoinMetadataStruct
    );
  }
  /**
   *  Fetch total supply for a coin
   */
  async getTotalSupply(input) {
    return await this.client.requestWithType(
      "suix_getTotalSupply",
      [input.coinType],
      CoinSupply
    );
  }
  /**
   * Invoke any RPC method
   * @param method the method to be invoked
   * @param args the arguments to be passed to the RPC request
   */
  async call(method, args) {
    const response = await this.client.request(method, args);
    if (is(response, ErrorResponse)) {
      throw new RPCError({
        req: { method, args },
        code: response.error.code,
        data: response.error.data,
        cause: new Error(response.error.message)
      });
    }
    return response.result;
  }
  /**
   * Get Move function argument types like read, write and full access
   */
  async getMoveFunctionArgTypes(input) {
    return await this.client.requestWithType(
      "sui_getMoveFunctionArgTypes",
      [input.package, input.module, input.function],
      SuiMoveFunctionArgTypes
    );
  }
  /**
   * Get a map from module name to
   * structured representations of Move modules
   */
  async getNormalizedMoveModulesByPackage(input) {
    return await this.client.requestWithType(
      "sui_getNormalizedMoveModulesByPackage",
      [input.package],
      SuiMoveNormalizedModules
    );
  }
  /**
   * Get a structured representation of Move module
   */
  async getNormalizedMoveModule(input) {
    return await this.client.requestWithType(
      "sui_getNormalizedMoveModule",
      [input.package, input.module],
      SuiMoveNormalizedModule
    );
  }
  /**
   * Get a structured representation of Move function
   */
  async getNormalizedMoveFunction(input) {
    return await this.client.requestWithType(
      "sui_getNormalizedMoveFunction",
      [input.package, input.module, input.function],
      SuiMoveNormalizedFunction
    );
  }
  /**
   * Get a structured representation of Move struct
   */
  async getNormalizedMoveStruct(input) {
    return await this.client.requestWithType(
      "sui_getNormalizedMoveStruct",
      [input.package, input.module, input.struct],
      SuiMoveNormalizedStruct
    );
  }
  /**
   * Get all objects owned by an address
   */
  async getOwnedObjects(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.client.requestWithType(
      "suix_getOwnedObjects",
      [
        input.owner,
        {
          filter: input.filter,
          options: input.options
        },
        input.cursor,
        input.limit
      ],
      PaginatedObjectsResponse
    );
  }
  /**
   * Get details about an object
   */
  async getObject(input) {
    if (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) {
      throw new Error("Invalid Sui Object id");
    }
    return await this.client.requestWithType(
      "sui_getObject",
      [input.id, input.options],
      SuiObjectResponse
    );
  }
  /**
   * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail
   */
  async multiGetObjects(input) {
    input.ids.forEach((id) => {
      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {
        throw new Error(`Invalid Sui Object id ${id}`);
      }
    });
    const hasDuplicates = input.ids.length !== new Set(input.ids).size;
    if (hasDuplicates) {
      throw new Error(`Duplicate object ids in batch call ${input.ids}`);
    }
    return await this.client.requestWithType(
      "sui_multiGetObjects",
      [input.ids, input.options],
      array(SuiObjectResponse)
    );
  }
  /**
   * Get transaction blocks for a given query criteria
   */
  async queryTransactionBlocks(input) {
    return await this.client.requestWithType(
      "suix_queryTransactionBlocks",
      [
        {
          filter: input.filter,
          options: input.options
        },
        input.cursor,
        input.limit,
        (input.order || "descending") === "descending"
      ],
      PaginatedTransactionResponse
    );
  }
  async getTransactionBlock(input) {
    if (!isValidTransactionDigest(input.digest)) {
      throw new Error("Invalid Transaction digest");
    }
    return await this.client.requestWithType(
      "sui_getTransactionBlock",
      [input.digest, input.options],
      SuiTransactionBlockResponse
    );
  }
  async multiGetTransactionBlocks(input) {
    input.digests.forEach((d15) => {
      if (!isValidTransactionDigest(d15)) {
        throw new Error(`Invalid Transaction digest ${d15}`);
      }
    });
    const hasDuplicates = input.digests.length !== new Set(input.digests).size;
    if (hasDuplicates) {
      throw new Error(`Duplicate digests in batch call ${input.digests}`);
    }
    return await this.client.requestWithType(
      "sui_multiGetTransactionBlocks",
      [input.digests, input.options],
      array(SuiTransactionBlockResponse)
    );
  }
  async executeTransactionBlock(input) {
    return await this.client.requestWithType(
      "sui_executeTransactionBlock",
      [
        typeof input.transactionBlock === "string" ? input.transactionBlock : toB64(input.transactionBlock),
        Array.isArray(input.signature) ? input.signature : [input.signature],
        input.options,
        input.requestType
      ],
      SuiTransactionBlockResponse
    );
  }
  /**
   * Get total number of transactions
   */
  async getTotalTransactionBlocks() {
    const resp = await this.client.requestWithType(
      "sui_getTotalTransactionBlocks",
      [],
      string()
    );
    return BigInt(resp);
  }
  /**
   * Getting the reference gas price for the network
   */
  async getReferenceGasPrice() {
    const resp = await this.client.requestWithType(
      "suix_getReferenceGasPrice",
      [],
      string()
    );
    return BigInt(resp);
  }
  /**
   * Return the delegated stakes for an address
   */
  async getStakes(input) {
    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.client.requestWithType(
      "suix_getStakes",
      [input.owner],
      array(DelegatedStake)
    );
  }
  /**
   * Return the delegated stakes queried by id.
   */
  async getStakesByIds(input) {
    input.stakedSuiIds.forEach((id) => {
      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {
        throw new Error(`Invalid Sui Stake id ${id}`);
      }
    });
    return await this.client.requestWithType(
      "suix_getStakesByIds",
      [input.stakedSuiIds],
      array(DelegatedStake)
    );
  }
  /**
   * Return the latest system state content.
   */
  async getLatestSuiSystemState() {
    return await this.client.requestWithType(
      "suix_getLatestSuiSystemState",
      [],
      SuiSystemStateSummary
    );
  }
  /**
   * Get events for a given query criteria
   */
  async queryEvents(input) {
    return await this.client.requestWithType(
      "suix_queryEvents",
      [
        input.query,
        input.cursor,
        input.limit,
        (input.order || "descending") === "descending"
      ],
      PaginatedEvents
    );
  }
  /**
   * Subscribe to get notifications whenever an event matching the filter occurs
   */
  async subscribeEvent(input) {
    return this.wsClient.subscribeEvent(input.filter, input.onMessage);
  }
  /**
   * Unsubscribe from an event subscription
   */
  async unsubscribeEvent(input) {
    return this.wsClient.unsubscribeEvent(input.id);
  }
  /**
   * Runs the transaction block in dev-inspect mode. Which allows for nearly any
   * transaction (or Move call) with any arguments. Detailed results are
   * provided, including both the transaction effects and any return values.
   */
  async devInspectTransactionBlock(input) {
    let devInspectTxBytes;
    if (TransactionBlock.is(input.transactionBlock)) {
      input.transactionBlock.setSenderIfNotSet(input.sender);
      devInspectTxBytes = toB64(
        await input.transactionBlock.build({
          provider: this,
          onlyTransactionKind: true
        })
      );
    } else if (typeof input.transactionBlock === "string") {
      devInspectTxBytes = input.transactionBlock;
    } else if (input.transactionBlock instanceof Uint8Array) {
      devInspectTxBytes = toB64(input.transactionBlock);
    } else {
      throw new Error("Unknown transaction block format.");
    }
    return await this.client.requestWithType(
      "sui_devInspectTransactionBlock",
      [input.sender, devInspectTxBytes, input.gasPrice, input.epoch],
      DevInspectResults
    );
  }
  /**
   * Dry run a transaction block and return the result.
   */
  async dryRunTransactionBlock(input) {
    return await this.client.requestWithType(
      "sui_dryRunTransactionBlock",
      [
        typeof input.transactionBlock === "string" ? input.transactionBlock : toB64(input.transactionBlock)
      ],
      DryRunTransactionBlockResponse
    );
  }
  /**
   * Return the list of dynamic field objects owned by an object
   */
  async getDynamicFields(input) {
    if (!input.parentId || !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))) {
      throw new Error("Invalid Sui Object id");
    }
    return await this.client.requestWithType(
      "suix_getDynamicFields",
      [input.parentId, input.cursor, input.limit],
      DynamicFieldPage
    );
  }
  /**
   * Return the dynamic field object information for a specified object
   */
  async getDynamicFieldObject(input) {
    return await this.client.requestWithType(
      "suix_getDynamicFieldObject",
      [input.parentId, input.name],
      SuiObjectResponse
    );
  }
  /**
   * Get the sequence number of the latest checkpoint that has been executed
   */
  async getLatestCheckpointSequenceNumber() {
    const resp = await this.client.requestWithType(
      "sui_getLatestCheckpointSequenceNumber",
      [],
      string()
    );
    return String(resp);
  }
  /**
   * Returns information about a given checkpoint
   */
  async getCheckpoint(input) {
    return await this.client.requestWithType(
      "sui_getCheckpoint",
      [input.id],
      Checkpoint
    );
  }
  /**
   * Returns historical checkpoints paginated
   */
  async getCheckpoints(input) {
    const version2 = await this.getRpcApiVersion();
    const resp = await this.client.requestWithType(
      "sui_getCheckpoints",
      [
        input.cursor,
        version2 && (0, import_femver.lt)(version2, "0.32.0") ? String(input == null ? void 0 : input.limit) : input == null ? void 0 : input.limit,
        input.descendingOrder
      ],
      CheckpointPage
    );
    return resp;
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCommitteeInfo(input) {
    return await this.client.requestWithType(
      "suix_getCommitteeInfo",
      [input == null ? void 0 : input.epoch],
      CommitteeInfo
    );
  }
  async getNetworkMetrics() {
    return await this.client.requestWithType(
      "suix_getNetworkMetrics",
      [],
      NetworkMetrics
    );
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getEpochs(input) {
    const version2 = await this.getRpcApiVersion();
    return await this.client.requestWithType(
      "suix_getEpochs",
      [
        input == null ? void 0 : input.cursor,
        version2 && (0, import_femver.lt)(version2, "0.32.0") ? String(input == null ? void 0 : input.limit) : input == null ? void 0 : input.limit,
        input == null ? void 0 : input.descendingOrder
      ],
      EpochPage
    );
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCurrentEpoch() {
    return await this.client.requestWithType(
      "suix_getCurrentEpoch",
      [],
      EpochInfo
    );
  }
};
var AppId = ((AppId22) => {
  AppId22[AppId22["Sui"] = 0] = "Sui";
  return AppId22;
})(AppId || {});
var IntentVersion = ((IntentVersion22) => {
  IntentVersion22[IntentVersion22["V0"] = 0] = "V0";
  return IntentVersion22;
})(IntentVersion || {});
var IntentScope = ((IntentScope3) => {
  IntentScope3[IntentScope3["TransactionData"] = 0] = "TransactionData";
  IntentScope3[IntentScope3["TransactionEffects"] = 1] = "TransactionEffects";
  IntentScope3[IntentScope3["CheckpointSummary"] = 2] = "CheckpointSummary";
  IntentScope3[IntentScope3["PersonalMessage"] = 3] = "PersonalMessage";
  return IntentScope3;
})(IntentScope || {});
function intentWithScope(scope) {
  return [
    scope,
    0,
    0
    /* Sui */
  ];
}
function messageWithIntent(scope, message) {
  const intent = intentWithScope(scope);
  const intentMessage = new Uint8Array(intent.length + message.length);
  intentMessage.set(intent);
  intentMessage.set(message, intent.length);
  return intentMessage;
}
async function verifyMessage(message, serializedSignature, scope) {
  const signature = fromSerializedSignature(serializedSignature);
  const messageBytes = messageWithIntent(
    scope,
    typeof message === "string" ? fromB64(message) : message
  );
  const digest = blake2b(messageBytes, { dkLen: 32 });
  switch (signature.signatureScheme) {
    case "ED25519":
      return import_tweetnacl3.default.sign.detached.verify(
        digest,
        signature.signature,
        signature.pubKey.toBytes()
      );
    case "Secp256k1":
      return secp256k1.verify(
        secp256k1.Signature.fromCompact(signature.signature),
        sha256(digest),
        signature.pubKey.toBytes()
      );
    default:
      throw new Error(
        `Unknown signature scheme: "${signature.signatureScheme}"`
      );
  }
}
var SUI_SYSTEM_STATE_OBJECT_ID = normalizeSuiObjectId("0x5");

// node_modules/ethos-connect/dist/components/EthosConnectProvider.js
var import_react28 = __toESM(require_react(), 1);

// node_modules/ethos-connect/dist/components/styled/SignInModal.js
var import_react23 = __toESM(require_react(), 1);

// node_modules/ethos-connect/dist/components/svg/Loader.js
var import_react = __toESM(require_react(), 1);
var r = ({ width: t18 = 100, color: i17 = "#333" }) => import_react.default.createElement("svg", { version: "1.1", id: "L4", xmlns: "http://www.w3.org/2000/svg", x: "0px", y: "0px", viewBox: "0 0 54 20", width: t18, height: t18 * (20 / 54), enableBackground: "new 0 0 0 0" }, import_react.default.createElement("circle", { fill: i17, stroke: "none", cx: "6", cy: "10", r: "6" }, import_react.default.createElement("animate", { attributeName: "opacity", dur: "1.5s", values: "0;1;0", repeatCount: "indefinite", begin: "0.1" })), import_react.default.createElement("circle", { fill: i17, stroke: "none", cx: "26", cy: "10", r: "6" }, import_react.default.createElement("animate", { attributeName: "opacity", dur: "1.5s", values: "0;1;0", repeatCount: "indefinite", begin: "0.5" })), import_react.default.createElement("circle", { fill: i17, stroke: "none", cx: "46", cy: "10", r: "6" }, import_react.default.createElement("animate", { attributeName: "opacity", dur: "1.5s", values: "0;1;0", repeatCount: "indefinite", begin: "1.0" })));
var a = r;

// node_modules/ethos-connect/dist/components/svg/WalletsIcon.js
var import_react2 = __toESM(require_react(), 1);
var W = ({ width: A2 = 32 }) => import_react2.default.createElement("img", { src: C, width: A2, height: A2 });
var m = W;
var C = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAeGVYSWZNTQAqAAAACAAFARIAAwAAAAEAAQAAARoABQAAAAEAAABKARsABQAAAAEAAABSASgAAwAAAAEAAgAAh2kABAAAAAEAAABaAAAAAAAAAEgAAAABAAAASAAAAAEAAqACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAAAQdIdCAAAACXBIWXMAAAsTAAALEwEAmpwYAAACZmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjU2PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjU2PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiB3yYcAAAgwSURBVFgJrZddiJ1HGcefmXfe9z3n7G42yTYamy9sklZT0XilAeuFdwXxQrD4gVKwF6IXohdS8CYXJWJFwQvprXhTaOhVFakFjbGWioqItKYXprVda0OaNNnd8/F+jr//nN1k16RCwLM778w8M2f+//k/zzzzHme3+Zw+/Zuw+94TK7mvDucxHCws3h2ie19u9p68d3vy3kaFuYG3diH4We/9dJaF2SzLKG58xWfTyz4b/zvPJqsun6zW9eS1j2785ap76Gz333Buu+H0M2+OwrQ5Wzj/YBbNhWiWR2eAG+CxiJ6+WeijK5KNMWssy6YGCdWR4pwbWwgTbGNsam9QxtH5jSfqS6vfuv+hs/UW7g0C33l69WARu38GMx/Mxaw3l5uAXQypPScjQihgxSY51cE3mwQmAApY9Rx8Xs8JZNm6y/z6uCjHRw5+7GdXRMLr8bmnYtZZe6Hx0TdQalUYaVy02qKTjfpGUb/xLjbeotpdn1uMZey60vp+sFlKm/dxYJRddR77mC+0bfZyjKcTNhs221e89khjbhTZTc+DDbrAwmgWIx0sUMGgj6MbkQE3yOY8hTnWFy74HlB1OnOuTaXvW8BZ3eUOEtE5EQn73njxwleY+FMRcJ23M1BL6wQWjJDQ4n3sXX+TiAMSQoBDTNj84SAm43XYQqSkyZS+x9IB1lJvEaghUtOvWB8Sff6DRODrT720UFm717uMfTrWnxPp5VuBg8KSLnrUoEMcYmQO+8eDPMRHIokWoduVLkge1yXwmwTkkgqCBTVh7sPKhec/sxTqpeye2MKSBWPEsS5jB2wGcJFgYzBXu8MGCW1Wam0S2VJLdqbyBUK4G9CUC+SKDkAFacPUGn2IpjgDo3QL+cL7Q9O3xwnF6NmlAc6IdgtgFg/sLu3LJ1fcgeVCS+uTMObN2z53jM/GtV144YJV641IMFZBpKZdooACM9wXWl8fz5JgWfSA9z7AFAlQ5Esn73YXrkztr29xtFAjFThkYCM2tUs29jzvy0ZRX8d3tOjcoRNH7JUX1llPKtSclArwASoUwJTHyTHN0R4JCDnAgQDcm1c02PdffD1WtUAUIT7mSB9UEwvzXOBSPiixFXBWTijx2QAxKW5A0AyH5Jx+gd12gDeAb5EYupDNjobeNUcURYouoOZuYEGcZSujwj1y6qAd2lVK7y15t+rtPridzaYbnf3t3FWbrin4dCIatK6oZxAiX8TyMATa/TEpAAGCjJ0TTiLU2Vc/csxevrJmf740D3+FmcY0C0QiZu4WuUJp+0ZNWxlz12Kwwx9espfP1wQmIU1K0zH0viJTzmLXTvZLgZUEmBbPmCAAojLL4mN//LubNQJnaSnU4wg8zHFjVsAluAIg+bsg4AesgQtSe8isAbbdRWBmsEG3IAWso2RZzcGb4o7RXaHz7aLETwBKe0CwbgJZGZX2tQ/da0eWRtvltrcnjT3661f5SmYd5Fpi49EHD9reUUqsW+5wG+PWfnv+HZtWMCFdu3YXB4yk39aAJwUW2G49FKuOC2WzxN63Ue1vn/zALeBictcot6JouTMq7oTaFtnCJvgOoosLwT5+atnGxPaEUsXSte0ujuEuFFgiNS+XvnUtV3zDGaAA2rua01CTnmvbNxzsWHB75wv3v9f2LMRE5NP3LW8f2tFe2V0kAmOO9QTPVt3QmmY5EWm7xSKwW6U7PImL0pNZ8rfy/c3I37GoOg8cWEnlloHbGDa0lBJLRzzpr1s03yovVBbKjszEaJ/h+5TUcS2HheeWL2+z5J2Z1nRLEictSyrLKF35djdx0MQwaGrdXSRBT4Q6FXI+9wH1ncG8++w13VESgA2S7ri5kKHjZNV72jDqmoqoJxB1oyYCUoIY+N8ueHe4W0fGWU3A5rzgoIRncyDo7vTdoAnDtpr20Q+VfuZF11Jq/98UaMIYF5Sx4RqucUUdUJvXUw79LAyb9hqS7NXZl9vlfmKCE+Hj6vXL7uDyvlu3dAeWy7OpVdm6Zb7idJXWdgOrRQYNeO275kdVdWnU1kaJo7oylYWmjov1zD39p1/atcnaHcDtnHpx4x0789IfrM7XrQprbPe6zYprcZJfd1fyqb0Z2kth2NcX0fyUAkMxoIPCoZASce3tVffjZ35CctTdKGWQDWWSSvhQth7VFFyKGQq+9lw7ngSVWRMCL668H2WB3Sqd58R/4ZqsjDnvBE278I8wqGbnvPdf1GKQSGBC2GzLTyI1J5cIklXlrnRSAYXuZuyk+gYZEfEqEMnmZQaZJuSxznJXe37a+Py5EKb1s2WZ6fbV4dAjPclJMuEphkDTmKaIkKZIKeWt+Ty1PQTS24RebrFLFdRhXg8JyEglq7MM8GD8lLK1xp8XsHvyiW+us+ZIgHMeetObExGHBK7BTRLCTqQSmTkx2cQwqYUdYonknKyIY9h0JW7D6378jYfP7ArazJM/XPvgMC9f1wJbsFpbfX2SCKigQyLkZEqDEkZC6V/jtJMkvGGk9uZyvNUq/2HizYpET32tqk5gSotRm/388YcfKDN/PnW0fxoq+iCiFhbXTTt1wo2WycjZVl9trjjJqJd8ARF0OANb1ne8pDCgV+wufvKe7/3id/O1E8T88exjnz+0lGWvADwUqAIg1VKG72q3XFWprcX17qzzke4aEjpgAqSvObKnLwlUDX1/YzKLJ4796FdvbMFubXKrr9r9/rufPTwo4icG0T5F/yjy7WeHe1iIG94VLM7VlX6qCEgy8g9i1M9FXvzMJkhyFa5vMXiRS/D5qqueO/b4uX9p4naw/wDv1ZplvOGRpgAAAABJRU5ErkJggg==";

// node_modules/ethos-connect/dist/enums/Breakpoints.js
var m2;
(function(l9) {
  l9[l9.sm = 640] = "sm", l9[l9.md = 768] = "md", l9[l9.lg = 1024] = "lg", l9[l9.xl = 1280] = "xl", l9[l9["2xl"] = 1536] = "2xl";
})(m2 || (m2 = {}));

// node_modules/ethos-connect/dist/components/styled/signInModalStyles.js
var n = "#74777C";
var c = () => ({ fontSize: "18px", lineHeight: "24px", fontWeight: "600", marginLeft: "10px" });
var l = () => ({ color: "#6B7280", fontSize: "0.875rem", lineHeight: "1.25rem", padding: "24px", display: "flex", flexDirection: "column", gap: "12px" });
var g2 = (e16) => ({ visibility: e16 ? "" : "hidden", position: "relative", zIndex: "100" });
var f3 = (e16) => ({ position: "fixed", top: "0px", right: "0px", bottom: "0px", left: "0px", backgroundColor: "rgb(107 114 128)", opacity: e16 ? ".75" : "0", transition: "all 300ms ease-in-out" });
var m3 = () => ({ color: "#6D28D9" });
var C2 = (e16) => ({ position: "fixed", zIndex: "99", top: "0px", right: "0px", bottom: "0px", left: "0px", overflowY: "auto", opacity: e16 ? "1" : "0", scale: e16 ? "1" : ".95", transition: "all 300ms ease-in-out" });
var b = (e16) => {
  const t18 = { display: "flex", alignItems: "center", justifyContent: "center", minHeight: "100%", padding: "1rem", textAlign: "center" }, o18 = { padding: "0", alignItems: "center" };
  return e16 < m2.sm ? t18 : { ...t18, ...o18 };
};
var R = (e16) => {
  const t18 = { overflow: "hidden", position: "relative", backgroundColor: "#ffffff", transitionProperty: "all", borderRadius: "0.5rem", boxShadow: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)" }, o18 = { width: "360px" };
  return e16 < m2.sm ? t18 : { ...t18, ...o18 };
};
var y = () => ({ padding: "24px 24px 0px", display: "flex", flexDirection: "row", justifyContent: "space-between", alignItems: "center" });
var P = () => ({ width: "24px", height: "24px", color: "#A0AEBA", cursor: "pointer" });
var h = () => ({ color: n, cursor: "pointer", display: "flex", gap: "6px", alignItems: "center" });
var w = () => ({ fontSize: "16px", lineHeight: "24px" });
var F = (e16 = false) => ({ padding: e16 ? "24px 24px 32px" : "0 24px 32px", display: "flex", flexDirection: "column", justifyContent: "center", gap: "12px" });
var D = () => ({ display: "flex", justifyContent: "center", gap: "-6px" });
var k = () => ({ fontSize: "24px", fontWeight: "600", lineHeight: "32px", margin: "0" });
var I = () => ({ fontSize: "16px", fontWeight: "400", lineHeight: "24px", margin: "0", color: n });
var G = () => ({ padding: "0px 24px 24px", display: "flex", flexDirection: "row", gap: "12px", justifyContent: "space-between", alignItems: "center", color: n });
var _ = () => ({ height: "1px", width: "100%", background: "rgba(0, 0, 0, 0.12)", borderRadius: "16px" });
var q = () => ({ boxSizing: "border-box", border: "1px solid rgba(0, 0, 0, 0.08)", borderRadius: "16px", background: "#F2F2F2", padding: "20px", width: "100%" });
var X = (e16) => {
  const t18 = { padding: "0px 24px 24px", display: "flex", flexDirection: "column", alignItems: "center", gap: "12px" }, o18 = {};
  return e16 < m2.sm ? t18 : { ...t18, ...o18 };
};
var Y = (e16, t18 = false, o18 = false, i17 = false) => {
  const s9 = { textDecoration: "none", fontWeight: o18 ? "500" : "400", boxSizing: "border-box", display: "flex", flexDirection: "row", gap: "12px", justifyContent: i17 ? "center" : "space-between", alignItems: "center", padding: o18 ? "20px 20px" : "16px 16px 16px 20px", width: "100%", background: o18 ? "#6D28D9" : "#F2F2F2", color: o18 ? "white" : "black", opacity: t18 ? 0.5 : 1, cursor: t18 ? "not-allowed" : "pointer", borderRadius: "16px", flex: "none", order: "0", flexGrow: "0", boxShadow: "0px 1px 2px rgba(0, 0, 0, 0.05)", border: "none", fontSize: "inherit" }, a10 = {};
  return e16 < m2.sm ? s9 : { ...s9, ...a10 };
};
var J = () => ({ padding: "0px 24px 24px" });
var N = () => ({ display: "flex", justifyContent: "center", padding: "45px 0" });
var ee = () => ({ padding: "6px 0", color: "#666", width: "100%", fontSize: "smaller", marginBottom: "12px" });

// node_modules/ethos-connect/dist/lib/useHandleElementWithIdClicked.js
var import_react3 = __toESM(require_react(), 1);
function o(t18, n17) {
  (0, import_react3.useEffect)(() => {
    function e16(d15) {
      d15.target.id === t18 && n17();
    }
    return document.addEventListener("mousedown", e16), () => {
      document.removeEventListener("mousedown", e16);
    };
  }, []);
}

// node_modules/ethos-connect/dist/components/styled/EmailSent.js
var import_react7 = __toESM(require_react(), 1);

// node_modules/ethos-connect/dist/components/svg/EthosEnclosed.js
var import_react4 = __toESM(require_react(), 1);
var r2 = ({ width: t18 = 24, color: o18 = "#6D28D9" }) => import_react4.default.createElement("svg", { width: t18, height: t18, viewBox: "0 0 56 56", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react4.default.createElement("rect", { width: "56", height: "56", rx: "16", fill: o18 }), import_react4.default.createElement("path", { opacity: "0.8", d: "M17.9631 13H36.9268C37.7997 13 38.5073 13.7076 38.5073 14.5805V35.9802C38.5073 36.8531 37.7997 37.5607 36.9268 37.5607H17.9631C17.0902 37.5607 16.3826 36.8531 16.3826 35.9802V14.5805C16.3826 13.7076 17.0902 13 17.9631 13Z", stroke: "url(#paint0_linear_514_2169)", strokeOpacity: "0.9", strokeWidth: "0.790251" }), import_react4.default.createElement("path", { d: "M17.2471 14.0457L30.1651 20.0566C30.7225 20.316 31.0789 20.8749 31.0789 21.4896V42.6676C31.0789 43.8113 29.9018 44.5763 28.8566 44.112L15.9386 38.3725C15.3677 38.1189 14.9998 37.5528 14.9998 36.9281V15.4787C14.9998 14.3231 16.1994 13.5582 17.2471 14.0457Z", fill: "white", fillOpacity: "0.9" }), import_react4.default.createElement("path", { d: "M42.9117 27.9093C43.0029 27.4813 43.219 27.0901 43.5329 26.7851C43.8467 26.4801 44.2441 26.2753 44.6746 26.1965L45.8205 25.9872L44.6745 25.7779H44.6746C44.2441 25.6991 43.8467 25.4943 43.5329 25.1893C43.219 24.8843 43.0029 24.4931 42.9117 24.0651L42.6596 22.8774L42.4074 24.0651C42.3162 24.4931 42.1001 24.8843 41.7862 25.1893C41.4724 25.4943 41.075 25.6992 40.6445 25.7779L39.4985 25.9872L40.6446 26.1965H40.6445C41.075 26.2753 41.4724 26.4801 41.7861 26.7851C42.1 27.0901 42.3162 27.4813 42.4073 27.9093L42.6595 29.097L42.9117 27.9093Z", fill: "white", fillOpacity: "0.9" }), import_react4.default.createElement("defs", null, import_react4.default.createElement("linearGradient", { id: "paint0_linear_514_2169", x1: "38.5073", y1: "19.5371", x2: "27.4445", y2: "25.0685", gradientUnits: "userSpaceOnUse" }, import_react4.default.createElement("stop", { stopColor: "white" }), import_react4.default.createElement("stop", { offset: "1", stopColor: "white", stopOpacity: "0" }))));
var e2 = r2;

// node_modules/ethos-connect/dist/components/svg/Ethos.js
var import_react5 = __toESM(require_react(), 1);
var s = ({ width: o18 = 24, color: r17 = "#1e293b" }) => import_react5.default.createElement("svg", { width: o18, height: o18 * 65 / 47, viewBox: "0 0 47 65", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react5.default.createElement("path", { d: "M6.00471 1H40.0029C42.7644 1 45.0029 3.23858 45.0029 6V44.8425C45.0029 47.604 42.7643 49.8425 40.0029 49.8425H6.0047C3.24328 49.8425 1.0047 47.604 1.0047 44.8425V6C1.0047 3.23858 3.24329 1 6.00471 1Z", stroke: r17, strokeWidth: "2" }), import_react5.default.createElement("path", { d: "M6.68764 3.64648L30.6631 14.8026C32.0736 15.4589 32.9756 16.8735 32.9756 18.4292V58.6799C32.9756 61.5743 29.9966 63.5105 27.3515 62.3353L3.37601 51.683C1.93126 51.0411 1.00013 49.6085 1.00013 48.0276V7.27309C1.00013 4.34854 4.03609 2.41268 6.68764 3.64648Z", fill: r17 }));
var h2 = s;

// node_modules/ethos-connect/dist/components/styled/Header.js
var import_react6 = __toESM(require_react(), 1);
var y2 = ({ title: r17, subTitle: o18, dappIcon: t18, showEthos: i17 = false, children: d15 }) => import_react6.default.createElement("div", null, import_react6.default.createElement("div", { style: F(!!t18) }, import_react6.default.createElement("div", { style: D() }, t18 && (typeof t18 == "string" ? import_react6.default.createElement("img", { src: t18 }) : t18), i17 && import_react6.default.createElement(h2, null)), r17 && import_react6.default.createElement("div", { style: k() }, r17), o18 && import_react6.default.createElement("div", { style: I() }, o18)), d15);
var h3 = y2;

// node_modules/ethos-connect/dist/components/styled/EmailSent.js
var r3 = () => import_react7.default.createElement(h3, { title: "Ethos sent you an email", dappIcon: import_react7.default.createElement(e2, { width: 60 }) }, import_react7.default.createElement("div", { style: l() }, import_react7.default.createElement("p", null, "An email has been sent to you with a link to login."), import_react7.default.createElement("p", null, "If you don't receive it, please check your spam folder or contact us at:"), import_react7.default.createElement("p", null, "support@ethoswallet.xyz")));
var p = r3;

// node_modules/ethos-connect/dist/components/styled/Wallets.js
var import_react9 = __toESM(require_react(), 1);

// node_modules/ethos-connect/dist/components/styled/IconButton.js
var import_react8 = __toESM(require_react(), 1);
var c2 = (o18) => {
  const { text: n17, icon: t18, width: r17, disabled: i17, primary: s9, type: d15, ...u5 } = o18;
  return import_react8.default.createElement("button", { style: Y(r17, i17, s9, !t18), ...u5, type: d15 }, import_react8.default.createElement("div", null, n17), t18);
};
var m4 = c2;

// node_modules/ethos-connect/dist/components/styled/Wallets.js
var c3 = ({ wallets: i17, selectWallet: l9, width: o18 }) => {
  const s9 = (0, import_react9.useCallback)((t18) => {
    if (!l9)
      return;
    let e16 = t18.target, a10;
    for (; !a10 && e16.parentNode; )
      a10 = e16.dataset.name, e16 = e16.parentNode;
    l9(a10);
  }, []), m12 = (0, import_react9.useCallback)((t18) => import_react9.default.createElement("img", { src: t18.icon, height: 32, width: 32 }), []);
  return import_react9.default.createElement("div", { role: "wallet-sign-in" }, import_react9.default.createElement("div", { style: X(o18) }, i17 == null ? void 0 : i17.map((t18, e16) => import_react9.default.createElement(m4, { key: `select-wallet-${e16}`, icon: m12(t18), "data-name": t18.name, text: t18.name, onClick: s9, width: o18 }))));
};
var f4 = c3;

// node_modules/ethos-connect/dist/components/styled/Email.js
var import_react10 = __toESM(require_react(), 1);

// node_modules/ethos-connect/dist/lib/getConfiguration.js
var import_store2 = __toESM(require_store2(), 1);
var t2 = () => import_store2.default.namespace("ethos")("configuration") || {};
var a2 = t2;

// node_modules/ethos-connect/dist/lib/postIFrameMessage.js
var import_store24 = __toESM(require_store2(), 1);

// node_modules/ethos-connect/dist/lib/getIframe.js
var import_store23 = __toESM(require_store2(), 1);

// node_modules/ethos-connect/dist/lib/log.js
var import_store22 = __toESM(require_store2(), 1);
var g3 = (o18) => {
  const l9 = import_store22.default.namespace("log"), e16 = l9("allowed") || [];
  if (!e16.includes(o18))
    return l9("allowed", [...e16, o18]), `Logging enabled for ${o18}. Call ethos.clearAllowLog() to turn off this logging.`;
};
var r5 = () => {
  import_store22.default.namespace("log")("allowed", []);
};
var s2 = (o18, ...l9) => {
  const n17 = import_store22.default.namespace("log")("allowed");
  !n17 || !(n17.includes(o18) || n17.includes("all")) || console.log(o18, ...l9);
};
typeof window != "undefined" && (window.ethos = { allowLog: g3, clearAllowLog: r5 });
var c4 = s2;

// node_modules/ethos-connect/dist/lib/getIframe.js
var I2 = (p12) => {
  const { apiKey: l9, walletAppUrl: a10 } = a2();
  if (c4("getIframe", "getIframe", l9, a10), !l9 || !a10)
    return;
  const f11 = "ethos-wallet-iframe";
  let c11 = 0, e16 = document.getElementById(f11);
  const d15 = () => {
    !e16 || (e16.style.width = "1px", e16.style.height = "1px");
  }, s9 = new URLSearchParams(window.location.search), i17 = s9.get("access_token"), m12 = s9.get("refresh_token");
  let r17 = a10 + `/wallet?apiKey=${l9}`;
  if (i17 && m12) {
    r17 += `&access_token=${i17}&refresh_token=${m12}`, s9.delete("access_token"), s9.delete("refresh_token");
    let t18 = location.protocol + "//" + location.host + location.pathname;
    s9.toString().length > 0 && (t18 += "?" + s9.toString()), import_store23.default.namespace("auth")("access_token", i17), import_store23.default.namespace("auth")("refresh_token", m12), window.history.pushState({}, "", t18);
  } else {
    const t18 = import_store23.default.namespace("auth")("access_token"), n17 = import_store23.default.namespace("auth")("refresh_token");
    t18 && n17 && (r17 += `&access_token=${t18}&refresh_token=${n17}`);
  }
  return e16 || (c4("getIframe", "Load Iframe", r17), e16 = document.createElement("IFRAME"), e16.src = r17, e16.id = f11, e16.style.border = "none", e16.style.position = "absolute", e16.style.top = c11 - 1 + "px", e16.style.right = "60px", e16.style.width = "1px", e16.style.height = "1px", e16.style.zIndex = "99", e16.style.backgroundColor = "transparent", e16.setAttribute("allow", "payment; clipboard-read; clipboard-write"), document.body.appendChild(e16), window.addEventListener("message", (t18) => {
    if (t18.origin === a10) {
      const { action: n17 } = t18.data;
      switch (n17) {
        case "close":
          d15();
          break;
        case "ready":
          e16.setAttribute("readyToReceiveMessages", "true");
          const h7 = import_store23.default.namespace("iframeMessages"), u5 = h7("messages") || [];
          for (const y6 of u5)
            p2(y6);
          h7("messages", null);
          break;
      }
    }
  }), window.addEventListener("scroll", () => {
    c11 = window.scrollY, e16.style.top = c11 + "px";
  })), p12 ? (e16.style.width = "360px", e16.style.height = "600px") : p12 !== void 0 && d15(), e16;
};
var M = I2;

// node_modules/ethos-connect/dist/lib/postIFrameMessage.js
var i3 = (e16) => {
  var _a;
  const s9 = M();
  if (!(s9 == null ? void 0 : s9.getAttribute("readyToReceiveMessages"))) {
    const t18 = import_store24.default.namespace("iframeMessages"), o18 = t18("messages") || [], r17 = t18("messages", [...o18, e16]);
    c4("iframe", "Storing iframe message", r17);
    return;
  }
  (_a = s9 == null ? void 0 : s9.contentWindow) == null ? void 0 : _a.postMessage(e16, "*");
};
var p2 = i3;

// node_modules/ethos-connect/dist/lib/event.js
var a4 = async (e16) => {
  p2({ action: "event", data: e16 });
};
var n3 = a4;

// node_modules/ethos-connect/dist/lib/login.js
var import_store28 = __toESM(require_store2(), 1);

// node_modules/bignumber.js/bignumber.mjs
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P4 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v7, b5) {
    var alphabet2, c11, caseChanged, e16, i17, isNum2, len, str, x5 = this;
    if (!(x5 instanceof BigNumber2))
      return new BigNumber2(v7, b5);
    if (b5 == null) {
      if (v7 && v7._isBigNumber === true) {
        x5.s = v7.s;
        if (!v7.c || v7.e > MAX_EXP) {
          x5.c = x5.e = null;
        } else if (v7.e < MIN_EXP) {
          x5.c = [x5.e = 0];
        } else {
          x5.e = v7.e;
          x5.c = v7.c.slice();
        }
        return;
      }
      if ((isNum2 = typeof v7 == "number") && v7 * 0 == 0) {
        x5.s = 1 / v7 < 0 ? (v7 = -v7, -1) : 1;
        if (v7 === ~~v7) {
          for (e16 = 0, i17 = v7; i17 >= 10; i17 /= 10, e16++)
            ;
          if (e16 > MAX_EXP) {
            x5.c = x5.e = null;
          } else {
            x5.e = e16;
            x5.c = [v7];
          }
          return;
        }
        str = String(v7);
      } else {
        if (!isNumeric.test(str = String(v7)))
          return parseNumeric(x5, str, isNum2);
        x5.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e16 = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i17 = str.search(/e/i)) > 0) {
        if (e16 < 0)
          e16 = i17;
        e16 += +str.slice(i17 + 1);
        str = str.substring(0, i17);
      } else if (e16 < 0) {
        e16 = str.length;
      }
    } else {
      intCheck(b5, 2, ALPHABET.length, "Base");
      if (b5 == 10 && alphabetHasNormalDecimalDigits) {
        x5 = new BigNumber2(v7);
        return round(x5, DECIMAL_PLACES + x5.e + 1, ROUNDING_MODE);
      }
      str = String(v7);
      if (isNum2 = typeof v7 == "number") {
        if (v7 * 0 != 0)
          return parseNumeric(x5, str, isNum2, b5);
        x5.s = 1 / v7 < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v7);
        }
      } else {
        x5.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet2 = ALPHABET.slice(0, b5);
      e16 = i17 = 0;
      for (len = str.length; i17 < len; i17++) {
        if (alphabet2.indexOf(c11 = str.charAt(i17)) < 0) {
          if (c11 == ".") {
            if (i17 > e16) {
              e16 = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i17 = -1;
              e16 = 0;
              continue;
            }
          }
          return parseNumeric(x5, String(v7), isNum2, b5);
        }
      }
      isNum2 = false;
      str = convertBase(str, b5, 10, x5.s);
      if ((e16 = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      else
        e16 = str.length;
    }
    for (i17 = 0; str.charCodeAt(i17) === 48; i17++)
      ;
    for (len = str.length; str.charCodeAt(--len) === 48; )
      ;
    if (str = str.slice(i17, ++len)) {
      len -= i17;
      if (isNum2 && BigNumber2.DEBUG && len > 15 && (v7 > MAX_SAFE_INTEGER || v7 !== mathfloor(v7))) {
        throw Error(tooManyDigits + x5.s * v7);
      }
      if ((e16 = e16 - i17 - 1) > MAX_EXP) {
        x5.c = x5.e = null;
      } else if (e16 < MIN_EXP) {
        x5.c = [x5.e = 0];
      } else {
        x5.e = e16;
        x5.c = [];
        i17 = (e16 + 1) % LOG_BASE;
        if (e16 < 0)
          i17 += LOG_BASE;
        if (i17 < len) {
          if (i17)
            x5.c.push(+str.slice(0, i17));
          for (len -= LOG_BASE; i17 < len; ) {
            x5.c.push(+str.slice(i17, i17 += LOG_BASE));
          }
          i17 = LOG_BASE - (str = str.slice(i17)).length;
        } else {
          i17 -= len;
        }
        for (; i17--; str += "0")
          ;
        x5.c.push(+str);
      }
    } else {
      x5.c = [x5.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p12, v7;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p12 = "DECIMAL_PLACES")) {
          v7 = obj[p12];
          intCheck(v7, 0, MAX, p12);
          DECIMAL_PLACES = v7;
        }
        if (obj.hasOwnProperty(p12 = "ROUNDING_MODE")) {
          v7 = obj[p12];
          intCheck(v7, 0, 8, p12);
          ROUNDING_MODE = v7;
        }
        if (obj.hasOwnProperty(p12 = "EXPONENTIAL_AT")) {
          v7 = obj[p12];
          if (v7 && v7.pop) {
            intCheck(v7[0], -MAX, 0, p12);
            intCheck(v7[1], 0, MAX, p12);
            TO_EXP_NEG = v7[0];
            TO_EXP_POS = v7[1];
          } else {
            intCheck(v7, -MAX, MAX, p12);
            TO_EXP_NEG = -(TO_EXP_POS = v7 < 0 ? -v7 : v7);
          }
        }
        if (obj.hasOwnProperty(p12 = "RANGE")) {
          v7 = obj[p12];
          if (v7 && v7.pop) {
            intCheck(v7[0], -MAX, -1, p12);
            intCheck(v7[1], 1, MAX, p12);
            MIN_EXP = v7[0];
            MAX_EXP = v7[1];
          } else {
            intCheck(v7, -MAX, MAX, p12);
            if (v7) {
              MIN_EXP = -(MAX_EXP = v7 < 0 ? -v7 : v7);
            } else {
              throw Error(bignumberError + p12 + " cannot be zero: " + v7);
            }
          }
        }
        if (obj.hasOwnProperty(p12 = "CRYPTO")) {
          v7 = obj[p12];
          if (v7 === !!v7) {
            if (v7) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v7;
              } else {
                CRYPTO = !v7;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v7;
            }
          } else {
            throw Error(bignumberError + p12 + " not true or false: " + v7);
          }
        }
        if (obj.hasOwnProperty(p12 = "MODULO_MODE")) {
          v7 = obj[p12];
          intCheck(v7, 0, 9, p12);
          MODULO_MODE = v7;
        }
        if (obj.hasOwnProperty(p12 = "POW_PRECISION")) {
          v7 = obj[p12];
          intCheck(v7, 0, MAX, p12);
          POW_PRECISION = v7;
        }
        if (obj.hasOwnProperty(p12 = "FORMAT")) {
          v7 = obj[p12];
          if (typeof v7 == "object")
            FORMAT = v7;
          else
            throw Error(bignumberError + p12 + " not an object: " + v7);
        }
        if (obj.hasOwnProperty(p12 = "ALPHABET")) {
          v7 = obj[p12];
          if (typeof v7 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v7)) {
            alphabetHasNormalDecimalDigits = v7.slice(0, 10) == "0123456789";
            ALPHABET = v7;
          } else {
            throw Error(bignumberError + p12 + " invalid: " + v7);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber2.isBigNumber = function(v7) {
    if (!v7 || v7._isBigNumber !== true)
      return false;
    if (!BigNumber2.DEBUG)
      return true;
    var i17, n17, c11 = v7.c, e16 = v7.e, s9 = v7.s;
    out:
      if ({}.toString.call(c11) == "[object Array]") {
        if ((s9 === 1 || s9 === -1) && e16 >= -MAX && e16 <= MAX && e16 === mathfloor(e16)) {
          if (c11[0] === 0) {
            if (e16 === 0 && c11.length === 1)
              return true;
            break out;
          }
          i17 = (e16 + 1) % LOG_BASE;
          if (i17 < 1)
            i17 += LOG_BASE;
          if (String(c11[0]).length == i17) {
            for (i17 = 0; i17 < c11.length; i17++) {
              n17 = c11[i17];
              if (n17 < 0 || n17 >= BASE || n17 !== mathfloor(n17))
                break out;
            }
            if (n17 !== 0)
              return true;
          }
        }
      } else if (c11 === null && e16 === null && (s9 === null || s9 === 1 || s9 === -1)) {
        return true;
      }
    throw Error(bignumberError + "Invalid BigNumber: " + v7);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, P4.lt);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, P4.gt);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a10, b5, e16, k4, v7, i17 = 0, c11 = [], rand = new BigNumber2(ONE);
      if (dp == null)
        dp = DECIMAL_PLACES;
      else
        intCheck(dp, 0, MAX);
      k4 = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a10 = crypto.getRandomValues(new Uint32Array(k4 *= 2));
          for (; i17 < k4; ) {
            v7 = a10[i17] * 131072 + (a10[i17 + 1] >>> 11);
            if (v7 >= 9e15) {
              b5 = crypto.getRandomValues(new Uint32Array(2));
              a10[i17] = b5[0];
              a10[i17 + 1] = b5[1];
            } else {
              c11.push(v7 % 1e14);
              i17 += 2;
            }
          }
          i17 = k4 / 2;
        } else if (crypto.randomBytes) {
          a10 = crypto.randomBytes(k4 *= 7);
          for (; i17 < k4; ) {
            v7 = (a10[i17] & 31) * 281474976710656 + a10[i17 + 1] * 1099511627776 + a10[i17 + 2] * 4294967296 + a10[i17 + 3] * 16777216 + (a10[i17 + 4] << 16) + (a10[i17 + 5] << 8) + a10[i17 + 6];
            if (v7 >= 9e15) {
              crypto.randomBytes(7).copy(a10, i17);
            } else {
              c11.push(v7 % 1e14);
              i17 += 7;
            }
          }
          i17 = k4 / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i17 < k4; ) {
          v7 = random53bitInt();
          if (v7 < 9e15)
            c11[i17++] = v7 % 1e14;
        }
      }
      k4 = c11[--i17];
      dp %= LOG_BASE;
      if (k4 && dp) {
        v7 = POWS_TEN[LOG_BASE - dp];
        c11[i17] = mathfloor(k4 / v7) * v7;
      }
      for (; c11[i17] === 0; c11.pop(), i17--)
        ;
      if (i17 < 0) {
        c11 = [e16 = 0];
      } else {
        for (e16 = -1; c11[0] === 0; c11.splice(0, 1), e16 -= LOG_BASE)
          ;
        for (i17 = 1, v7 = c11[0]; v7 >= 10; v7 /= 10, i17++)
          ;
        if (i17 < LOG_BASE)
          e16 -= LOG_BASE - i17;
      }
      rand.e = e16;
      rand.c = c11;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i17 = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i17 < args.length; )
      sum = sum.plus(args[i17++]);
    return sum;
  };
  convertBase = function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet2) {
      var j2, arr = [0], arrL, i17 = 0, len = str.length;
      for (; i17 < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
          ;
        arr[0] += alphabet2.indexOf(str.charAt(i17++));
        for (j2 = 0; j2 < arr.length; j2++) {
          if (arr[j2] > baseOut - 1) {
            if (arr[j2 + 1] == null)
              arr[j2 + 1] = 0;
            arr[j2 + 1] += arr[j2] / baseOut | 0;
            arr[j2] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet2, d15, e16, k4, r17, x5, xc, y6, i17 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i17 >= 0) {
        k4 = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y6 = new BigNumber2(baseIn);
        x5 = y6.pow(str.length - i17);
        POW_PRECISION = k4;
        y6.c = toBaseOut(
          toFixedPoint(coeffToString(x5.c), x5.e, "0"),
          10,
          baseOut,
          decimal
        );
        y6.e = y6.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet2 = ALPHABET, decimal) : (alphabet2 = decimal, ALPHABET));
      e16 = k4 = xc.length;
      for (; xc[--k4] == 0; xc.pop())
        ;
      if (!xc[0])
        return alphabet2.charAt(0);
      if (i17 < 0) {
        --e16;
      } else {
        x5.c = xc;
        x5.e = e16;
        x5.s = sign;
        x5 = div(x5, y6, dp, rm, baseOut);
        xc = x5.c;
        r17 = x5.r;
        e16 = x5.e;
      }
      d15 = e16 + dp + 1;
      i17 = xc[d15];
      k4 = baseOut / 2;
      r17 = r17 || d15 < 0 || xc[d15 + 1] != null;
      r17 = rm < 4 ? (i17 != null || r17) && (rm == 0 || rm == (x5.s < 0 ? 3 : 2)) : i17 > k4 || i17 == k4 && (rm == 4 || r17 || rm == 6 && xc[d15 - 1] & 1 || rm == (x5.s < 0 ? 8 : 7));
      if (d15 < 1 || !xc[0]) {
        str = r17 ? toFixedPoint(alphabet2.charAt(1), -dp, alphabet2.charAt(0)) : alphabet2.charAt(0);
      } else {
        xc.length = d15;
        if (r17) {
          for (--baseOut; ++xc[--d15] > baseOut; ) {
            xc[d15] = 0;
            if (!d15) {
              ++e16;
              xc = [1].concat(xc);
            }
          }
        }
        for (k4 = xc.length; !xc[--k4]; )
          ;
        for (i17 = 0, str = ""; i17 <= k4; str += alphabet2.charAt(xc[i17++]))
          ;
        str = toFixedPoint(str, e16, alphabet2.charAt(0));
      }
      return str;
    };
  }();
  div = function() {
    function multiply(x5, k4, base) {
      var m12, temp, xlo, xhi, carry = 0, i17 = x5.length, klo = k4 % SQRT_BASE, khi = k4 / SQRT_BASE | 0;
      for (x5 = x5.slice(); i17--; ) {
        xlo = x5[i17] % SQRT_BASE;
        xhi = x5[i17] / SQRT_BASE | 0;
        m12 = khi * xlo + xhi * klo;
        temp = klo * xlo + m12 % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m12 / SQRT_BASE | 0) + khi * xhi;
        x5[i17] = temp % base;
      }
      if (carry)
        x5 = [carry].concat(x5);
      return x5;
    }
    function compare2(a10, b5, aL, bL) {
      var i17, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i17 = cmp = 0; i17 < aL; i17++) {
          if (a10[i17] != b5[i17]) {
            cmp = a10[i17] > b5[i17] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a10, b5, aL, base) {
      var i17 = 0;
      for (; aL--; ) {
        a10[aL] -= i17;
        i17 = a10[aL] < b5[aL] ? 1 : 0;
        a10[aL] = i17 * base + a10[aL] - b5[aL];
      }
      for (; !a10[0] && a10.length > 1; a10.splice(0, 1))
        ;
    }
    return function(x5, y6, dp, rm, base) {
      var cmp, e16, i17, more, n17, prod, prodL, q2, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s9 = x5.s == y6.s ? 1 : -1, xc = x5.c, yc = y6.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x5.s || !y6.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s9 * 0 : s9 / 0
          )
        );
      }
      q2 = new BigNumber2(s9);
      qc = q2.c = [];
      e16 = x5.e - y6.e;
      s9 = dp + e16 + 1;
      if (!base) {
        base = BASE;
        e16 = bitFloor(x5.e / LOG_BASE) - bitFloor(y6.e / LOG_BASE);
        s9 = s9 / LOG_BASE | 0;
      }
      for (i17 = 0; yc[i17] == (xc[i17] || 0); i17++)
        ;
      if (yc[i17] > (xc[i17] || 0))
        e16--;
      if (s9 < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i17 = 0;
        s9 += 2;
        n17 = mathfloor(base / (yc[0] + 1));
        if (n17 > 1) {
          yc = multiply(yc, n17, base);
          xc = multiply(xc, n17, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0)
          ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2)
          yc0++;
        do {
          n17 = 0;
          cmp = compare2(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            n17 = mathfloor(rem0 / yc0);
            if (n17 > 1) {
              if (n17 >= base)
                n17 = base - 1;
              prod = multiply(yc, n17, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n17--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n17 == 0) {
                cmp = n17 = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL)
              prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc, rem, yL, remL) < 1) {
                n17++;
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n17++;
            rem = [0];
          }
          qc[i17++] = n17;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s9--);
        more = rem[0] != null;
        if (!qc[0])
          qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i17 = 1, s9 = qc[0]; s9 >= 10; s9 /= 10, i17++)
          ;
        round(q2, dp + (q2.e = i17 + e16 * LOG_BASE - 1) + 1, rm, more);
      } else {
        q2.e = e16;
        q2.r = +more;
      }
      return q2;
    };
  }();
  function format(n17, i17, rm, id) {
    var c0, e16, ne, len, str;
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    if (!n17.c)
      return n17.toString();
    c0 = n17.c[0];
    ne = n17.e;
    if (i17 == null) {
      str = coeffToString(n17.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n17 = round(new BigNumber2(n17), i17, rm);
      e16 = n17.e;
      str = coeffToString(n17.c);
      len = str.length;
      if (id == 1 || id == 2 && (i17 <= e16 || e16 <= TO_EXP_NEG)) {
        for (; len < i17; str += "0", len++)
          ;
        str = toExponential(str, e16);
      } else {
        i17 -= ne;
        str = toFixedPoint(str, e16, "0");
        if (e16 + 1 > len) {
          if (--i17 > 0)
            for (str += "."; i17--; str += "0")
              ;
        } else {
          i17 += e16 - len;
          if (i17 > 0) {
            if (e16 + 1 == len)
              str += ".";
            for (; i17--; str += "0")
              ;
          }
        }
      }
    }
    return n17.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, method) {
    var n17, i17 = 1, m12 = new BigNumber2(args[0]);
    for (; i17 < args.length; i17++) {
      n17 = new BigNumber2(args[i17]);
      if (!n17.s) {
        m12 = n17;
        break;
      } else if (method.call(m12, n17)) {
        m12 = n17;
      }
    }
    return m12;
  }
  function normalise(n17, c11, e16) {
    var i17 = 1, j2 = c11.length;
    for (; !c11[--j2]; c11.pop())
      ;
    for (j2 = c11[0]; j2 >= 10; j2 /= 10, i17++)
      ;
    if ((e16 = i17 + e16 * LOG_BASE - 1) > MAX_EXP) {
      n17.c = n17.e = null;
    } else if (e16 < MIN_EXP) {
      n17.c = [n17.e = 0];
    } else {
      n17.e = e16;
      n17.c = c11;
    }
    return n17;
  }
  parseNumeric = function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x5, str, isNum2, b5) {
      var base, s9 = isNum2 ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s9)) {
        x5.s = isNaN(s9) ? null : s9 < 0 ? -1 : 1;
      } else {
        if (!isNum2) {
          s9 = s9.replace(basePrefix, function(m12, p1, p22) {
            base = (p22 = p22.toLowerCase()) == "x" ? 16 : p22 == "b" ? 2 : 8;
            return !b5 || b5 == base ? p1 : m12;
          });
          if (b5) {
            base = b5;
            s9 = s9.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s9)
            return new BigNumber2(s9, base);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b5 ? " base " + b5 : "") + " number: " + str);
        }
        x5.s = null;
      }
      x5.c = x5.e = null;
    };
  }();
  function round(x5, sd, rm, r17) {
    var d15, i17, j2, k4, n17, ni, rd, xc = x5.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d15 = 1, k4 = xc[0]; k4 >= 10; k4 /= 10, d15++)
          ;
        i17 = sd - d15;
        if (i17 < 0) {
          i17 += LOG_BASE;
          j2 = sd;
          n17 = xc[ni = 0];
          rd = n17 / pows10[d15 - j2 - 1] % 10 | 0;
        } else {
          ni = mathceil((i17 + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r17) {
              for (; xc.length <= ni; xc.push(0))
                ;
              n17 = rd = 0;
              d15 = 1;
              i17 %= LOG_BASE;
              j2 = i17 - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n17 = k4 = xc[ni];
            for (d15 = 1; k4 >= 10; k4 /= 10, d15++)
              ;
            i17 %= LOG_BASE;
            j2 = i17 - LOG_BASE + d15;
            rd = j2 < 0 ? 0 : n17 / pows10[d15 - j2 - 1] % 10 | 0;
          }
        }
        r17 = r17 || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j2 < 0 ? n17 : n17 % pows10[d15 - j2 - 1]);
        r17 = rm < 4 ? (rd || r17) && (rm == 0 || rm == (x5.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r17 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i17 > 0 ? j2 > 0 ? n17 / pows10[d15 - j2] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x5.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r17) {
            sd -= x5.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x5.e = -sd || 0;
          } else {
            xc[0] = x5.e = 0;
          }
          return x5;
        }
        if (i17 == 0) {
          xc.length = ni;
          k4 = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k4 = pows10[LOG_BASE - i17];
          xc[ni] = j2 > 0 ? mathfloor(n17 / pows10[d15 - j2] % pows10[j2]) * k4 : 0;
        }
        if (r17) {
          for (; ; ) {
            if (ni == 0) {
              for (i17 = 1, j2 = xc[0]; j2 >= 10; j2 /= 10, i17++)
                ;
              j2 = xc[0] += k4;
              for (k4 = 1; j2 >= 10; j2 /= 10, k4++)
                ;
              if (i17 != k4) {
                x5.e++;
                if (xc[0] == BASE)
                  xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k4;
              if (xc[ni] != BASE)
                break;
              xc[ni--] = 0;
              k4 = 1;
            }
          }
        }
        for (i17 = xc.length; xc[--i17] === 0; xc.pop())
          ;
      }
      if (x5.e > MAX_EXP) {
        x5.c = x5.e = null;
      } else if (x5.e < MIN_EXP) {
        x5.c = [x5.e = 0];
      }
    }
    return x5;
  }
  function valueOf(n17) {
    var str, e16 = n17.e;
    if (e16 === null)
      return n17.toString();
    str = coeffToString(n17.c);
    str = e16 <= TO_EXP_NEG || e16 >= TO_EXP_POS ? toExponential(str, e16) : toFixedPoint(str, e16, "0");
    return n17.s < 0 ? "-" + str : str;
  }
  P4.absoluteValue = P4.abs = function() {
    var x5 = new BigNumber2(this);
    if (x5.s < 0)
      x5.s = 1;
    return x5;
  };
  P4.comparedTo = function(y6, b5) {
    return compare(this, new BigNumber2(y6, b5));
  };
  P4.decimalPlaces = P4.dp = function(dp, rm) {
    var c11, n17, v7, x5 = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x5), dp + x5.e + 1, rm);
    }
    if (!(c11 = x5.c))
      return null;
    n17 = ((v7 = c11.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v7 = c11[v7])
      for (; v7 % 10 == 0; v7 /= 10, n17--)
        ;
    if (n17 < 0)
      n17 = 0;
    return n17;
  };
  P4.dividedBy = P4.div = function(y6, b5) {
    return div(this, new BigNumber2(y6, b5), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P4.dividedToIntegerBy = P4.idiv = function(y6, b5) {
    return div(this, new BigNumber2(y6, b5), 0, 1);
  };
  P4.exponentiatedBy = P4.pow = function(n17, m12) {
    var half, isModExp, i17, k4, more, nIsBig, nIsNeg, nIsOdd, y6, x5 = this;
    n17 = new BigNumber2(n17);
    if (n17.c && !n17.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n17));
    }
    if (m12 != null)
      m12 = new BigNumber2(m12);
    nIsBig = n17.e > 14;
    if (!x5.c || !x5.c[0] || x5.c[0] == 1 && !x5.e && x5.c.length == 1 || !n17.c || !n17.c[0]) {
      y6 = new BigNumber2(Math.pow(+valueOf(x5), nIsBig ? n17.s * (2 - isOdd(n17)) : +valueOf(n17)));
      return m12 ? y6.mod(m12) : y6;
    }
    nIsNeg = n17.s < 0;
    if (m12) {
      if (m12.c ? !m12.c[0] : !m12.s)
        return new BigNumber2(NaN);
      isModExp = !nIsNeg && x5.isInteger() && m12.isInteger();
      if (isModExp)
        x5 = x5.mod(m12);
    } else if (n17.e > 9 && (x5.e > 0 || x5.e < -1 || (x5.e == 0 ? x5.c[0] > 1 || nIsBig && x5.c[1] >= 24e7 : x5.c[0] < 8e13 || nIsBig && x5.c[0] <= 9999975e7))) {
      k4 = x5.s < 0 && isOdd(n17) ? -0 : 0;
      if (x5.e > -1)
        k4 = 1 / k4;
      return new BigNumber2(nIsNeg ? 1 / k4 : k4);
    } else if (POW_PRECISION) {
      k4 = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg)
        n17.s = 1;
      nIsOdd = isOdd(n17);
    } else {
      i17 = Math.abs(+valueOf(n17));
      nIsOdd = i17 % 2;
    }
    y6 = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y6 = y6.times(x5);
        if (!y6.c)
          break;
        if (k4) {
          if (y6.c.length > k4)
            y6.c.length = k4;
        } else if (isModExp) {
          y6 = y6.mod(m12);
        }
      }
      if (i17) {
        i17 = mathfloor(i17 / 2);
        if (i17 === 0)
          break;
        nIsOdd = i17 % 2;
      } else {
        n17 = n17.times(half);
        round(n17, n17.e + 1, 1);
        if (n17.e > 14) {
          nIsOdd = isOdd(n17);
        } else {
          i17 = +valueOf(n17);
          if (i17 === 0)
            break;
          nIsOdd = i17 % 2;
        }
      }
      x5 = x5.times(x5);
      if (k4) {
        if (x5.c && x5.c.length > k4)
          x5.c.length = k4;
      } else if (isModExp) {
        x5 = x5.mod(m12);
      }
    }
    if (isModExp)
      return y6;
    if (nIsNeg)
      y6 = ONE.div(y6);
    return m12 ? y6.mod(m12) : k4 ? round(y6, POW_PRECISION, ROUNDING_MODE, more) : y6;
  };
  P4.integerValue = function(rm) {
    var n17 = new BigNumber2(this);
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    return round(n17, n17.e + 1, rm);
  };
  P4.isEqualTo = P4.eq = function(y6, b5) {
    return compare(this, new BigNumber2(y6, b5)) === 0;
  };
  P4.isFinite = function() {
    return !!this.c;
  };
  P4.isGreaterThan = P4.gt = function(y6, b5) {
    return compare(this, new BigNumber2(y6, b5)) > 0;
  };
  P4.isGreaterThanOrEqualTo = P4.gte = function(y6, b5) {
    return (b5 = compare(this, new BigNumber2(y6, b5))) === 1 || b5 === 0;
  };
  P4.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P4.isLessThan = P4.lt = function(y6, b5) {
    return compare(this, new BigNumber2(y6, b5)) < 0;
  };
  P4.isLessThanOrEqualTo = P4.lte = function(y6, b5) {
    return (b5 = compare(this, new BigNumber2(y6, b5))) === -1 || b5 === 0;
  };
  P4.isNaN = function() {
    return !this.s;
  };
  P4.isNegative = function() {
    return this.s < 0;
  };
  P4.isPositive = function() {
    return this.s > 0;
  };
  P4.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P4.minus = function(y6, b5) {
    var i17, j2, t18, xLTy, x5 = this, a10 = x5.s;
    y6 = new BigNumber2(y6, b5);
    b5 = y6.s;
    if (!a10 || !b5)
      return new BigNumber2(NaN);
    if (a10 != b5) {
      y6.s = -b5;
      return x5.plus(y6);
    }
    var xe = x5.e / LOG_BASE, ye = y6.e / LOG_BASE, xc = x5.c, yc = y6.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return xc ? (y6.s = -b5, y6) : new BigNumber2(yc ? x5 : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y6.s = -b5, y6) : new BigNumber2(xc[0] ? x5 : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a10 = xe - ye) {
      if (xLTy = a10 < 0) {
        a10 = -a10;
        t18 = xc;
      } else {
        ye = xe;
        t18 = yc;
      }
      t18.reverse();
      for (b5 = a10; b5--; t18.push(0))
        ;
      t18.reverse();
    } else {
      j2 = (xLTy = (a10 = xc.length) < (b5 = yc.length)) ? a10 : b5;
      for (a10 = b5 = 0; b5 < j2; b5++) {
        if (xc[b5] != yc[b5]) {
          xLTy = xc[b5] < yc[b5];
          break;
        }
      }
    }
    if (xLTy)
      t18 = xc, xc = yc, yc = t18, y6.s = -y6.s;
    b5 = (j2 = yc.length) - (i17 = xc.length);
    if (b5 > 0)
      for (; b5--; xc[i17++] = 0)
        ;
    b5 = BASE - 1;
    for (; j2 > a10; ) {
      if (xc[--j2] < yc[j2]) {
        for (i17 = j2; i17 && !xc[--i17]; xc[i17] = b5)
          ;
        --xc[i17];
        xc[j2] += BASE;
      }
      xc[j2] -= yc[j2];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye)
      ;
    if (!xc[0]) {
      y6.s = ROUNDING_MODE == 3 ? -1 : 1;
      y6.c = [y6.e = 0];
      return y6;
    }
    return normalise(y6, xc, ye);
  };
  P4.modulo = P4.mod = function(y6, b5) {
    var q2, s9, x5 = this;
    y6 = new BigNumber2(y6, b5);
    if (!x5.c || !y6.s || y6.c && !y6.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y6.c || x5.c && !x5.c[0]) {
      return new BigNumber2(x5);
    }
    if (MODULO_MODE == 9) {
      s9 = y6.s;
      y6.s = 1;
      q2 = div(x5, y6, 0, 3);
      y6.s = s9;
      q2.s *= s9;
    } else {
      q2 = div(x5, y6, 0, MODULO_MODE);
    }
    y6 = x5.minus(q2.times(y6));
    if (!y6.c[0] && MODULO_MODE == 1)
      y6.s = x5.s;
    return y6;
  };
  P4.multipliedBy = P4.times = function(y6, b5) {
    var c11, e16, i17, j2, k4, m12, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x5 = this, xc = x5.c, yc = (y6 = new BigNumber2(y6, b5)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x5.s || !y6.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y6.c = y6.e = y6.s = null;
      } else {
        y6.s *= x5.s;
        if (!xc || !yc) {
          y6.c = y6.e = null;
        } else {
          y6.c = [0];
          y6.e = 0;
        }
      }
      return y6;
    }
    e16 = bitFloor(x5.e / LOG_BASE) + bitFloor(y6.e / LOG_BASE);
    y6.s *= x5.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL)
      zc = xc, xc = yc, yc = zc, i17 = xcL, xcL = ycL, ycL = i17;
    for (i17 = xcL + ycL, zc = []; i17--; zc.push(0))
      ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i17 = ycL; --i17 >= 0; ) {
      c11 = 0;
      ylo = yc[i17] % sqrtBase;
      yhi = yc[i17] / sqrtBase | 0;
      for (k4 = xcL, j2 = i17 + k4; j2 > i17; ) {
        xlo = xc[--k4] % sqrtBase;
        xhi = xc[k4] / sqrtBase | 0;
        m12 = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m12 % sqrtBase * sqrtBase + zc[j2] + c11;
        c11 = (xlo / base | 0) + (m12 / sqrtBase | 0) + yhi * xhi;
        zc[j2--] = xlo % base;
      }
      zc[j2] = c11;
    }
    if (c11) {
      ++e16;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y6, zc, e16);
  };
  P4.negated = function() {
    var x5 = new BigNumber2(this);
    x5.s = -x5.s || null;
    return x5;
  };
  P4.plus = function(y6, b5) {
    var t18, x5 = this, a10 = x5.s;
    y6 = new BigNumber2(y6, b5);
    b5 = y6.s;
    if (!a10 || !b5)
      return new BigNumber2(NaN);
    if (a10 != b5) {
      y6.s = -b5;
      return x5.minus(y6);
    }
    var xe = x5.e / LOG_BASE, ye = y6.e / LOG_BASE, xc = x5.c, yc = y6.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return new BigNumber2(a10 / 0);
      if (!xc[0] || !yc[0])
        return yc[0] ? y6 : new BigNumber2(xc[0] ? x5 : a10 * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a10 = xe - ye) {
      if (a10 > 0) {
        ye = xe;
        t18 = yc;
      } else {
        a10 = -a10;
        t18 = xc;
      }
      t18.reverse();
      for (; a10--; t18.push(0))
        ;
      t18.reverse();
    }
    a10 = xc.length;
    b5 = yc.length;
    if (a10 - b5 < 0)
      t18 = yc, yc = xc, xc = t18, b5 = a10;
    for (a10 = 0; b5; ) {
      a10 = (xc[--b5] = xc[b5] + yc[b5] + a10) / BASE | 0;
      xc[b5] = BASE === xc[b5] ? 0 : xc[b5] % BASE;
    }
    if (a10) {
      xc = [a10].concat(xc);
      ++ye;
    }
    return normalise(y6, xc, ye);
  };
  P4.precision = P4.sd = function(sd, rm) {
    var c11, n17, v7, x5 = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x5), sd, rm);
    }
    if (!(c11 = x5.c))
      return null;
    v7 = c11.length - 1;
    n17 = v7 * LOG_BASE + 1;
    if (v7 = c11[v7]) {
      for (; v7 % 10 == 0; v7 /= 10, n17--)
        ;
      for (v7 = c11[0]; v7 >= 10; v7 /= 10, n17++)
        ;
    }
    if (sd && x5.e + 1 > n17)
      n17 = x5.e + 1;
    return n17;
  };
  P4.shiftedBy = function(k4) {
    intCheck(k4, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k4);
  };
  P4.squareRoot = P4.sqrt = function() {
    var m12, n17, r17, rep, t18, x5 = this, c11 = x5.c, s9 = x5.s, e16 = x5.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s9 !== 1 || !c11 || !c11[0]) {
      return new BigNumber2(!s9 || s9 < 0 && (!c11 || c11[0]) ? NaN : c11 ? x5 : 1 / 0);
    }
    s9 = Math.sqrt(+valueOf(x5));
    if (s9 == 0 || s9 == 1 / 0) {
      n17 = coeffToString(c11);
      if ((n17.length + e16) % 2 == 0)
        n17 += "0";
      s9 = Math.sqrt(+n17);
      e16 = bitFloor((e16 + 1) / 2) - (e16 < 0 || e16 % 2);
      if (s9 == 1 / 0) {
        n17 = "5e" + e16;
      } else {
        n17 = s9.toExponential();
        n17 = n17.slice(0, n17.indexOf("e") + 1) + e16;
      }
      r17 = new BigNumber2(n17);
    } else {
      r17 = new BigNumber2(s9 + "");
    }
    if (r17.c[0]) {
      e16 = r17.e;
      s9 = e16 + dp;
      if (s9 < 3)
        s9 = 0;
      for (; ; ) {
        t18 = r17;
        r17 = half.times(t18.plus(div(x5, t18, dp, 1)));
        if (coeffToString(t18.c).slice(0, s9) === (n17 = coeffToString(r17.c)).slice(0, s9)) {
          if (r17.e < e16)
            --s9;
          n17 = n17.slice(s9 - 3, s9 + 1);
          if (n17 == "9999" || !rep && n17 == "4999") {
            if (!rep) {
              round(t18, t18.e + DECIMAL_PLACES + 2, 0);
              if (t18.times(t18).eq(x5)) {
                r17 = t18;
                break;
              }
            }
            dp += 4;
            s9 += 4;
            rep = 1;
          } else {
            if (!+n17 || !+n17.slice(1) && n17.charAt(0) == "5") {
              round(r17, r17.e + DECIMAL_PLACES + 2, 1);
              m12 = !r17.times(r17).eq(x5);
            }
            break;
          }
        }
      }
    }
    return round(r17, r17.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m12);
  };
  P4.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P4.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P4.toFormat = function(dp, rm, format2) {
    var str, x5 = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x5.toFixed(dp, rm);
    if (x5.c) {
      var i17, arr = str.split("."), g1 = +format2.groupSize, g22 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x5.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g22)
        i17 = g1, g1 = g22, g22 = i17, len -= i17;
      if (g1 > 0 && len > 0) {
        i17 = len % g1 || g1;
        intPart = intDigits.substr(0, i17);
        for (; i17 < len; i17 += g1)
          intPart += groupSeparator + intDigits.substr(i17, g1);
        if (g22 > 0)
          intPart += groupSeparator + intDigits.slice(i17);
        if (isNeg)
          intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g22 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g22 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P4.toFraction = function(md) {
    var d15, d0, d1, d22, e16, exp, n17, n0, n1, q2, r17, s9, x5 = this, xc = x5.c;
    if (md != null) {
      n17 = new BigNumber2(md);
      if (!n17.isInteger() && (n17.c || n17.s !== 1) || n17.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n17.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n17));
      }
    }
    if (!xc)
      return new BigNumber2(x5);
    d15 = new BigNumber2(ONE);
    n1 = d0 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s9 = coeffToString(xc);
    e16 = d15.e = s9.length - x5.e - 1;
    d15.c[0] = POWS_TEN[(exp = e16 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n17.comparedTo(d15) > 0 ? e16 > 0 ? d15 : n1 : n17;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n17 = new BigNumber2(s9);
    n0.c[0] = 0;
    for (; ; ) {
      q2 = div(n17, d15, 0, 1);
      d22 = d0.plus(q2.times(d1));
      if (d22.comparedTo(md) == 1)
        break;
      d0 = d1;
      d1 = d22;
      n1 = n0.plus(q2.times(d22 = n1));
      n0 = d22;
      d15 = n17.minus(q2.times(d22 = d15));
      n17 = d22;
    }
    d22 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d22.times(n1));
    d0 = d0.plus(d22.times(d1));
    n0.s = n1.s = x5.s;
    e16 = e16 * 2;
    r17 = div(n1, d1, e16, ROUNDING_MODE).minus(x5).abs().comparedTo(
      div(n0, d0, e16, ROUNDING_MODE).minus(x5).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r17;
  };
  P4.toNumber = function() {
    return +valueOf(this);
  };
  P4.toPrecision = function(sd, rm) {
    if (sd != null)
      intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P4.toString = function(b5) {
    var str, n17 = this, s9 = n17.s, e16 = n17.e;
    if (e16 === null) {
      if (s9) {
        str = "Infinity";
        if (s9 < 0)
          str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b5 == null) {
        str = e16 <= TO_EXP_NEG || e16 >= TO_EXP_POS ? toExponential(coeffToString(n17.c), e16) : toFixedPoint(coeffToString(n17.c), e16, "0");
      } else if (b5 === 10 && alphabetHasNormalDecimalDigits) {
        n17 = round(new BigNumber2(n17), DECIMAL_PLACES + e16 + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n17.c), n17.e, "0");
      } else {
        intCheck(b5, 2, ALPHABET.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n17.c), e16, "0"), 10, b5, s9, true);
      }
      if (s9 < 0 && n17.c[0])
        str = "-" + str;
    }
    return str;
  };
  P4.valueOf = P4.toJSON = function() {
    return valueOf(this);
  };
  P4._isBigNumber = true;
  P4[Symbol.toStringTag] = "BigNumber";
  P4[Symbol.for("nodejs.util.inspect.custom")] = P4.valueOf;
  if (configObject != null)
    BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n17) {
  var i17 = n17 | 0;
  return n17 > 0 || n17 === i17 ? i17 : i17 - 1;
}
function coeffToString(a10) {
  var s9, z, i17 = 1, j2 = a10.length, r17 = a10[0] + "";
  for (; i17 < j2; ) {
    s9 = a10[i17++] + "";
    z = LOG_BASE - s9.length;
    for (; z--; s9 = "0" + s9)
      ;
    r17 += s9;
  }
  for (j2 = r17.length; r17.charCodeAt(--j2) === 48; )
    ;
  return r17.slice(0, j2 + 1 || 1);
}
function compare(x5, y6) {
  var a10, b5, xc = x5.c, yc = y6.c, i17 = x5.s, j2 = y6.s, k4 = x5.e, l9 = y6.e;
  if (!i17 || !j2)
    return null;
  a10 = xc && !xc[0];
  b5 = yc && !yc[0];
  if (a10 || b5)
    return a10 ? b5 ? 0 : -j2 : i17;
  if (i17 != j2)
    return i17;
  a10 = i17 < 0;
  b5 = k4 == l9;
  if (!xc || !yc)
    return b5 ? 0 : !xc ^ a10 ? 1 : -1;
  if (!b5)
    return k4 > l9 ^ a10 ? 1 : -1;
  j2 = (k4 = xc.length) < (l9 = yc.length) ? k4 : l9;
  for (i17 = 0; i17 < j2; i17++)
    if (xc[i17] != yc[i17])
      return xc[i17] > yc[i17] ^ a10 ? 1 : -1;
  return k4 == l9 ? 0 : k4 > l9 ^ a10 ? 1 : -1;
}
function intCheck(n17, min, max, name) {
  if (n17 < min || n17 > max || n17 !== mathfloor(n17)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n17 == "number" ? n17 < min || n17 > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n17));
  }
}
function isOdd(n17) {
  var k4 = n17.c.length - 1;
  return bitFloor(n17.e / LOG_BASE) == k4 && n17.c[k4] % 2 != 0;
}
function toExponential(str, e16) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e16 < 0 ? "e" : "e+") + e16;
}
function toFixedPoint(str, e16, z) {
  var len, zs;
  if (e16 < 0) {
    for (zs = z + "."; ++e16; zs += z)
      ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e16 > len) {
      for (zs = z, e16 -= len; --e16; zs += z)
        ;
      str += zs;
    } else if (e16 < len) {
      str = str.slice(0, e16) + "." + str.slice(e16);
    }
  }
  return str;
}
var BigNumber = clone();
var bignumber_default = BigNumber;

// node_modules/ethos-connect/dist/lib/bigNumber.js
var g4 = (t18) => new bignumber_default(t18);
var m5 = (t18, r17) => {
  let n17 = new bignumber_default(t18.toString()), e16 = new bignumber_default(r17.toString());
  return n17.plus(e16);
};
var o5 = (t18, r17 = 9) => {
  if (t18 === void 0)
    return "---";
  let n17 = "", e16 = new bignumber_default(t18.toString()).shiftedBy(-1 * r17);
  return e16.gte(1e9) ? (e16 = e16.shiftedBy(-9), n17 = " B") : e16.gte(1e6) ? (e16 = e16.shiftedBy(-6), n17 = " M") : e16.gte(1e4) && (e16 = e16.shiftedBy(-3), n17 = " K"), e16.gte(1) ? e16 = e16.decimalPlaces(3, bignumber_default.ROUND_DOWN) : e16 = e16.decimalPlaces(6, bignumber_default.ROUND_DOWN), e16.toFormat() + n17;
};

// node_modules/ethos-connect/dist/lib/getBagNFT.js
var import_lodash = __toESM(require_lodash(), 1);
var b2 = /0x2::dynamic_field::Field<(0x[a-f0-9]{39,40})::utils::Marker<(0x[a-f0-9]{39,40})::display::UrlDomain>, (0x[a-f0-9]{39,40})::display::UrlDomain>/;
var j = /0x2::dynamic_field::Field<(0x[a-f0-9]{39,40})::utils::Marker<(0x[a-f0-9]{39,40})::display::DisplayDomain>, (0x[a-f0-9]{39,40})::display::DisplayDomain>/;
var d = "reference.objectId";
var f5 = "data.fields.bag.fields.id.id";
var g5 = "data.fields.logical_owner";
var u = (t18, e16) => {
  const { data: s9 } = t18;
  if (is(s9, SuiObjectData)) {
    const { content: n17 } = s9;
    if (n17 && "type" in n17)
      return n17.type.match(e16);
  }
  return false;
};
var x = (t18) => {
  const e16 = {}, s9 = t18.find((i17) => u(i17, b2)), n17 = t18.find((i17) => u(i17, j));
  if (s9 && getObjectFields(s9)) {
    const i17 = getObjectFields(s9).value.fields.url;
    e16.url = F2(i17);
  }
  return n17 && getObjectFields(n17) && (e16.description = getObjectFields(n17).value.fields.description, e16.name = getObjectFields(n17).value.fields.name), e16;
};
var O = (t18) => !!t18.content && "fields" in t18.content && "logical_owner" in t18.content.fields && "bag" in t18.content.fields;
var w2 = async (t18, e16) => {
  if (!O(e16) || !import_lodash.default.has(e16, d) || !import_lodash.default.has(e16, f5) || !import_lodash.default.has(e16, g5))
    return e16;
  const s9 = import_lodash.default.get(e16, d), n17 = import_lodash.default.get(e16, f5), i17 = import_lodash.default.get(e16, g5), r17 = (await t18.getDynamicFields({ parentId: n17 || "" })).data.map((m12) => m12.objectId), c11 = await t18.multiGetObjects({ ids: r17, options: { showContent: true, showDisplay: true, showOwner: true, showType: true } });
  return { id: s9, owner: i17, ...x(c11) };
};
var P2 = w2;

// node_modules/ethos-connect/dist/enums/Chain.js
var t4;
(function(e16) {
  e16.SUI_DEVNET = "sui:devnet", e16.SUI_TESTNET = "sui:testnet", e16.SUI_CUSTOM = "sui:custom";
})(t4 || (t4 = {}));

// node_modules/ethos-connect/dist/lib/constants.js
var e5 = "#6f53e4";
var n4 = typeof window != "undefined" && window.location.origin.indexOf("http://localhost") === 0 ? "http://localhost:3000" : "https://ethoswallet.onrender.com";
var i4 = "https://fullnode.devnet.sui.io/";
var p3 = "https://faucet.devnet.sui.io/";
var r6 = t4.SUI_DEVNET;

// node_modules/ethos-connect/dist/lib/getDisplay.js
var e6 = (t18) => {
  if (!!t18) {
    if ((t18 == null ? void 0 : t18.data) && typeof (t18 == null ? void 0 : t18.data) == "object")
      return t18.data;
    if (!("error" in t18))
      return t18;
  }
};
var r7 = e6;

// node_modules/ethos-connect/dist/lib/getWalletContents.js
var F2 = (o18) => o18 ? (o18.indexOf("ipfs") === 0 && (o18 = `https://ipfs.io/ipfs/${o18.substring(5)}`), o18) : "";
var y3 = { suiBalance: g4(0), nfts: [], tokens: {}, objects: [] };
var R2 = async ({ address: o18, network: S3, existingContents: l9 }) => {
  try {
    const f11 = new Connection({ fullnode: S3 || i4 }), h7 = new JsonRpcProvider(f11);
    if (!o18)
      return y3;
    const b5 = await h7.getOwnedObjects({ owner: o18, options: { showType: true, showOwner: true, showContent: true, showDisplay: true } });
    if (b5.data.length === 0)
      return l9 === y3 ? null : y3;
    const w12 = [];
    let p12 = [];
    if ((l9 == null ? void 0 : l9.objects) && l9.objects.length > 0)
      for (const n17 of b5.data) {
        if (!n17.data || n17.error)
          continue;
        const e16 = l9 == null ? void 0 : l9.objects.find((c11) => typeof n17.data == "object" && typeof c11.data == "object" ? c11.data.objectId === n17.data.objectId && c11.data.version === n17.data.version : false);
        e16 ? w12.push(e16) : p12.push(n17);
      }
    else
      p12 = b5.data;
    if (p12.length === 0)
      return null;
    const T = p12, W5 = w12.concat(T);
    let j2 = g4(0);
    const m12 = [], s9 = {}, I6 = [];
    for (const n17 of W5) {
      const { data: e16 } = n17;
      if (!e16)
        continue;
      const { display: c11, content: { fields: d15 } } = e16, t18 = r7(c11);
      try {
        const u5 = (e16.type || "").split("<"), r17 = (u5[1] || "").replace(/>/, ""), i17 = u5[0].split("::"), x5 = i17[i17.length - 1], { name: v7, description: C10, ...k4 } = d15 ?? {};
        if (I6.push({ ...n17, type: e16 == null ? void 0 : e16.type, version: e16 == null ? void 0 : e16.version, objectId: e16 == null ? void 0 : e16.objectId, name: v7, description: C10, display: t18, extraFields: k4 }), x5 === "Coin")
          r17 === "0x2::sui::SUI" && (j2 = m5(j2, d15.balance)), s9[r17] || (s9[r17] = { balance: 0, coins: [] }), s9[r17].balance = m5(s9[r17].balance, d15.balance), s9[r17].coins.push({ objectId: e16 == null ? void 0 : e16.objectId, type: e16 == null ? void 0 : e16.type, balance: g4(d15.balance), digest: e16 == null ? void 0 : e16.digest, version: e16 == null ? void 0 : e16.version, display: t18 });
        else if (O(n17.data)) {
          const a10 = await P2(h7, n17.data);
          "name" in a10 && m12.push({ type: e16 == null ? void 0 : e16.type, package: i17[0], chain: "Sui", address: e16 == null ? void 0 : e16.objectId, objectId: e16 == null ? void 0 : e16.objectId, name: (t18 == null ? void 0 : t18.name) ?? a10.name, description: (t18 == null ? void 0 : t18.name) ?? a10.description, imageUri: F2((t18 == null ? void 0 : t18.image_url) ?? a10.url), link: t18 == null ? void 0 : t18.link, creator: t18 == null ? void 0 : t18.creator, projectUrl: t18 == null ? void 0 : t18.project_url, display: t18, module: i17[1], links: { Explorer: `https://explorer.sui.io/objects/${n17 == null ? void 0 : n17.objectId}` } });
        } else {
          const { url: a10, image_url: B4, image: U, ...E4 } = k4 || {}, O3 = F2((t18 == null ? void 0 : t18.image_url) || a10 || B4 || U);
          O3 && m12.push({ type: e16 == null ? void 0 : e16.type, package: i17[0], chain: "Sui", address: e16 == null ? void 0 : e16.objectId, objectId: e16 == null ? void 0 : e16.objectId, name: (t18 == null ? void 0 : t18.name) ?? v7, description: (t18 == null ? void 0 : t18.description) ?? C10, imageUri: O3, link: t18 == null ? void 0 : t18.link, creator: t18 == null ? void 0 : t18.creator, projectUrl: t18 == null ? void 0 : t18.project_url, display: t18, extraFields: E4, module: i17[1], links: { Explorer: `https://explorer.sui.io/objects/${n17 == null ? void 0 : n17.objectId}` } });
        }
      } catch (u5) {
        console.log("Error retrieving object", n17, u5);
      }
    }
    return { suiBalance: j2, tokens: s9, nfts: m12, objects: I6 };
  } catch (f11) {
    return console.log("Error retrieving wallet contents", f11), null;
  }
};
var Y2 = R2;

// node_modules/ethos-connect/dist/lib/getEthosSigner.js
var import_store26 = __toESM(require_store2(), 1);

// node_modules/ethos-connect/dist/types/Signer.js
var t5;
(function(n17) {
  n17.Extension = "extension", n17.Hosted = "hosted";
})(t5 || (t5 = {}));

// node_modules/ethos-connect/dist/lib/activeUser.js
var l2 = () => {
  c4("activeUser", "Calling Active User");
  const { walletAppUrl: r17, apiKey: a10 } = a2();
  c4("activeUser", "Configuration", r17, a10);
  const g10 = (m12) => {
    const o18 = (t18) => {
      if (c4("activeUser", "Message Origin: ", t18.origin, r17, t18), t18.origin === r17) {
        const { action: n17, data: i17 } = t18.data;
        c4("activeUser", "Message From Wallet", n17, i17), n17 === "user" && i17.apiKey === a10 && (window.removeEventListener("message", o18), m12(i17 == null ? void 0 : i17.user));
      }
    };
    window.addEventListener("message", o18);
    const s9 = { action: "activeUser" };
    c4("activeUser", "getIframe"), M(), c4('activeUser", "Post message to the iframe', s9), p2(s9);
  };
  return new Promise(g10);
};
var w3 = l2;

// node_modules/ethos-connect/dist/lib/hostedInteraction.js
var import_store25 = __toESM(require_store2(), 1);
var w4 = ({ id: t18, action: e16, data: n17, onResponse: i17, showWallet: p12 = false }) => {
  const { walletAppUrl: c11 } = a2(), r17 = (o18) => {
    if (c4("hostedInteraction", "response: ", o18), o18.origin === c11) {
      const { approved: m12, action: f11, data: l9 } = o18.data;
      if (f11 !== e16)
        return;
      i17({ approved: m12, data: l9 }), window.removeEventListener("message", r17), M(false);
    }
  };
  window.addEventListener("message", r17);
  const d15 = import_store25.default.namespace("ethos")("configuration"), { network: g10 } = d15;
  c4("hostedInteraction", "Posting interaction", t18, e16, n17), p2({ id: t18, network: g10, action: e16, data: n17 }), M(p12);
};
var L = w4;

// node_modules/ethos-connect/dist/lib/getEthosSigner.js
var x2 = async ({ defaultChain: D4 }) => {
  const a10 = await w3(), j2 = ((a10 == null ? void 0 : a10.accounts) || []).filter((n17) => n17.chain === "sui"), I6 = j2[0], N4 = (n17) => new Promise((e16, M5) => {
    const t18 = ({ approved: g10, data: i17 }) => {
      var _a;
      g10 ? e16(i17.response) : M5({ error: ((_a = i17 == null ? void 0 : i17.response) == null ? void 0 : _a.error) || "User rejected transaction." });
    }, o18 = n17.transactionBlock.serialize(), s9 = n17.account ?? I6.address, r17 = n17.chain ?? D4 ?? r6;
    L({ action: "transaction", data: { input: n17, serializedTransaction: o18, account: s9, chain: r17 }, onResponse: t18, showWallet: true });
  }), y6 = (n17) => new Promise((e16, M5) => {
    const t18 = ({ approved: g10, data: i17 }) => {
      var _a;
      g10 ? e16(i17.response) : M5({ error: ((_a = i17 == null ? void 0 : i17.response) == null ? void 0 : _a.error) || "User rejected transaction." });
    }, o18 = n17.transactionBlock.serialize(), s9 = n17.account ?? I6.address, r17 = n17.chain ?? D4 ?? r6;
    L({ action: "transaction", data: { input: n17, serializedTransaction: o18, account: s9, chain: r17 }, onResponse: t18, showWallet: true });
  }), z = () => Promise.resolve(true), l9 = (n17) => new Promise((e16, M5) => {
    const t18 = ({ approved: o18, data: s9 }) => {
      var _a;
      o18 ? e16(s9.response) : M5({ error: ((_a = s9 == null ? void 0 : s9.response) == null ? void 0 : _a.error) || "User rejected signing." });
    };
    L({ action: "sign", data: { ...n17, signData: n17.message }, onResponse: t18, showWallet: true });
  }), u5 = (n17 = false) => new Promise((e16) => {
    const M5 = () => {
      e16(true);
    };
    L({ action: "logout", data: { fromWallet: typeof n17 == "boolean" ? n17 : false }, onResponse: M5 }), import_store26.default.namespace("auth")("access_token", null);
  }), E4 = () => u5(true);
  return a10 ? { type: t5.Hosted, name: "Ethos", icon: p4, email: a10.email, getAddress: async () => I6 == null ? void 0 : I6.address, accounts: j2, currentAccount: I6, signAndExecuteTransactionBlock: N4, signTransactionBlock: y6, requestPreapproval: z, signMessage: l9, disconnect: u5, logout: E4 } : null;
};
var f6 = x2;
var p4 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iOCIgZmlsbD0iIzZEMjhEOSIvPgo8cGF0aCBvcGFjaXR5PSIwLjgiIGQ9Ik05LjEyMTg3IDYuODU3MDZIMTkuOTU4M0MyMC40NTcxIDYuODU3MDYgMjAuODYxNCA3LjI2MTQxIDIwLjg2MTQgNy43NjAyVjE5Ljk4ODZDMjAuODYxNCAyMC40ODc0IDIwLjQ1NzEgMjAuODkxOCAxOS45NTgzIDIwLjg5MThIOS4xMjE4N0M4LjYyMzA4IDIwLjg5MTggOC4yMTg3MiAyMC40ODc0IDguMjE4NzIgMTkuOTg4NlY3Ljc2MDJDOC4yMTg3MiA3LjI2MTQxIDguNjIzMDggNi44NTcwNiA5LjEyMTg3IDYuODU3MDZaIiBzdHJva2U9InVybCgjcGFpbnQwX2xpbmVhcl82OTlfMjY5OCkiIHN0cm9rZS13aWR0aD0iMC40NTE1NzIiLz4KPHBhdGggZD0iTTguNzEyNzQgNy40NTQ1OUwxNi4wOTQ1IDEwLjg4OTRDMTYuNDEyOSAxMS4wMzc2IDE2LjYxNjYgMTEuMzU3IDE2LjYxNjYgMTEuNzA4M1YyMy44MUMxNi42MTY2IDI0LjQ2MzUgMTUuOTQ0IDI0LjkwMDcgMTUuMzQ2OCAyNC42MzUzTDcuOTY1MDIgMjEuMzU1NkM3LjYzODgyIDIxLjIxMDcgNy40Mjg1OCAyMC44ODcyIDcuNDI4NTggMjAuNTMwM1Y4LjI3MzQzQzcuNDI4NTggNy42MTMxMSA4LjExNDA2IDcuMTc2MDIgOC43MTI3NCA3LjQ1NDU5WiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTIzLjM3ODIgMTUuMzc2N0MyMy40MzAzIDE1LjEzMjEgMjMuNTUzOCAxNC45MDg2IDIzLjczMzIgMTQuNzM0M0MyMy45MTI1IDE0LjU2IDI0LjEzOTYgMTQuNDQzIDI0LjM4NTYgMTQuMzk3OUwyNS4wNDA0IDE0LjI3ODRMMjQuMzg1NSAxNC4xNTg4SDI0LjM4NTZDMjQuMTM5NiAxNC4xMTM3IDIzLjkxMjUgMTMuOTk2NyAyMy43MzMyIDEzLjgyMjRDMjMuNTUzOCAxMy42NDgxIDIzLjQzMDMgMTMuNDI0NiAyMy4zNzgyIDEzLjE4TDIzLjIzNDEgMTIuNTAxM0wyMy4wOSAxMy4xOEMyMy4wMzc5IDEzLjQyNDYgMjIuOTE0NCAxMy42NDgxIDIyLjczNTEgMTMuODIyNEMyMi41NTU4IDEzLjk5NjcgMjIuMzI4NyAxNC4xMTM4IDIyLjA4MjcgMTQuMTU4OEwyMS40Mjc4IDE0LjI3ODRMMjIuMDgyNyAxNC4zOTc5SDIyLjA4MjdDMjIuMzI4NyAxNC40NDMgMjIuNTU1NyAxNC41NiAyMi43MzUgMTQuNzM0M0MyMi45MTQ0IDE0LjkwODYgMjMuMDM3OSAxNS4xMzIxIDIzLjA5IDE1LjM3NjdMMjMuMjM0MSAxNi4wNTU0TDIzLjM3ODIgMTUuMzc2N1oiIGZpbGw9IndoaXRlIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfNjk5XzI2OTgiIHgxPSIyMC44NjE0IiB5MT0iMTAuNTkyNiIgeDI9IjE0LjUzOTgiIHkyPSIxMy43NTM0IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IndoaXRlIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0id2hpdGUiIHN0b3Atb3BhY2l0eT0iMCIvPgo8L2xpbmVhckdyYWRpZW50Pgo8L2RlZnM+Cjwvc3ZnPgo=";

// node_modules/ethos-connect/dist/lib/initializeEthos.js
var import_store27 = __toESM(require_store2(), 1);
var n5 = (o18) => {
  const t18 = import_store27.default.namespace("ethos");
  c4("initialize", "Ethos Configuration", o18), t18("configuration", o18);
};
var m6 = n5;

// node_modules/ethos-connect/dist/lib/listenForMobileConnection.js
var c5 = async () => {
  const { walletAppUrl: i17 } = a2(), e16 = (n17) => {
    if (n17.origin === i17) {
      const { action: r17, data: o18 } = n17.data;
      if (r17 !== "connect" || !o18.address)
        return;
      window.removeEventListener("message", e16);
      const t18 = { currentAccount: { address: o18.address } };
      c4("mobile", "Mobile connection established", { getSigner: t18 }, t18);
    }
  };
  window.removeEventListener("message", e16), window.addEventListener("message", e16);
};
var m7 = c5;

// node_modules/ethos-connect/dist/lib/lib.js
var s3 = { getWalletContents: Y2, postIFrameMessage: p2, getEthosSigner: f6, getConfiguration: a2, initializeEthos: m6, listenForMobileConnection: m7 };
var C3 = s3;

// node_modules/ethos-connect/dist/lib/login.js
var d3 = async ({ email: g10, provider: e16, apiKey: t18 }) => {
  const { walletAppUrl: o18, redirectTo: n17 } = C3.getConfiguration(), u5 = import_store28.default.namespace("users");
  if (e16) {
    const r17 = n17 ?? location.href, i17 = `${o18}/auth?apiKey=${t18}&returnTo=${encodeURIComponent(r17)}`;
    location.href = `${o18}/socialauth?provider=${e16}&redirectTo=${encodeURIComponent(i17)}`;
    return;
  }
  return new Promise((r17, i17) => {
    const s9 = (a10) => {
      if (a10.origin === o18) {
        const { action: m12, data: l9 } = a10.data;
        if (m12 !== "login")
          return;
        window.removeEventListener("message", s9), u5("current", l9), r17(l9);
      }
    };
    window.addEventListener("message", s9), C3.postIFrameMessage({ action: "login", data: { email: g10, provider: e16, returnTo: n17 ?? window.location.href, apiKey: t18 } });
  });
};
var h4 = d3;

// node_modules/ethos-connect/dist/components/styled/Email.js
var E = ({ setSigningIn: o18, setEmailSent: f11, width: r17 }) => {
  const { apiKey: l9 } = a2(), [e16, m12] = (0, import_react10.useState)(""), t18 = (0, import_react10.useMemo)(() => !e16 || e16.length === 0 ? false : !!e16.match(/(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])/), [e16]), x5 = (0, import_react10.useCallback)(async () => {
    !t18 || (await h4({ email: e16, apiKey: l9 }), m12(""), o18(false), f11(true), n3({ action: "send_email", category: "sign_in", label: e16, value: 1 }));
  }, [t18, h4, e16, l9]), p12 = (0, import_react10.useCallback)((a10) => {
    m12(a10.target.value);
  }, []), c11 = (0, import_react10.useCallback)(async (a10) => {
    if (!t18) {
      a10.preventDefault();
      return;
    }
    o18(true), x5();
  }, [x5]);
  return import_react10.default.createElement("div", { role: "email-sign-in" }, import_react10.default.createElement("form", { onSubmit: c11, style: X(r17) }, import_react10.default.createElement("input", { style: q(), type: "email", placeholder: "Enter your email address...", value: e16, onChange: p12 }), import_react10.default.createElement(m4, { text: "Sign In With Email", type: "submit", width: r17, disabled: !t18, primary: true })));
};
var w5 = E;

// node_modules/ethos-connect/dist/components/styled/Dialog.js
var import_react11 = __toESM(require_react(), 1);

// node_modules/ethos-connect/dist/components/styled/FontProvider.js
var t6 = __toESM(require_react(), 1);
var s4 = ({ children: e16 }) => t6.createElement(t6.Fragment, null, t6.createElement("link", { href: "https://rsms.me/inter/inter.css", rel: "stylesheet" }), t6.createElement("div", { style: (() => ({ fontFamily: "'Inter', sans-serif", color: "black", lineHeight: "1.5", fontSize: "16px" }))() }, e16));
var i7 = s4;

// node_modules/ethos-connect/dist/components/styled/Dialog.js
var d5 = ({ isOpenAll: r17, children: t18 }) => import_react11.default.createElement(i7, null, import_react11.default.createElement("div", { style: g2(r17), role: "dialog" }, import_react11.default.createElement("div", { style: f3(r17) }), t18));
var n7 = d5;

// node_modules/ethos-connect/dist/components/styled/ModalWrapper.js
var import_react12 = __toESM(require_react(), 1);
var d6 = ({ closeOnClickId: s9, onClose: n17, isOpenAll: p12, width: l9, back: r17, children: t18 }) => import_react12.default.createElement("div", { style: C2(p12) }, import_react12.default.createElement("div", { id: s9, style: b(l9) }, import_react12.default.createElement("div", { style: R(l9) }, import_react12.default.createElement("div", { style: y() }, import_react12.default.createElement("span", null, r17 && import_react12.default.createElement("span", { style: h(), onClick: r17 }, "", import_react12.default.createElement("span", { style: w() }, "Back"))), import_react12.default.createElement("span", { style: P(), onClick: n17 }, import_react12.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, stroke: "currentColor" }, import_react12.default.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M6 18L18 6M6 6l12 12" })))), t18)));
var v = d6;

// node_modules/ethos-connect/dist/components/svg/InstallWalletIcon.js
var import_react13 = __toESM(require_react(), 1);
var r8 = ({ width: t18 = 60 }) => import_react13.default.createElement("svg", { width: t18, height: t18, viewBox: "0 0 60 60", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react13.default.createElement("rect", { x: "1", y: "1", width: "58", height: "58", rx: "17", fill: "#1A1C26" }), import_react13.default.createElement("path", { d: "M17.0307 21.5C18.1258 20.5314 19.538 19.9977 21 20H39C40.5213 20 41.9107 20.5667 42.9693 21.5C42.8475 20.5332 42.377 19.6442 41.6462 18.9998C40.9153 18.3553 39.9744 17.9998 39 18H21C20.0256 17.9998 19.0847 18.3553 18.3538 18.9998C17.623 19.6442 17.1525 20.5332 17.0307 21.5ZM17.0307 25.5C18.1258 24.5314 19.538 23.9977 21 24H39C40.5213 24 41.9107 24.5667 42.9693 25.5C42.8475 24.5332 42.377 23.6442 41.6462 22.9998C40.9153 22.3553 39.9744 21.9998 39 22H21C20.0256 21.9998 19.0847 22.3553 18.3538 22.9998C17.623 23.6442 17.1525 24.5332 17.0307 25.5ZM21 26C19.9391 26 18.9217 26.4214 18.1716 27.1716C17.4214 27.9217 17 28.9391 17 30V38C17 39.0609 17.4214 40.0783 18.1716 40.8284C18.9217 41.5786 19.9391 42 21 42H39C40.0609 42 41.0783 41.5786 41.8284 40.8284C42.5786 40.0783 43 39.0609 43 38V30C43 28.9391 42.5786 27.9217 41.8284 27.1716C41.0783 26.4214 40.0609 26 39 26H34C33.7348 26 33.4804 26.1054 33.2929 26.2929C33.1054 26.4804 33 26.7348 33 27C33 27.7956 32.6839 28.5587 32.1213 29.1213C31.5587 29.6839 30.7956 30 30 30C29.2044 30 28.4413 29.6839 27.8787 29.1213C27.3161 28.5587 27 27.7956 27 27C27 26.7348 26.8946 26.4804 26.7071 26.2929C26.5196 26.1054 26.2652 26 26 26H21Z", fill: "white" }), import_react13.default.createElement("rect", { x: "1", y: "1", width: "58", height: "58", rx: "17", stroke: "#060914", strokeWidth: "2" }));
var h5 = r8;

// node_modules/ethos-connect/dist/components/styled/InstallWallet.js
var import_react16 = __toESM(require_react(), 1);

// node_modules/ethos-connect/dist/components/svg/SuiEnclosed.js
var import_react14 = __toESM(require_react(), 1);
var l3 = ({ width: i17 = 32 }) => import_react14.default.createElement("svg", { width: i17, height: i17, viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react14.default.createElement("rect", { width: "32", height: "32", rx: "8", fill: "#81BAEB" }), import_react14.default.createElement("g", { clipPath: "url(#clip0_315_6756)" }, import_react14.default.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.4932 22.2659C11.0635 23.2776 11.8925 24.1195 12.8953 24.7053C13.898 25.2912 15.0385 25.5999 16.1999 25.5999C17.3613 25.5999 18.5017 25.2912 19.5045 24.7053C20.5073 24.1195 21.3363 23.2776 21.9066 22.2659C22.4918 21.2523 22.7999 20.1025 22.7999 18.932C22.7999 17.7616 22.4918 16.6118 21.9066 15.5982L16.8874 6.80155C16.8187 6.67967 16.7188 6.57825 16.598 6.50767C16.4772 6.4371 16.3398 6.3999 16.1999 6.3999C16.06 6.3999 15.9226 6.4371 15.8018 6.50767C15.6809 6.57825 15.5811 6.67967 15.5123 6.80155L10.4932 15.5982C9.90796 16.6118 9.59985 17.7616 9.59985 18.932C9.59985 20.1025 9.90796 21.2523 10.4932 22.2659ZM14.786 10.9865L15.8561 9.11092C15.8905 9.04998 15.9404 8.99927 16.0008 8.96399C16.0612 8.9287 16.1299 8.9101 16.1999 8.9101C16.2698 8.9101 16.3385 8.9287 16.399 8.96399C16.4594 8.99927 16.5093 9.04998 16.5437 9.11092L20.6605 16.3263C21.0301 16.966 21.2592 17.6771 21.3326 18.4123C21.4061 19.1475 21.3221 19.8898 21.0864 20.59C21.0352 20.3514 20.9648 20.1172 20.8758 19.8899C20.3072 18.4377 19.0214 17.3171 17.0534 16.559C15.7004 16.0397 14.8368 15.276 14.4859 14.2886C14.0339 13.0166 14.506 11.6291 14.786 10.9865ZM12.9612 14.1847L11.7392 16.3263C11.2817 17.1186 11.0409 18.0174 11.0409 18.9323C11.0409 19.8472 11.2817 20.7459 11.7392 21.5382C12.1091 22.1934 12.6186 22.7591 13.2316 23.1952C13.8447 23.6312 14.5462 23.927 15.2864 24.0615C16.0266 24.1959 16.7874 24.1658 17.5146 23.9732C18.2419 23.7806 18.9178 23.4302 19.4944 22.947C19.8131 22.1324 19.8244 21.2296 19.5264 20.4072C19.1088 19.358 18.1034 18.5204 16.5383 17.9172C14.7692 17.2381 13.6199 16.178 13.1228 14.7672C13.0558 14.5769 13.0019 14.3823 12.9612 14.1847Z", fill: "white" })), import_react14.default.createElement("defs", null, import_react14.default.createElement("clipPath", { id: "clip0_315_6756" }, import_react14.default.createElement("rect", { width: "19.2", height: "19.2", fill: "white", transform: "translate(6.3999 6.3999)" }))));
var e7 = l3;

// node_modules/ethos-connect/dist/components/svg/EthosWalletIcon.js
var import_react15 = __toESM(require_react(), 1);
var i8 = () => import_react15.default.createElement("svg", { width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react15.default.createElement("rect", { width: "32", height: "32", rx: "8", fill: "#6D28D9" }), import_react15.default.createElement("path", { opacity: "0.8", d: "M9.12187 6.85706H19.9583C20.4571 6.85706 20.8614 7.26141 20.8614 7.7602V19.9886C20.8614 20.4874 20.4571 20.8918 19.9583 20.8918H9.12187C8.62308 20.8918 8.21872 20.4874 8.21872 19.9886V7.7602C8.21872 7.26141 8.62308 6.85706 9.12187 6.85706Z", stroke: "url(#paint0_linear_699_2698)", strokeWidth: "0.451572" }), import_react15.default.createElement("path", { d: "M8.71274 7.45459L16.0945 10.8894C16.4129 11.0376 16.6166 11.357 16.6166 11.7083V23.81C16.6166 24.4635 15.944 24.9007 15.3468 24.6353L7.96502 21.3556C7.63882 21.2107 7.42858 20.8872 7.42858 20.5303V8.27343C7.42858 7.61311 8.11406 7.17602 8.71274 7.45459Z", fill: "white" }), import_react15.default.createElement("path", { d: "M23.3782 15.3767C23.4303 15.1321 23.5538 14.9086 23.7332 14.7343C23.9125 14.56 24.1396 14.443 24.3856 14.3979L25.0404 14.2784L24.3855 14.1588H24.3856C24.1396 14.1137 23.9125 13.9967 23.7332 13.8224C23.5538 13.6481 23.4303 13.4246 23.3782 13.18L23.2341 12.5013L23.09 13.18C23.0379 13.4246 22.9144 13.6481 22.7351 13.8224C22.5558 13.9967 22.3287 14.1138 22.0827 14.1588L21.4278 14.2784L22.0827 14.3979H22.0827C22.3287 14.443 22.5557 14.56 22.735 14.7343C22.9144 14.9086 23.0379 15.1321 23.09 15.3767L23.2341 16.0554L23.3782 15.3767Z", fill: "white" }), import_react15.default.createElement("defs", null, import_react15.default.createElement("linearGradient", { id: "paint0_linear_699_2698", x1: "20.8614", y1: "10.5926", x2: "14.5398", y2: "13.7534", gradientUnits: "userSpaceOnUse" }, import_react15.default.createElement("stop", { stopColor: "white" }), import_react15.default.createElement("stop", { offset: "1", stopColor: "white", stopOpacity: "0" }))));
var r9 = i8;

// node_modules/ethos-connect/dist/components/styled/InstallWallet.js
var d7 = ({ walletInfos: n17, width: e16 }) => {
  const i17 = (t18) => t18 ? typeof t18 == "string" ? import_react16.default.createElement("img", { src: t18, height: 32, width: 32 }) : t18 : import_react16.default.createElement(import_react16.default.Fragment, null), s9 = [{ name: "Ethos Wallet", icon: import_react16.default.createElement(r9, null), link: "https://chrome.google.com/webstore/detail/ethos-wallet/mcbigmjiafegjnnogedioegffbooigli" }, { name: "Sui Wallet", icon: import_react16.default.createElement(e7, null), link: "https://chrome.google.com/webstore/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil" }, ...n17 || []];
  return import_react16.default.createElement(h3, { dappIcon: import_react16.default.createElement(h5, null), title: "Install A Wallet", subTitle: "Wallets allow you to interact with, store, send, and receive digital assets." }, import_react16.default.createElement("div", { role: "wallet-sign-in" }, import_react16.default.createElement("div", { style: X(e16) }, s9 == null ? void 0 : s9.map((t18, r17) => import_react16.default.createElement("a", { key: `install-wallet-${r17}`, style: Y(e16), href: t18.link, target: "_blank" }, t18.name, import_react16.default.createElement("div", null, i17(t18.icon)))))));
};
var w6 = d7;

// node_modules/ethos-connect/dist/hooks/useModal.js
var import_react18 = __toESM(require_react(), 1);

// node_modules/ethos-connect/dist/components/ConnectContext.js
var import_react17 = __toESM(require_react(), 1);
var n8 = { init: () => {
} };
var e8 = (0, import_react17.createContext)(n8);
var r10 = e8;

// node_modules/ethos-connect/dist/hooks/useModal.js
var n9 = () => {
  const { modal: t18 } = (0, import_react18.useContext)(r10);
  return t18;
};
var m8 = n9;

// node_modules/ethos-connect/dist/hooks/useWallet.js
var import_react19 = __toESM(require_react(), 1);

// node_modules/ethos-connect/dist/enums/EthosConnectStatus.js
var i9;
(function(d15) {
  d15.Loading = "loading", d15.NoConnection = "no_connection", d15.Connected = "connected";
})(i9 || (i9 = {}));

// node_modules/ethos-connect/dist/hooks/useWallet.js
var s5 = () => {
  const { wallet: t18 } = (0, import_react19.useContext)(r10);
  return t18 ?? { status: i9.Loading, provider: null, setAltAccount: () => {
  } };
};
var m9 = s5;

// node_modules/ethos-connect/dist/hooks/useWindowDimensions.js
var import_react20 = __toESM(require_react(), 1);
function t9() {
  if (typeof window == "undefined")
    return { width: 0, height: 0 };
  const { innerWidth: n17, innerHeight: e16 } = window;
  return { width: n17, height: e16 };
}
function d8() {
  const [n17, e16] = (0, import_react20.useState)({ width: 0, height: 0 });
  return (0, import_react20.useEffect)(() => {
    e16(t9());
    function i17() {
      e16(t9());
    }
    return window.addEventListener("resize", i17), () => window.removeEventListener("resize", i17);
  }, []), n17;
}

// node_modules/ethos-connect/dist/hooks/hooks.js
var i10 = { useModal: m8, useWallet: m9, useWindowDimensions: d8 };
var n10 = i10;

// node_modules/ethos-connect/dist/components/styled/MobileWallet.js
var import_react21 = __toESM(require_react(), 1);
var t10 = () => import_react21.default.createElement("div", { role: "wallet-sign-in" }, import_react21.default.createElement("span", { style: c() }, "Connect A Mobile Wallet"), import_react21.default.createElement("div", { style: ee() }, import_react21.default.createElement("p", null, "There are no mobile wallets yet on Sui.")));
var i11 = t10;

// node_modules/ethos-connect/dist/components/styled/Or.js
var import_react22 = __toESM(require_react(), 1);
var e10 = () => import_react22.default.createElement("div", { style: G() }, import_react22.default.createElement("div", { style: _() }), "or", import_react22.default.createElement("div", { style: _() }));
var o11 = e10;

// node_modules/ethos-connect/dist/components/styled/SignInModal.js
function Et() {
  window.ethosInternal.showSignInModal();
}
function xt() {
  window.ethosInternal.hideSignInModal();
}
var dt = ({ connectMessage: u5, dappName: j2, dappIcon: y6, hideEmailSignIn: a10, hideWalletSignIn: r17, externalContext: C10, preferredWallets: i17 }) => {
  const { wallets: O3, selectWallet: q2 } = (C10 == null ? void 0 : C10.wallet) || n10.useWallet(), { isModalOpen: w12, openModal: k4, closeModal: d15 } = (C10 == null ? void 0 : C10.modal) || n10.useModal(), [E4, x5] = (0, import_react23.useState)(w12), [z, v7] = (0, import_react23.useState)(false), [F4, A2] = (0, import_react23.useState)(false), { width: e16 } = n10.useWindowDimensions(), D4 = "ethos-close-on-click", [H, N4] = (0, import_react23.useState)(false), [m12, G4] = (0, import_react23.useState)(false), [p12, B4] = (0, import_react23.useState)(false), [n17, J2] = (0, import_react23.useState)(j2), [s9, K2] = (0, import_react23.useState)();
  o(D4, d15), (0, import_react23.useEffect)(() => {
    window.ethosInternal || (window.ethosInternal = {}), window.ethosInternal.showSignInModal = () => {
      k4();
    }, window.ethosInternal.hideSignInModal = () => {
      d15();
    }, x5(w12);
  }, [w12, x5, k4, d15]), (0, import_react23.useEffect)(() => {
    if (a10 && r17)
      throw new Error("hideEmailSignIn and hideWalletSignIn cannot both be true");
  }, [a10, r17]), (0, import_react23.useEffect)(() => {
    n17 || J2(document.title);
  }, [n17]), (0, import_react23.useEffect)(() => {
    let o18 = O3 || [];
    i17 && i17.length > 0 && (o18 = o18.sort((R3, tt2) => {
      let c11 = i17.indexOf(R3.name);
      c11 === -1 && (c11 = o18.length);
      let W5 = i17.indexOf(tt2.name);
      return W5 === -1 && (W5 = o18.length), c11 - W5;
    })), c4("preferredWallets", i17, o18), K2(o18);
  }, [O3, i17, c4]);
  const Q = (0, import_react23.useCallback)(() => {
    B4((o18) => !o18);
  }, []), L3 = (0, import_react23.useCallback)(() => {
    N4((o18) => !o18);
  }, []), U = (0, import_react23.useCallback)(() => {
    B4(false), G4(false), N4(false);
  }, []), I6 = (0, import_react23.useMemo)(() => u5 || (n17 ? import_react23.default.createElement(import_react23.default.Fragment, null, "Connect to ", import_react23.default.createElement("span", { style: m3() }, n17)) : import_react23.default.createElement(import_react23.default.Fragment, null)), [n17, u5]), V = (0, import_react23.useMemo)(() => s9 ? m12 ? import_react23.default.createElement(i11, null) : p12 || a10 && s9.length === 0 ? import_react23.default.createElement(w6, { width: e16 }) : r17 ? import_react23.default.createElement(w5, { setSigningIn: v7, setEmailSent: A2, width: e16 }) : !H && s9.length > 0 ? import_react23.default.createElement(h3, { title: I6, dappIcon: y6, subTitle: "Choose from your installed wallets" }, import_react23.default.createElement(f4, { wallets: s9, selectWallet: q2, width: e16 }), !a10 && import_react23.default.createElement(import_react23.default.Fragment, null, import_react23.default.createElement(o11, null), import_react23.default.createElement("div", { style: J() }, import_react23.default.createElement(m4, { text: "Sign In With Email", onClick: L3, width: e16, primary: true })))) : import_react23.default.createElement(h3, { title: I6, dappIcon: y6, subTitle: `Log in to ${n17}` }, import_react23.default.createElement(w5, { setSigningIn: v7, setEmailSent: A2, width: e16 }), !r17 && import_react23.default.createElement(import_react23.default.Fragment, null, import_react23.default.createElement(o11, null), import_react23.default.createElement("div", { style: J() }, s9.length > 0 ? import_react23.default.createElement(m4, { icon: import_react23.default.createElement(m, null), text: "Select One Of Your Wallets", onClick: L3, width: e16 }) : import_react23.default.createElement(m4, { icon: import_react23.default.createElement(m, null), text: "Install A Wallet", onClick: Q, width: e16 })))) : import_react23.default.createElement(import_react23.default.Fragment, null), [I6, n17, a10, r17, s9, H, m12, p12]), X2 = (0, import_react23.useMemo)(() => m12 || p12, [m12, p12]), Z = (0, import_react23.useMemo)(() => import_react23.default.createElement("div", { style: N() }, import_react23.default.createElement(a, { width: 50 })), []);
  return import_react23.default.createElement(n7, { isOpenAll: E4 }, import_react23.default.createElement(v, { closeOnClickId: D4, onClose: d15, isOpenAll: E4, width: e16, back: X2 ? U : null }, F4 ? import_react23.default.createElement(p, null) : z ? Z : V));
};
var vt = dt;

// node_modules/ethos-connect/dist/hooks/useContext.js
var import_react27 = __toESM(require_react(), 1);

// node_modules/ethos-connect/dist/hooks/useAccount.js
var import_react24 = __toESM(require_react(), 1);
var y4 = (s9, t18) => {
  const [c11, f11] = (0, import_react24.useState)(), [m12, u5] = (0, import_react24.useState)({}), i17 = (0, import_react24.useRef)(t18), o18 = (0, import_react24.useRef)();
  return (0, import_react24.useEffect)(() => {
    if (!s9)
      return;
    i17.current = t18;
    const a10 = async () => {
      var _a;
      const e16 = (c11 == null ? void 0 : c11.address) ?? ((_a = s9.currentAccount) == null ? void 0 : _a.address);
      if (!e16)
        return;
      u5((n17) => n17.address === e16 ? n17 : { ...n17, address: e16 });
      const r17 = await Y2({ address: e16, network: t18, existingContents: o18.current });
      !r17 || t18 !== i17.current || JSON.stringify(o18.current) === JSON.stringify(r17) || (o18.current = r17, u5((n17) => ({ ...n17, contents: r17 })));
    };
    a10();
    const A2 = setInterval(a10, 5e3);
    return () => clearInterval(A2);
  }, [t18, s9, c11]), { account: m12, altAccount: c11, setAltAccount: f11 };
};
var v2 = y4;

// node_modules/ethos-connect/dist/hooks/useConnect.js
var import_react26 = __toESM(require_react(), 1);

// node_modules/ethos-connect/dist/hooks/useWalletKit.js
var import_react25 = __toESM(require_react(), 1);

// node_modules/@mysten/wallet-adapter-base/dist/index.mjs
function isWalletAdapter(wallet) {
  return "connect" in wallet;
}
function isWalletProvider(wallet) {
  return !isWalletAdapter(wallet);
}
function resolveAdapters(adapterAndProviders) {
  return adapterAndProviders.flatMap((adapter) => {
    if (isWalletProvider(adapter)) {
      return adapter.get();
    }
    return adapter;
  });
}

// node_modules/@mysten/wallet-kit-core/dist/index.mjs
var localStorageAdapter = {
  async set(key, value) {
    return localStorage.setItem(key, value);
  },
  async get(key) {
    return localStorage.getItem(key);
  },
  async del(key) {
    localStorage.removeItem(key);
  }
};
var WalletKitCoreConnectionStatus = ((WalletKitCoreConnectionStatus2) => {
  WalletKitCoreConnectionStatus2["DISCONNECTED"] = "DISCONNECTED";
  WalletKitCoreConnectionStatus2["CONNECTING"] = "CONNECTING";
  WalletKitCoreConnectionStatus2["CONNECTED"] = "CONNECTED";
  WalletKitCoreConnectionStatus2["ERROR"] = "ERROR";
  return WalletKitCoreConnectionStatus2;
})(WalletKitCoreConnectionStatus || {});
var SUI_WALLET_NAME = "Sui Wallet";
var RECENT_WALLET_STORAGE = "wallet-kit:last-wallet";
function sortWallets(wallets2, preferredWallets) {
  return [
    // Preferred wallets, in order:
    ...preferredWallets.map((name) => wallets2.find((wallet) => wallet.name === name)).filter(Boolean),
    // Wallets in default order:
    ...wallets2.filter((wallet) => !preferredWallets.includes(wallet.name))
  ];
}
function createWalletKitCore({
  adapters,
  preferredWallets = [SUI_WALLET_NAME],
  storageAdapter = localStorageAdapter,
  storageKey = RECENT_WALLET_STORAGE
}) {
  const subscriptions = /* @__PURE__ */ new Set();
  let walletEventUnsubscribe = null;
  let internalState = {
    accounts: [],
    currentAccount: null,
    wallets: sortWallets(resolveAdapters(adapters), preferredWallets),
    currentWallet: null,
    status: "DISCONNECTED"
    /* DISCONNECTED */
  };
  const computeState = () => ({
    ...internalState,
    isConnecting: internalState.status === "CONNECTING",
    isConnected: internalState.status === "CONNECTED",
    isError: internalState.status === "ERROR"
    /* ERROR */
  });
  let state = computeState();
  function setState(nextInternalState) {
    internalState = {
      ...internalState,
      ...nextInternalState
    };
    state = computeState();
    subscriptions.forEach((handler) => {
      try {
        handler(state);
      } catch {
      }
    });
  }
  function disconnected() {
    if (walletEventUnsubscribe) {
      walletEventUnsubscribe();
      walletEventUnsubscribe = null;
    }
    setState({
      status: "DISCONNECTED",
      accounts: [],
      currentAccount: null,
      currentWallet: null
    });
  }
  const providers = adapters.filter(isWalletProvider);
  if (providers.length) {
    providers.map(
      (provider) => provider.on("changed", () => {
        setState({
          wallets: sortWallets(resolveAdapters(adapters), preferredWallets)
        });
      })
    );
  }
  const walletKit = {
    async autoconnect() {
      if (state.currentWallet)
        return;
      try {
        const lastWalletName = await storageAdapter.get(storageKey);
        if (lastWalletName) {
          walletKit.connect(lastWalletName);
        }
      } catch {
      }
    },
    getState() {
      return state;
    },
    subscribe(handler) {
      subscriptions.add(handler);
      try {
        handler(state);
      } catch {
      }
      return () => {
        subscriptions.delete(handler);
      };
    },
    async connect(walletName) {
      const currentWallet = internalState.wallets.find((wallet) => wallet.name === walletName) ?? null;
      setState({ currentWallet });
      if (currentWallet && !currentWallet.connecting) {
        if (walletEventUnsubscribe) {
          walletEventUnsubscribe();
        }
        walletEventUnsubscribe = currentWallet.on(
          "change",
          ({ connected, accounts }) => {
            if (connected === false) {
              disconnected();
            } else if (accounts) {
              setState({
                accounts,
                currentAccount: internalState.currentAccount && !accounts.find(
                  ({ address }) => {
                    var _a;
                    return address === ((_a = internalState.currentAccount) == null ? void 0 : _a.address);
                  }
                ) ? accounts[0] : internalState.currentAccount
              });
            }
          }
        );
        try {
          setState({
            status: "CONNECTING"
            /* CONNECTING */
          });
          await currentWallet.connect();
          setState({
            status: "CONNECTED"
            /* CONNECTED */
          });
          try {
            await storageAdapter.set(storageKey, currentWallet.name);
          } catch {
          }
          const accounts = await currentWallet.getAccounts();
          setState({ accounts, currentAccount: accounts[0] ?? null });
        } catch (e16) {
          console.log("Wallet connection error", e16);
          setState({
            status: "ERROR"
            /* ERROR */
          });
        }
      } else {
        setState({
          status: "DISCONNECTED"
          /* DISCONNECTED */
        });
      }
    },
    async disconnect() {
      if (!internalState.currentWallet) {
        console.warn("Attempted to `disconnect` but no wallet was connected.");
        return;
      }
      try {
        await storageAdapter.del(storageKey);
      } catch {
      }
      await internalState.currentWallet.disconnect();
      disconnected();
    },
    signMessage(messageInput) {
      if (!internalState.currentWallet || !internalState.currentAccount) {
        throw new Error(
          "No wallet is currently connected, cannot call `signMessage`."
        );
      }
      return internalState.currentWallet.signMessage({
        ...messageInput,
        account: messageInput.account ?? internalState.currentAccount
      });
    },
    async signTransactionBlock(transactionInput) {
      if (!internalState.currentWallet || !internalState.currentAccount) {
        throw new Error(
          "No wallet is currently connected, cannot call `signTransaction`."
        );
      }
      const {
        account = internalState.currentAccount,
        chain: chain2 = internalState.currentAccount.chains[0]
      } = transactionInput;
      if (!chain2) {
        throw new Error("Missing chain");
      }
      return internalState.currentWallet.signTransactionBlock({
        ...transactionInput,
        account,
        chain: chain2
      });
    },
    async signAndExecuteTransactionBlock(transactionInput) {
      if (!internalState.currentWallet || !internalState.currentAccount) {
        throw new Error(
          "No wallet is currently connected, cannot call `signAndExecuteTransactionBlock`."
        );
      }
      const {
        account = internalState.currentAccount,
        chain: chain2 = internalState.currentAccount.chains[0]
      } = transactionInput;
      if (!chain2) {
        throw new Error("Missing chain");
      }
      return internalState.currentWallet.signAndExecuteTransactionBlock({
        ...transactionInput,
        account,
        chain: chain2
      });
    }
  };
  return walletKit;
}

// node_modules/@mysten/wallet-adapter-unsafe-burner/node_modules/@mysten/sui.js/dist/index.mjs
var import_tweetnacl4 = __toESM(require_nacl_fast(), 1);

// node_modules/@mysten/wallet-adapter-unsafe-burner/node_modules/@mysten/bcs/dist/index.mjs
var import_bs582 = __toESM(require_bs58(), 1);
function b64ToUint62(nChr) {
  return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
}
function fromB642(sBase64, nBlocksSize) {
  var sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, ""), nInLen = sB64Enc.length, nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2, taBytes = new Uint8Array(nOutLen);
  for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
    nMod4 = nInIdx & 3;
    nUint24 |= b64ToUint62(sB64Enc.charCodeAt(nInIdx)) << 6 * (3 - nMod4);
    if (nMod4 === 3 || nInLen - nInIdx === 1) {
      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
        taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
      }
      nUint24 = 0;
    }
  }
  return taBytes;
}
function uint6ToB642(nUint6) {
  return nUint6 < 26 ? nUint6 + 65 : nUint6 < 52 ? nUint6 + 71 : nUint6 < 62 ? nUint6 - 4 : nUint6 === 62 ? 43 : nUint6 === 63 ? 47 : 65;
}
function toB642(aBytes) {
  var nMod3 = 2, sB64Enc = "";
  for (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {
    nMod3 = nIdx % 3;
    if (nIdx > 0 && nIdx * 4 / 3 % 76 === 0) {
      sB64Enc += "";
    }
    nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);
    if (nMod3 === 2 || aBytes.length - nIdx === 1) {
      sB64Enc += String.fromCodePoint(
        uint6ToB642(nUint24 >>> 18 & 63),
        uint6ToB642(nUint24 >>> 12 & 63),
        uint6ToB642(nUint24 >>> 6 & 63),
        uint6ToB642(nUint24 & 63)
      );
      nUint24 = 0;
    }
  }
  return sB64Enc.slice(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? "" : nMod3 === 1 ? "=" : "==");
}
function fromHEX2(hexStr) {
  let intArr = hexStr.replace("0x", "").match(/.{1,2}/g).map((byte) => parseInt(byte, 16));
  if (intArr === null) {
    throw new Error(`Unable to parse HEX: ${hexStr}`);
  }
  return Uint8Array.from(intArr);
}
function toHEX2(bytes2) {
  return bytes2.reduce(
    (str, byte) => str + byte.toString(16).padStart(2, "0"),
    ""
  );
}
var SUI_ADDRESS_LENGTH3 = 32;
function toLittleEndian2(bigint, size) {
  let result = new Uint8Array(size);
  let i17 = 0;
  while (bigint > 0) {
    result[i17] = Number(bigint % BigInt(256));
    bigint = bigint / BigInt(256);
    i17 += 1;
  }
  return result;
}
var toB582 = (buffer) => import_bs582.default.encode(buffer);
var fromB582 = (str) => import_bs582.default.decode(str);
var BcsReader2 = class {
  /**
   * @param {Uint8Array} data Data to use as a buffer.
   */
  constructor(data) {
    this.bytePosition = 0;
    this.dataView = new DataView(data.buffer);
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes2) {
    this.bytePosition += bytes2;
    return this;
  }
  /**
   * Read U8 value from the buffer and shift cursor by 1.
   * @returns
   */
  read8() {
    let value = this.dataView.getUint8(this.bytePosition);
    this.shift(1);
    return value;
  }
  /**
   * Read U16 value from the buffer and shift cursor by 2.
   * @returns
   */
  read16() {
    let value = this.dataView.getUint16(this.bytePosition, true);
    this.shift(2);
    return value;
  }
  /**
   * Read U32 value from the buffer and shift cursor by 4.
   * @returns
   */
  read32() {
    let value = this.dataView.getUint32(this.bytePosition, true);
    this.shift(4);
    return value;
  }
  /**
   * Read U64 value from the buffer and shift cursor by 8.
   * @returns
   */
  read64() {
    let value1 = this.read32();
    let value2 = this.read32();
    let result = value2.toString(16) + value1.toString(16).padStart(8, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 16.
   */
  read128() {
    let value1 = BigInt(this.read64());
    let value2 = BigInt(this.read64());
    let result = value2.toString(16) + value1.toString(16).padStart(8, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read U128 value from the buffer and shift cursor by 32.
   * @returns
   */
  read256() {
    let value1 = BigInt(this.read128());
    let value2 = BigInt(this.read128());
    let result = value2.toString(16) + value1.toString(16).padStart(16, "0");
    return BigInt("0x" + result).toString(10);
  }
  /**
   * Read `num` number of bytes from the buffer and shift cursor by `num`.
   * @param num Number of bytes to read.
   */
  readBytes(num) {
    let start = this.bytePosition + this.dataView.byteOffset;
    let value = new Uint8Array(this.dataView.buffer, start, num);
    this.shift(num);
    return value;
  }
  /**
   * Read ULEB value - an integer of varying size. Used for enum indexes and
   * vector lengths.
   * @returns {Number} The ULEB value.
   */
  readULEB() {
    let start = this.bytePosition + this.dataView.byteOffset;
    let buffer = new Uint8Array(this.dataView.buffer, start);
    let { value, length } = ulebDecode2(buffer);
    this.shift(length);
    return value;
  }
  /**
   * Read a BCS vector: read a length and then apply function `cb` X times
   * where X is the length of the vector, defined as ULEB in BCS bytes.
   * @param cb Callback to process elements of vector.
   * @returns {Array<Any>} Array of the resulting values, returned by callback.
   */
  readVec(cb) {
    let length = this.readULEB();
    let result = [];
    for (let i17 = 0; i17 < length; i17++) {
      result.push(cb(this, i17, length));
    }
    return result;
  }
};
var BcsWriter2 = class {
  constructor({
    size = 1024,
    maxSize,
    allocateSize = 1024
  } = {}) {
    this.bytePosition = 0;
    this.size = size;
    this.maxSize = maxSize || size;
    this.allocateSize = allocateSize;
    this.dataView = new DataView(new ArrayBuffer(size));
  }
  ensureSizeOrGrow(bytes2) {
    const requiredSize = this.bytePosition + bytes2;
    if (requiredSize > this.size) {
      const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);
      if (requiredSize > nextSize) {
        throw new Error(
          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`
        );
      }
      this.size = nextSize;
      const nextBuffer = new ArrayBuffer(this.size);
      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));
      this.dataView = new DataView(nextBuffer);
    }
  }
  /**
   * Shift current cursor position by `bytes`.
   *
   * @param {Number} bytes Number of bytes to
   * @returns {this} Self for possible chaining.
   */
  shift(bytes2) {
    this.bytePosition += bytes2;
    return this;
  }
  /**
   * Write a U8 value into a buffer and shift cursor position by 1.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write8(value) {
    this.ensureSizeOrGrow(1);
    this.dataView.setUint8(this.bytePosition, Number(value));
    return this.shift(1);
  }
  /**
   * Write a U16 value into a buffer and shift cursor position by 2.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write16(value) {
    this.ensureSizeOrGrow(2);
    this.dataView.setUint16(this.bytePosition, Number(value), true);
    return this.shift(2);
  }
  /**
   * Write a U32 value into a buffer and shift cursor position by 4.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  write32(value) {
    this.ensureSizeOrGrow(4);
    this.dataView.setUint32(this.bytePosition, Number(value), true);
    return this.shift(4);
  }
  /**
   * Write a U64 value into a buffer and shift cursor position by 8.
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write64(value) {
    toLittleEndian2(BigInt(value), 8).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a U128 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write128(value) {
    toLittleEndian2(BigInt(value), 16).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a U256 value into a buffer and shift cursor position by 16.
   *
   * @param {bigint} value Value to write.
   * @returns {this}
   */
  write256(value) {
    toLittleEndian2(BigInt(value), 32).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a ULEB value into a buffer and shift cursor position by number of bytes
   * written.
   * @param {Number} value Value to write.
   * @returns {this}
   */
  writeULEB(value) {
    ulebEncode2(value).forEach((el) => this.write8(el));
    return this;
  }
  /**
   * Write a vector into a buffer by first writing the vector length and then calling
   * a callback on each passed value.
   *
   * @param {Array<Any>} vector Array of elements to write.
   * @param {WriteVecCb} cb Callback to call on each element of the vector.
   * @returns {this}
   */
  writeVec(vector, cb) {
    this.writeULEB(vector.length);
    Array.from(vector).forEach((el, i17) => cb(this, el, i17, vector.length));
    return this;
  }
  /**
   * Adds support for iterations over the object.
   * @returns {Uint8Array}
   */
  *[Symbol.iterator]() {
    for (let i17 = 0; i17 < this.bytePosition; i17++) {
      yield this.dataView.getUint8(i17);
    }
    return this.toBytes();
  }
  /**
   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).
   * @returns {Uint8Array} Resulting bcs.
   */
  toBytes() {
    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));
  }
  /**
   * Represent data as 'hex' or 'base64'
   * @param encoding Encoding to use: 'base64' or 'hex'
   */
  toString(encoding) {
    return encodeStr2(this.toBytes(), encoding);
  }
};
function ulebEncode2(num) {
  let arr = [];
  let len = 0;
  if (num === 0) {
    return [0];
  }
  while (num > 0) {
    arr[len] = num & 127;
    if (num >>= 7) {
      arr[len] |= 128;
    }
    len += 1;
  }
  return arr;
}
function ulebDecode2(arr) {
  let total = 0;
  let shift = 0;
  let len = 0;
  while (true) {
    let byte = arr[len];
    len += 1;
    total |= (byte & 127) << shift;
    if ((byte & 128) === 0) {
      break;
    }
    shift += 7;
  }
  return {
    value: total,
    length: len
  };
}
var _BCS2 = class {
  /**
   * Construct a BCS instance with a prepared schema.
   *
   * @param schema A prepared schema with type definitions
   * @param withPrimitives Whether to register primitive types by default
   */
  constructor(schema) {
    this.types = /* @__PURE__ */ new Map();
    this.counter = 0;
    if (schema instanceof _BCS2) {
      this.schema = schema.schema;
      this.types = new Map(schema.types);
      return;
    }
    this.schema = schema;
    this.registerAddressType(
      _BCS2.ADDRESS,
      schema.addressLength,
      schema.addressEncoding
    );
    this.registerVectorType(schema.vectorType);
    if (schema.types && schema.types.structs) {
      for (let name of Object.keys(schema.types.structs)) {
        this.registerStructType(name, schema.types.structs[name]);
      }
    }
    if (schema.types && schema.types.enums) {
      for (let name of Object.keys(schema.types.enums)) {
        this.registerEnumType(name, schema.types.enums[name]);
      }
    }
    if (schema.types && schema.types.aliases) {
      for (let name of Object.keys(schema.types.aliases)) {
        this.registerAlias(name, schema.types.aliases[name]);
      }
    }
    if (schema.withPrimitives !== false) {
      registerPrimitives2(this);
    }
  }
  /**
   * Name of the key to use for temporary struct definitions.
   * Returns a temp key + index (for a case when multiple temp
   * structs are processed).
   */
  tempKey() {
    return `bcs-struct-${++this.counter}`;
  }
  /**
   * Serialize data into bcs.
   *
   * @example
   * bcs.registerVectorType('vector<u8>', 'u8');
   *
   * let serialized = BCS
   *   .set('vector<u8>', [1,2,3,4,5,6])
   *   .toBytes();
   *
   * console.assert(toHex(serialized) === '06010203040506');
   *
   * @param type Name of the type to serialize (must be registered) or a struct type.
   * @param data Data to serialize.
   * @param size Serialization buffer size. Default 1024 = 1KB.
   * @return A BCS reader instance. Usually you'd want to call `.toBytes()`
   */
  ser(type2, data, options) {
    if (typeof type2 === "string" || Array.isArray(type2)) {
      const { name, params } = this.parseTypeName(type2);
      return this.getTypeInterface(name).encode(
        this,
        data,
        options,
        params
      );
    }
    if (typeof type2 === "object") {
      const key = this.tempKey();
      const temp = new _BCS2(this);
      return temp.registerStructType(key, type2).ser(key, data, options);
    }
    throw new Error(
      `Incorrect type passed into the '.ser()' function. 
${JSON.stringify(
        type2
      )}`
    );
  }
  /**
   * Deserialize BCS into a JS type.
   *
   * @example
   * let num = bcs.ser('u64', '4294967295').toString('hex');
   * let deNum = bcs.de('u64', num, 'hex');
   * console.assert(deNum.toString(10) === '4294967295');
   *
   * @param type Name of the type to deserialize (must be registered) or a struct type definition.
   * @param data Data to deserialize.
   * @param encoding Optional - encoding to use if data is of type String
   * @return Deserialized data.
   */
  de(type2, data, encoding) {
    if (typeof data === "string") {
      if (encoding) {
        data = decodeStr2(data, encoding);
      } else {
        throw new Error("To pass a string to `bcs.de`, specify encoding");
      }
    }
    if (typeof type2 === "string" || Array.isArray(type2)) {
      const { name, params } = this.parseTypeName(type2);
      return this.getTypeInterface(name).decode(this, data, params);
    }
    if (typeof type2 === "object") {
      const temp = new _BCS2(this);
      const key = this.tempKey();
      return temp.registerStructType(key, type2).de(key, data, encoding);
    }
    throw new Error(
      `Incorrect type passed into the '.de()' function. 
${JSON.stringify(
        type2
      )}`
    );
  }
  /**
   * Check whether a `TypeInterface` has been loaded for a `type`.
   * @param type Name of the type to check.
   * @returns
   */
  hasType(type2) {
    return this.types.has(type2);
  }
  /**
   * Create an alias for a type.
   * WARNING: this can potentially lead to recursion
   * @param name Alias to use
   * @param forType Type to reference
   * @returns
   *
   * @example
   * ```
   * let bcs = new BCS(getSuiMoveConfig());
   * bcs.registerAlias('ObjectDigest', BCS.BASE58);
   * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');
   * ```
   */
  registerAlias(name, forType) {
    this.types.set(name, forType);
    return this;
  }
  /**
   * Method to register new types for BCS internal representation.
   * For each registered type 2 callbacks must be specified and one is optional:
   *
   * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;
   * - decodeCb(reader) - write a way to deserialize data with BcsReader;
   * - validateCb(data) - validate data - either return bool or throw an error
   *
   * @example
   * // our type would be a string that consists only of numbers
   * bcs.registerType('number_string',
   *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),
   *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8
   *    (value) => /[0-9]+/.test(value) // test that it has at least one digit
   * );
   * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);
   *
   * @param name
   * @param encodeCb Callback to encode a value.
   * @param decodeCb Callback to decode a value.
   * @param validateCb Optional validator Callback to check type before serialization.
   */
  registerType(typeName, encodeCb, decodeCb, validateCb = () => true) {
    const { name, params: generics } = this.parseTypeName(typeName);
    this.types.set(name, {
      encode(self2, data, options, typeParams) {
        const typeMap = generics.reduce(
          (acc, value, index) => {
            return Object.assign(acc, { [value]: typeParams[index] });
          },
          {}
        );
        return this._encodeRaw.call(
          self2,
          new BcsWriter2(options),
          data,
          typeParams,
          typeMap
        );
      },
      decode(self2, data, typeParams) {
        const typeMap = generics.reduce(
          (acc, value, index) => {
            return Object.assign(acc, { [value]: typeParams[index] });
          },
          {}
        );
        return this._decodeRaw.call(
          self2,
          new BcsReader2(data),
          typeParams,
          typeMap
        );
      },
      // these methods should always be used with caution as they require pre-defined
      // reader and writer and mainly exist to allow multi-field (de)serialization;
      _encodeRaw(writer, data, typeParams, typeMap) {
        if (validateCb(data)) {
          return encodeCb.call(this, writer, data, typeParams, typeMap);
        } else {
          throw new Error(`Validation failed for type ${name}, data: ${data}`);
        }
      },
      _decodeRaw(reader, typeParams, typeMap) {
        return decodeCb.call(this, reader, typeParams, typeMap);
      }
    });
    return this;
  }
  /**
   * Register an address type which is a sequence of U8s of specified length.
   * @example
   * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);
   * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');
   *
   * @param name Name of the address type.
   * @param length Byte length of the address.
   * @param encoding Encoding to use for the address type
   * @returns
   */
  registerAddressType(name, length, encoding = "hex") {
    switch (encoding) {
      case "base64":
        return this.registerType(
          name,
          function encodeAddress(writer, data) {
            return fromB642(data).reduce(
              (writer2, el) => writer2.write8(el),
              writer
            );
          },
          function decodeAddress(reader) {
            return toB642(reader.readBytes(length));
          }
        );
      case "hex":
        return this.registerType(
          name,
          function encodeAddress(writer, data) {
            return fromHEX2(data).reduce(
              (writer2, el) => writer2.write8(el),
              writer
            );
          },
          function decodeAddress(reader) {
            return toHEX2(reader.readBytes(length));
          }
        );
      default:
        throw new Error("Unsupported encoding! Use either hex or base64");
    }
  }
  /**
   * Register custom vector type inside the bcs.
   *
   * @example
   * bcs.registerVectorType('vector<T>'); // generic registration
   * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];
   * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');
   *
   * @param name Name of the type to register
   * @param elementType Optional name of the inner type of the vector
   * @return Returns self for chaining.
   */
  registerVectorType(typeName) {
    let { name, params } = this.parseTypeName(typeName);
    if (params.length > 1) {
      throw new Error("Vector can have only one type parameter; got " + name);
    }
    return this.registerType(
      typeName,
      function encodeVector(writer, data, typeParams, typeMap) {
        return writer.writeVec(data, (writer2, el) => {
          let elementType = typeParams[0];
          if (!elementType) {
            throw new Error(
              `Incorrect number of type parameters passed a to vector '${typeName}'`
            );
          }
          let { name: name2, params: params2 } = this.parseTypeName(elementType);
          if (this.hasType(name2)) {
            return this.getTypeInterface(name2)._encodeRaw.call(
              this,
              writer2,
              el,
              params2,
              typeMap
            );
          }
          if (!(name2 in typeMap)) {
            throw new Error(
              `Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`
            );
          }
          let { name: innerName, params: innerParams } = this.parseTypeName(
            typeMap[name2]
          );
          return this.getTypeInterface(innerName)._encodeRaw.call(
            this,
            writer2,
            el,
            innerParams,
            typeMap
          );
        });
      },
      function decodeVector(reader, typeParams, typeMap) {
        return reader.readVec((reader2) => {
          let elementType = typeParams[0];
          if (!elementType) {
            throw new Error(
              `Incorrect number of type parameters passed to a vector '${typeName}'`
            );
          }
          let { name: name2, params: params2 } = this.parseTypeName(elementType);
          if (this.hasType(name2)) {
            return this.getTypeInterface(name2)._decodeRaw.call(
              this,
              reader2,
              params2,
              typeMap
            );
          }
          if (!(name2 in typeMap)) {
            throw new Error(
              `Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`
            );
          }
          let { name: innerName, params: innerParams } = this.parseTypeName(
            typeMap[name2]
          );
          this.getTypeInterface(innerName)._decodeRaw.call(
            this,
            reader2,
            innerParams,
            typeMap
          );
        });
      }
    );
  }
  /**
   * Safe method to register a custom Move struct. The first argument is a name of the
   * struct which is only used on the FrontEnd and has no affect on serialization results,
   * and the second is a struct description passed as an Object.
   *
   * The description object MUST have the same order on all of the platforms (ie in Move
   * or in Rust).
   *
   * @example
   * // Move / Rust struct
   * // struct Coin {
   * //   value: u64,
   * //   owner: vector<u8>, // name // Vec<u8> in Rust
   * //   is_locked: bool,
   * // }
   *
   * bcs.registerStructType('Coin', {
   *   value: bcs.U64,
   *   owner: bcs.STRING,
   *   is_locked: bcs.BOOL
   * });
   *
   * // Created in Rust with diem/bcs
   * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';
   * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array
   *  128, 209, 177,   5,  96,  0,  0,
   *    0,  14,  66, 105, 103, 32, 87,
   *   97, 108, 108, 101, 116, 32, 71,
   *  117, 121,   0
   * ];
   *
   * // Let's encode the value as well
   * let test_set = bcs.ser('Coin', {
   *   owner: 'Big Wallet Guy',
   *   value: '412412400000',
   *   is_locked: false,
   * });
   *
   * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');
   *
   * @param name Name of the type to register.
   * @param fields Fields of the struct. Must be in the correct order.
   * @return Returns BCS for chaining.
   */
  registerStructType(typeName, fields) {
    for (let key in fields) {
      let internalName = this.tempKey();
      let value = fields[key];
      if (!Array.isArray(value) && typeof value !== "string") {
        fields[key] = internalName;
        this.registerStructType(internalName, value);
      }
    }
    let struct = Object.freeze(fields);
    let canonicalOrder = Object.keys(struct);
    let { name: structName, params: generics } = this.parseTypeName(typeName);
    return this.registerType(
      typeName,
      function encodeStruct(writer, data, typeParams, typeMap) {
        if (!data || data.constructor !== Object) {
          throw new Error(
            `Expected ${structName} to be an Object, got: ${data}`
          );
        }
        if (typeParams.length !== generics.length) {
          throw new Error(
            `Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`
          );
        }
        for (let key of canonicalOrder) {
          if (!(key in data)) {
            throw new Error(
              `Struct ${structName} requires field ${key}:${struct[key]}`
            );
          }
          const { name: fieldType, params: fieldParams } = this.parseTypeName(
            struct[key]
          );
          if (!generics.includes(fieldType)) {
            this.getTypeInterface(fieldType)._encodeRaw.call(
              this,
              writer,
              data[key],
              fieldParams,
              typeMap
            );
          } else {
            const paramIdx = generics.indexOf(fieldType);
            let { name, params } = this.parseTypeName(typeParams[paramIdx]);
            if (this.hasType(name)) {
              this.getTypeInterface(name)._encodeRaw.call(
                this,
                writer,
                data[key],
                params,
                typeMap
              );
              continue;
            }
            if (!(name in typeMap)) {
              throw new Error(
                `Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`
              );
            }
            let { name: innerName, params: innerParams } = this.parseTypeName(
              typeMap[name]
            );
            this.getTypeInterface(innerName)._encodeRaw.call(
              this,
              writer,
              data[key],
              innerParams,
              typeMap
            );
          }
        }
        return writer;
      },
      function decodeStruct(reader, typeParams, typeMap) {
        if (typeParams.length !== generics.length) {
          throw new Error(
            `Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`
          );
        }
        let result = {};
        for (let key of canonicalOrder) {
          const { name: fieldName, params: fieldParams } = this.parseTypeName(
            struct[key]
          );
          if (!generics.includes(fieldName)) {
            result[key] = this.getTypeInterface(fieldName)._decodeRaw.call(
              this,
              reader,
              fieldParams,
              typeMap
            );
          } else {
            const paramIdx = generics.indexOf(fieldName);
            let { name, params } = this.parseTypeName(typeParams[paramIdx]);
            if (this.hasType(name)) {
              result[key] = this.getTypeInterface(name)._decodeRaw.call(
                this,
                reader,
                params,
                typeMap
              );
              continue;
            }
            if (!(name in typeMap)) {
              throw new Error(
                `Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`
              );
            }
            let { name: innerName, params: innerParams } = this.parseTypeName(
              typeMap[name]
            );
            result[key] = this.getTypeInterface(innerName)._decodeRaw.call(
              this,
              reader,
              innerParams,
              typeMap
            );
          }
        }
        return result;
      }
    );
  }
  /**
   * Safe method to register custom enum type where each invariant holds the value of another type.
   * @example
   * bcs.registerStructType('Coin', { value: 'u64' });
   * bcs.registerEnumType('MyEnum', {
   *  single: 'Coin',
   *  multi: 'vector<Coin>',
   *  empty: null
   * });
   *
   * console.log(
   *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }
   *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }
   * )
   *
   * // and serialization
   * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();
   * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });
   *
   * @param name
   * @param variants
   */
  registerEnumType(typeName, variants) {
    for (let key in variants) {
      let internalName = this.tempKey();
      let value = variants[key];
      if (value !== null && !Array.isArray(value) && typeof value !== "string") {
        variants[key] = internalName;
        this.registerStructType(internalName, value);
      }
    }
    let struct = Object.freeze(variants);
    let canonicalOrder = Object.keys(struct);
    let { name, params: canonicalTypeParams } = this.parseTypeName(typeName);
    return this.registerType(
      typeName,
      function encodeEnum(writer, data, typeParams, typeMap) {
        if (!data) {
          throw new Error(
            `Unable to write enum "${name}", missing data.
Received: "${data}"`
          );
        }
        if (typeof data !== "object") {
          throw new Error(
            `Incorrect data passed into enum "${name}", expected object with properties: "${canonicalOrder.join(
              " | "
            )}".
Received: "${JSON.stringify(data)}"`
          );
        }
        let key = Object.keys(data)[0];
        if (key === void 0) {
          throw new Error(
            `Empty object passed as invariant of the enum "${name}"`
          );
        }
        let orderByte = canonicalOrder.indexOf(key);
        if (orderByte === -1) {
          throw new Error(
            `Unknown invariant of the enum "${name}", allowed values: "${canonicalOrder.join(
              " | "
            )}"; received "${key}"`
          );
        }
        let invariant = canonicalOrder[orderByte];
        let invariantType = struct[invariant];
        writer.write8(orderByte);
        if (invariantType === null) {
          return writer;
        }
        let paramIndex = canonicalTypeParams.indexOf(invariantType);
        let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];
        {
          let { name: name2, params } = this.parseTypeName(typeOrParam);
          return this.getTypeInterface(name2)._encodeRaw.call(
            this,
            writer,
            data[key],
            params,
            typeMap
          );
        }
      },
      function decodeEnum(reader, typeParams, typeMap) {
        let orderByte = reader.readULEB();
        let invariant = canonicalOrder[orderByte];
        let invariantType = struct[invariant];
        if (orderByte === -1) {
          throw new Error(
            `Decoding type mismatch, expected enum "${name}" invariant index, received "${orderByte}"`
          );
        }
        if (invariantType === null) {
          return { [invariant]: true };
        }
        let paramIndex = canonicalTypeParams.indexOf(invariantType);
        let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];
        {
          let { name: name2, params } = this.parseTypeName(typeOrParam);
          return {
            [invariant]: this.getTypeInterface(name2)._decodeRaw.call(
              this,
              reader,
              params,
              typeMap
            )
          };
        }
      }
    );
  }
  /**
   * Get a set of encoders/decoders for specific type.
   * Mainly used to define custom type de/serialization logic.
   *
   * @param type
   * @returns {TypeInterface}
   */
  getTypeInterface(type2) {
    let typeInterface = this.types.get(type2);
    if (typeof typeInterface === "string") {
      let chain2 = [];
      while (typeof typeInterface === "string") {
        if (chain2.includes(typeInterface)) {
          throw new Error(
            `Recursive definition found: ${chain2.join(
              " -> "
            )} -> ${typeInterface}`
          );
        }
        chain2.push(typeInterface);
        typeInterface = this.types.get(typeInterface);
      }
    }
    if (typeInterface === void 0) {
      throw new Error(`Type ${type2} is not registered`);
    }
    return typeInterface;
  }
  /**
   * Parse a type name and get the type's generics.
   * @example
   * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');
   * // typeName: Option
   * // typeParams: [ 'Coin<SUI>' ]
   *
   * @param name Name of the type to process
   * @returns Object with typeName and typeParams listed as Array
   */
  parseTypeName(name) {
    if (Array.isArray(name)) {
      let [typeName2, ...params2] = name;
      return { name: typeName2, params: params2 };
    }
    if (typeof name !== "string") {
      throw new Error(`Illegal type passed as a name of the type: ${name}`);
    }
    let [left, right] = this.schema.genericSeparators || ["<", ">"];
    let l_bound = name.indexOf(left);
    let r_bound = Array.from(name).reverse().indexOf(right);
    if (l_bound === -1 && r_bound === -1) {
      return { name, params: [] };
    }
    if (l_bound === -1 || r_bound === -1) {
      throw new Error(`Unclosed generic in name '${name}'`);
    }
    let typeName = name.slice(0, l_bound);
    let params = name.slice(l_bound + 1, name.length - r_bound - 1).split(",").map((e16) => e16.trim());
    return { name: typeName, params };
  }
};
var BCS2 = _BCS2;
BCS2.U8 = "u8";
BCS2.U16 = "u16";
BCS2.U32 = "u32";
BCS2.U64 = "u64";
BCS2.U128 = "u128";
BCS2.U256 = "u256";
BCS2.BOOL = "bool";
BCS2.VECTOR = "vector";
BCS2.ADDRESS = "address";
BCS2.STRING = "string";
BCS2.HEX = "hex-string";
BCS2.BASE58 = "base58-string";
BCS2.BASE64 = "base64-string";
function encodeStr2(data, encoding) {
  switch (encoding) {
    case "base58":
      return toB582(data);
    case "base64":
      return toB642(data);
    case "hex":
      return toHEX2(data);
    default:
      throw new Error(
        "Unsupported encoding, supported values are: base64, hex"
      );
  }
}
function decodeStr2(data, encoding) {
  switch (encoding) {
    case "base58":
      return fromB582(data);
    case "base64":
      return fromB642(data);
    case "hex":
      return fromHEX2(data);
    default:
      throw new Error(
        "Unsupported encoding, supported values are: base64, hex"
      );
  }
}
function registerPrimitives2(bcs3) {
  bcs3.registerType(
    BCS2.U8,
    function(writer, data) {
      return writer.write8(data);
    },
    function(reader) {
      return reader.read8();
    },
    (u8) => u8 < 256
  );
  bcs3.registerType(
    BCS2.U16,
    function(writer, data) {
      return writer.write16(data);
    },
    function(reader) {
      return reader.read16();
    },
    (u16) => u16 < 65536
  );
  bcs3.registerType(
    BCS2.U32,
    function(writer, data) {
      return writer.write32(data);
    },
    function(reader) {
      return reader.read32();
    },
    (u322) => u322 <= 4294967296n
  );
  bcs3.registerType(
    BCS2.U64,
    function(writer, data) {
      return writer.write64(data);
    },
    function(reader) {
      return reader.read64();
    }
  );
  bcs3.registerType(
    BCS2.U128,
    function(writer, data) {
      return writer.write128(data);
    },
    function(reader) {
      return reader.read128();
    }
  );
  bcs3.registerType(
    BCS2.U256,
    function(writer, data) {
      return writer.write256(data);
    },
    function(reader) {
      return reader.read256();
    }
  );
  bcs3.registerType(
    BCS2.BOOL,
    function(writer, data) {
      return writer.write8(data);
    },
    function(reader) {
      return reader.read8().toString(10) === "1";
    }
  );
  bcs3.registerType(
    BCS2.STRING,
    function(writer, data) {
      return writer.writeVec(
        Array.from(data),
        (writer2, el) => writer2.write8(el.charCodeAt(0))
      );
    },
    function(reader) {
      return reader.readVec((reader2) => reader2.read8()).map((el) => String.fromCharCode(Number(el))).join("");
    },
    (_str) => true
  );
  bcs3.registerType(
    BCS2.HEX,
    function(writer, data) {
      return writer.writeVec(
        Array.from(fromHEX2(data)),
        (writer2, el) => writer2.write8(el)
      );
    },
    function(reader) {
      let bytes2 = reader.readVec((reader2) => reader2.read8());
      return toHEX2(new Uint8Array(bytes2));
    }
  );
  bcs3.registerType(
    BCS2.BASE58,
    function(writer, data) {
      return writer.writeVec(
        Array.from(fromB582(data)),
        (writer2, el) => writer2.write8(el)
      );
    },
    function(reader) {
      let bytes2 = reader.readVec((reader2) => reader2.read8());
      return toB582(new Uint8Array(bytes2));
    }
  );
  bcs3.registerType(
    BCS2.BASE64,
    function(writer, data) {
      return writer.writeVec(
        Array.from(fromB642(data)),
        (writer2, el) => writer2.write8(el)
      );
    },
    function(reader) {
      let bytes2 = reader.readVec((reader2) => reader2.read8());
      return toB642(new Uint8Array(bytes2));
    }
  );
}
function getSuiMoveConfig2() {
  return {
    genericSeparators: ["<", ">"],
    vectorType: "vector",
    addressLength: SUI_ADDRESS_LENGTH3,
    addressEncoding: "hex"
  };
}

// node_modules/@mysten/wallet-adapter-unsafe-burner/node_modules/@mysten/sui.js/dist/index.mjs
var import_bip392 = __toESM(require_bip39(), 1);
var import_tweetnacl5 = __toESM(require_nacl_fast(), 1);
var import_browser2 = __toESM(require_browser(), 1);
var import_rpc_websockets2 = __toESM(require_index_browser(), 1);
var import_femver2 = __toESM(require_femver(), 1);
var import_tweetnacl6 = __toESM(require_nacl_fast(), 1);
var __accessCheck2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet2 = (obj, member, getter) => {
  __accessCheck2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet2 = (obj, member, value, setter) => {
  __accessCheck2(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod2 = (obj, member, method) => {
  __accessCheck2(obj, member, "access private method");
  return method;
};
var TransactionDigest2 = string();
var TransactionEffectsDigest2 = string();
var TransactionEventDigest2 = string();
var ObjectId2 = string();
var SuiAddress2 = string();
var SequenceNumber2 = string();
var ObjectOwner2 = union([
  object({
    AddressOwner: SuiAddress2
  }),
  object({
    ObjectOwner: SuiAddress2
  }),
  object({
    Shared: object({
      initial_shared_version: number2()
    })
  }),
  literal("Immutable")
]);
var SuiJsonValue2 = define2("SuiJsonValue", () => true);
var TX_DIGEST_LENGTH2 = 32;
function isValidTransactionDigest2(value) {
  try {
    const buffer = fromB582(value);
    return buffer.length === TX_DIGEST_LENGTH2;
  } catch (e16) {
    return false;
  }
}
var SUI_ADDRESS_LENGTH4 = 32;
function isValidSuiAddress2(value) {
  return isHex2(value) && getHexByteLength2(value) === SUI_ADDRESS_LENGTH4;
}
function isValidSuiObjectId2(value) {
  return isValidSuiAddress2(value);
}
function normalizeSuiAddress2(value, forceAdd0x = false) {
  let address = value.toLowerCase();
  if (!forceAdd0x && address.startsWith("0x")) {
    address = address.slice(2);
  }
  return `0x${address.padStart(SUI_ADDRESS_LENGTH4 * 2, "0")}`;
}
function normalizeSuiObjectId2(value, forceAdd0x = false) {
  return normalizeSuiAddress2(value, forceAdd0x);
}
function isHex2(value) {
  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;
}
function getHexByteLength2(value) {
  return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;
}
var ObjectType2 = union([string(), literal("package")]);
var SuiObjectRef2 = object({
  /** Base64 string representing the object digest */
  digest: TransactionDigest2,
  /** Hex code as string representing the object id */
  objectId: string(),
  /** Object version */
  version: union([number2(), string()])
});
var SuiGasData2 = object({
  payment: array(SuiObjectRef2),
  /** Gas Object's owner */
  owner: string(),
  price: string(),
  budget: string()
});
var SuiObjectInfo2 = assign(
  SuiObjectRef2,
  object({
    type: string(),
    owner: ObjectOwner2,
    previousTransaction: TransactionDigest2
  })
);
var ObjectContentFields2 = record(string(), any());
var MovePackageContent2 = record(string(), string());
var SuiMoveObject2 = object({
  /** Move type (e.g., "0x2::coin::Coin<0x2::sui::SUI>") */
  type: string(),
  /** Fields and values stored inside the Move object */
  fields: ObjectContentFields2,
  hasPublicTransfer: boolean()
});
var SuiMovePackage2 = object({
  /** A mapping from module name to disassembled Move bytecode */
  disassembled: MovePackageContent2
});
var SuiParsedData2 = union([
  assign(SuiMoveObject2, object({ dataType: literal("moveObject") })),
  assign(SuiMovePackage2, object({ dataType: literal("package") }))
]);
var SuiRawMoveObject2 = object({
  /** Move type (e.g., "0x2::coin::Coin<0x2::sui::SUI>") */
  type: string(),
  hasPublicTransfer: boolean(),
  version: SequenceNumber2,
  bcsBytes: array(number2())
});
var SuiRawMovePackage2 = object({
  id: ObjectId2,
  /** A mapping from module name to Move bytecode enocded in base64*/
  moduleMap: record(string(), string())
});
var SuiRawData2 = union([
  assign(SuiMoveObject2, object({ dataType: literal("moveObject") })),
  assign(SuiRawMovePackage2, object({ dataType: literal("package") }))
]);
var MIST_PER_SUI2 = BigInt(1e9);
var ObjectDigest2 = string();
var SuiObjectResponseError2 = object({
  code: string(),
  error: optional(string()),
  object_id: optional(ObjectId2),
  version: optional(SequenceNumber2),
  digest: optional(ObjectDigest2)
});
var DisplayFieldsResponse2 = object({
  data: nullable(record(string(), string())),
  error: nullable(SuiObjectResponseError2)
});
var DisplayFieldsBackwardCompatibleResponse2 = union([
  DisplayFieldsResponse2,
  optional(record(string(), string()))
]);
var SuiObjectData2 = object({
  objectId: ObjectId2,
  version: SequenceNumber2,
  digest: ObjectDigest2,
  /**
   * Type of the object, default to be undefined unless SuiObjectDataOptions.showType is set to true
   */
  type: optional(string()),
  /**
   * Move object content or package content, default to be undefined unless SuiObjectDataOptions.showContent is set to true
   */
  content: optional(SuiParsedData2),
  /**
   * Move object content or package content in BCS bytes, default to be undefined unless SuiObjectDataOptions.showBcs is set to true
   */
  bcs: optional(SuiRawData2),
  /**
   * The owner of this object. Default to be undefined unless SuiObjectDataOptions.showOwner is set to true
   */
  owner: optional(ObjectOwner2),
  /**
   * The digest of the transaction that created or last mutated this object.
   * Default to be undefined unless SuiObjectDataOptions.showPreviousTransaction is set to true
   */
  previousTransaction: optional(TransactionDigest2),
  /**
   * The amount of SUI we would rebate if this object gets deleted.
   * This number is re-calculated each time the object is mutated based on
   * the present storage gas price.
   * Default to be undefined unless SuiObjectDataOptions.showStorageRebate is set to true
   */
  storageRebate: optional(string()),
  /**
   * Display metadata for this object, default to be undefined unless SuiObjectDataOptions.showDisplay is set to true
   * This can also be None if the struct type does not have Display defined
   * See more details in https://forums.sui.io/t/nft-object-display-proposal/4872
   */
  display: optional(DisplayFieldsBackwardCompatibleResponse2)
});
var SuiObjectDataOptions2 = object({
  /* Whether to fetch the object type, default to be true */
  showType: optional(boolean()),
  /* Whether to fetch the object content, default to be false */
  showContent: optional(boolean()),
  /* Whether to fetch the object content in BCS bytes, default to be false */
  showBcs: optional(boolean()),
  /* Whether to fetch the object owner, default to be false */
  showOwner: optional(boolean()),
  /* Whether to fetch the previous transaction digest, default to be false */
  showPreviousTransaction: optional(boolean()),
  /* Whether to fetch the storage rebate, default to be false */
  showStorageRebate: optional(boolean()),
  /* Whether to fetch the display metadata, default to be false */
  showDisplay: optional(boolean())
});
var ObjectStatus2 = union([
  literal("Exists"),
  literal("notExists"),
  literal("Deleted")
]);
var GetOwnedObjectsResponse2 = array(SuiObjectInfo2);
var SuiObjectResponse2 = object({
  data: optional(SuiObjectData2),
  error: optional(SuiObjectResponseError2)
});
function getSuiObjectData2(resp) {
  return resp.data;
}
function getObjectDeletedResponse2(resp) {
  if (resp.error && "object_id" in resp.error && "version" in resp.error && "digest" in resp.error) {
    const error = resp.error;
    return {
      objectId: error.object_id,
      version: error.version,
      digest: error.digest
    };
  }
  return void 0;
}
function getObjectReference2(resp) {
  if ("reference" in resp) {
    return resp.reference;
  }
  const exists2 = getSuiObjectData2(resp);
  if (exists2) {
    return {
      objectId: exists2.objectId,
      version: exists2.version,
      digest: exists2.digest
    };
  }
  return getObjectDeletedResponse2(resp);
}
function getObjectOwner2(resp) {
  var _a;
  if (is(resp, ObjectOwner2)) {
    return resp;
  }
  return (_a = getSuiObjectData2(resp)) == null ? void 0 : _a.owner;
}
function getSharedObjectInitialVersion2(resp) {
  const owner = getObjectOwner2(resp);
  if (typeof owner === "object" && "Shared" in owner) {
    return owner.Shared.initial_shared_version;
  } else {
    return void 0;
  }
}
var CheckpointedObjectId2 = object({
  objectId: ObjectId2,
  atCheckpoint: optional(number2())
});
var PaginatedObjectsResponse2 = object({
  data: array(SuiObjectResponse2),
  // TODO: remove union after 0.30.0 is released
  nextCursor: union([nullable(ObjectId2), nullable(CheckpointedObjectId2)]),
  hasNextPage: boolean()
});
var EventId2 = object({
  txDigest: TransactionDigest2,
  eventSeq: SequenceNumber2
});
var SuiEvent2 = object({
  id: EventId2,
  // Move package where this event was emitted.
  packageId: ObjectId2,
  // Move module where this event was emitted.
  transactionModule: string(),
  // Sender's Sui address.
  sender: SuiAddress2,
  // Move event type.
  type: string(),
  // Parsed json value of the event
  parsedJson: optional(record(string(), any())),
  // Base 58 encoded bcs bytes of the move event
  bcs: optional(string()),
  timestampMs: optional(string())
});
var PaginatedEvents2 = object({
  data: array(SuiEvent2),
  nextCursor: nullable(EventId2),
  hasNextPage: boolean()
});
var SubscriptionId2 = number2();
var SubscriptionEvent2 = object({
  subscription: SubscriptionId2,
  result: SuiEvent2
});
var EpochId2 = string();
var SuiChangeEpoch2 = object({
  epoch: EpochId2,
  storage_charge: string(),
  computation_charge: string(),
  storage_rebate: string(),
  epoch_start_timestamp_ms: optional(string())
});
var SuiConsensusCommitPrologue2 = object({
  epoch: EpochId2,
  round: string(),
  commit_timestamp_ms: string()
});
var Genesis2 = object({
  objects: array(ObjectId2)
});
var SuiArgument2 = union([
  literal("GasCoin"),
  object({ Input: number2() }),
  object({ Result: number2() }),
  object({ NestedResult: tuple([number2(), number2()]) })
]);
var MoveCallSuiTransaction2 = object({
  arguments: optional(array(SuiArgument2)),
  type_arguments: optional(array(string())),
  package: ObjectId2,
  module: string(),
  function: string()
});
var SuiTransaction2 = union([
  object({ MoveCall: MoveCallSuiTransaction2 }),
  object({ TransferObjects: tuple([array(SuiArgument2), SuiArgument2]) }),
  object({ SplitCoins: tuple([SuiArgument2, array(SuiArgument2)]) }),
  object({ MergeCoins: tuple([SuiArgument2, array(SuiArgument2)]) }),
  object({ Publish: tuple([SuiMovePackage2, array(ObjectId2)]) }),
  object({
    Upgrade: tuple([SuiMovePackage2, array(ObjectId2), ObjectId2, SuiArgument2])
  }),
  object({ MakeMoveVec: tuple([nullable(string()), array(SuiArgument2)]) })
]);
var SuiCallArg2 = union([
  object({
    type: literal("pure"),
    valueType: optional(string()),
    value: SuiJsonValue2
  }),
  object({
    type: literal("object"),
    objectType: literal("immOrOwnedObject"),
    objectId: ObjectId2,
    version: SequenceNumber2,
    digest: ObjectDigest2
  }),
  object({
    type: literal("object"),
    objectType: literal("sharedObject"),
    objectId: ObjectId2,
    initialSharedVersion: SequenceNumber2,
    mutable: boolean()
  })
]);
var ProgrammableTransaction2 = object({
  transactions: array(SuiTransaction2),
  inputs: array(SuiCallArg2)
});
var SuiTransactionBlockKind2 = union([
  assign(SuiChangeEpoch2, object({ kind: literal("ChangeEpoch") })),
  assign(
    SuiConsensusCommitPrologue2,
    object({
      kind: literal("ConsensusCommitPrologue")
    })
  ),
  assign(Genesis2, object({ kind: literal("Genesis") })),
  assign(
    ProgrammableTransaction2,
    object({ kind: literal("ProgrammableTransaction") })
  )
]);
var SuiTransactionBlockData2 = object({
  // Eventually this will become union(literal('v1'), literal('v2'), ...)
  messageVersion: literal("v1"),
  transaction: SuiTransactionBlockKind2,
  sender: SuiAddress2,
  gasData: SuiGasData2
  // this shit is diff bw wallet and explorer
});
var AuthoritySignature2 = string();
var GenericAuthoritySignature2 = union([
  AuthoritySignature2,
  array(AuthoritySignature2)
]);
var AuthorityQuorumSignInfo2 = object({
  epoch: EpochId2,
  signature: GenericAuthoritySignature2,
  signers_map: array(number2())
});
var GasCostSummary3 = object({
  computationCost: string(),
  storageCost: string(),
  storageRebate: string(),
  nonRefundableStorageFee: string()
});
var ExecutionStatusType2 = union([
  literal("success"),
  literal("failure")
]);
var ExecutionStatus2 = object({
  status: ExecutionStatusType2,
  error: optional(string())
});
var OwnedObjectRef2 = object({
  owner: ObjectOwner2,
  reference: SuiObjectRef2
});
var TransactionEffectsModifiedAtVersions2 = object({
  objectId: ObjectId2,
  sequenceNumber: SequenceNumber2
});
var TransactionEffects2 = object({
  // Eventually this will become union(literal('v1'), literal('v2'), ...)
  messageVersion: literal("v1"),
  /** The status of the execution */
  status: ExecutionStatus2,
  /** The epoch when this transaction was executed */
  executedEpoch: EpochId2,
  /** The version that every modified (mutated or deleted) object had before it was modified by this transaction. **/
  modifiedAtVersions: optional(array(TransactionEffectsModifiedAtVersions2)),
  gasUsed: GasCostSummary3,
  /** The object references of the shared objects used in this transaction. Empty if no shared objects were used. */
  sharedObjects: optional(array(SuiObjectRef2)),
  /** The transaction digest */
  transactionDigest: TransactionDigest2,
  /** ObjectRef and owner of new objects created */
  created: optional(array(OwnedObjectRef2)),
  /** ObjectRef and owner of mutated objects, including gas object */
  mutated: optional(array(OwnedObjectRef2)),
  /**
   * ObjectRef and owner of objects that are unwrapped in this transaction.
   * Unwrapped objects are objects that were wrapped into other objects in the past,
   * and just got extracted out.
   */
  unwrapped: optional(array(OwnedObjectRef2)),
  /** Object Refs of objects now deleted (the old refs) */
  deleted: optional(array(SuiObjectRef2)),
  /** Object Refs of objects now deleted (the old refs) */
  unwrapped_then_deleted: optional(array(SuiObjectRef2)),
  /** Object refs of objects now wrapped in other objects */
  wrapped: optional(array(SuiObjectRef2)),
  /**
   * The updated gas object reference. Have a dedicated field for convenient access.
   * It's also included in mutated.
   */
  gasObject: OwnedObjectRef2,
  /** The events emitted during execution. Note that only successful transactions emit events */
  eventsDigest: optional(TransactionEventDigest2),
  /** The set of transaction digests this transaction depends on */
  dependencies: optional(array(TransactionDigest2))
});
var TransactionEvents2 = array(SuiEvent2);
var ReturnValueType2 = tuple([array(number2()), string()]);
var MutableReferenceOutputType2 = tuple([
  SuiArgument2,
  array(number2()),
  string()
]);
var ExecutionResultType2 = object({
  mutableReferenceOutputs: optional(array(MutableReferenceOutputType2)),
  returnValues: optional(array(ReturnValueType2))
});
var DevInspectResults2 = object({
  effects: TransactionEffects2,
  events: TransactionEvents2,
  results: optional(array(ExecutionResultType2)),
  error: optional(string())
});
var AuthorityName2 = string();
var SuiTransactionBlock2 = object({
  data: SuiTransactionBlockData2,
  txSignatures: array(string())
});
var SuiObjectChangePublished2 = object({
  type: literal("published"),
  packageId: ObjectId2,
  version: SequenceNumber2,
  digest: ObjectDigest2,
  modules: array(string())
});
var SuiObjectChangeTransferred2 = object({
  type: literal("transferred"),
  sender: SuiAddress2,
  recipient: ObjectOwner2,
  objectType: string(),
  objectId: ObjectId2,
  version: SequenceNumber2,
  digest: ObjectDigest2
});
var SuiObjectChangeMutated2 = object({
  type: literal("mutated"),
  sender: SuiAddress2,
  owner: ObjectOwner2,
  objectType: string(),
  objectId: ObjectId2,
  version: SequenceNumber2,
  previousVersion: SequenceNumber2,
  digest: ObjectDigest2
});
var SuiObjectChangeDeleted2 = object({
  type: literal("deleted"),
  sender: SuiAddress2,
  objectType: string(),
  objectId: ObjectId2,
  version: SequenceNumber2
});
var SuiObjectChangeWrapped2 = object({
  type: literal("wrapped"),
  sender: SuiAddress2,
  objectType: string(),
  objectId: ObjectId2,
  version: SequenceNumber2
});
var SuiObjectChangeCreated2 = object({
  type: literal("created"),
  sender: SuiAddress2,
  owner: ObjectOwner2,
  objectType: string(),
  objectId: ObjectId2,
  version: SequenceNumber2,
  digest: ObjectDigest2
});
var SuiObjectChange2 = union([
  SuiObjectChangePublished2,
  SuiObjectChangeTransferred2,
  SuiObjectChangeMutated2,
  SuiObjectChangeDeleted2,
  SuiObjectChangeWrapped2,
  SuiObjectChangeCreated2
]);
var BalanceChange2 = object({
  owner: ObjectOwner2,
  coinType: string(),
  /* Coin balance change(positive means receive, negative means send) */
  amount: string()
});
var SuiTransactionBlockResponse2 = object({
  digest: TransactionDigest2,
  transaction: optional(SuiTransactionBlock2),
  effects: optional(TransactionEffects2),
  events: optional(TransactionEvents2),
  timestampMs: optional(string()),
  checkpoint: optional(string()),
  confirmedLocalExecution: optional(boolean()),
  objectChanges: optional(array(SuiObjectChange2)),
  balanceChanges: optional(array(BalanceChange2)),
  /* Errors that occurred in fetching/serializing the transaction. */
  errors: optional(array(string()))
});
var SuiTransactionBlockResponseOptions2 = object({
  /* Whether to show transaction input data. Default to be false. */
  showInput: optional(boolean()),
  /* Whether to show transaction effects. Default to be false. */
  showEffects: optional(boolean()),
  /* Whether to show transaction events. Default to be false. */
  showEvents: optional(boolean()),
  /* Whether to show object changes. Default to be false. */
  showObjectChanges: optional(boolean()),
  /* Whether to show coin balance changes. Default to be false. */
  showBalanceChanges: optional(boolean())
});
var PaginatedTransactionResponse2 = object({
  data: array(SuiTransactionBlockResponse2),
  nextCursor: nullable(TransactionDigest2),
  hasNextPage: boolean()
});
var DryRunTransactionBlockResponse2 = object({
  effects: TransactionEffects2,
  events: TransactionEvents2,
  objectChanges: array(SuiObjectChange2),
  balanceChanges: array(BalanceChange2),
  // TODO: Remove optional when this is rolled out to all networks:
  input: optional(SuiTransactionBlockData2)
});
function getExecutionStatusGasSummary(data) {
  var _a;
  if (is(data, TransactionEffects2)) {
    return data.gasUsed;
  }
  return (_a = getTransactionEffects(data)) == null ? void 0 : _a.gasUsed;
}
function getTotalGasUsedUpperBound(data) {
  const gasSummary = getExecutionStatusGasSummary(data);
  return gasSummary ? BigInt(gasSummary.computationCost) + BigInt(gasSummary.storageCost) : void 0;
}
function getTransactionEffects(data) {
  return data.effects;
}
function getOption2(option22) {
  if (typeof option22 === "object" && option22 !== null && "type" in option22 && option22.type.startsWith("0x1::option::Option<")) {
    return void 0;
  }
  return option22;
}
var SUI_FRAMEWORK_ADDRESS2 = "0x2";
var MOVE_STDLIB_ADDRESS2 = "0x1";
var OBJECT_MODULE_NAME2 = "object";
var ID_STRUCT_NAME2 = "ID";
var SUI_TYPE_ARG2 = `${SUI_FRAMEWORK_ADDRESS2}::sui::SUI`;
var SUI_CLOCK_OBJECT_ID2 = normalizeSuiObjectId2("0x6");
var CoinMetadataStruct2 = object({
  decimals: number2(),
  name: string(),
  symbol: string(),
  description: string(),
  iconUrl: nullable(string()),
  id: nullable(ObjectId2)
});
var _Delegation2 = class {
  static isDelegationSuiObject(obj) {
    return "type" in obj && obj.type === _Delegation2.SUI_OBJECT_TYPE;
  }
  constructor(obj) {
    this.suiObject = obj;
  }
  nextRewardUnclaimedEpoch() {
    return this.suiObject.data.fields.next_reward_unclaimed_epoch;
  }
  activeDelegation() {
    return BigInt(getOption2(this.suiObject.data.fields.active_delegation) || 0);
  }
  delegateAmount() {
    return this.suiObject.data.fields.delegate_amount;
  }
  endingEpoch() {
    return getOption2(this.suiObject.data.fields.ending_epoch);
  }
  validatorAddress() {
    return this.suiObject.data.fields.validator_address;
  }
  isActive() {
    return this.activeDelegation() > 0 && !this.endingEpoch();
  }
  hasUnclaimedRewards(epoch) {
    return this.nextRewardUnclaimedEpoch() <= epoch && (this.isActive() || (this.endingEpoch() || 0) > epoch);
  }
};
var Delegation2 = _Delegation2;
Delegation2.SUI_OBJECT_TYPE = "0x2::delegation::Delegation";
var VECTOR3 = "vector";
var TransactionDataV12 = {
  kind: "TransactionKind",
  sender: BCS2.ADDRESS,
  gasData: "GasData",
  expiration: "TransactionExpiration"
};
var BCS_SPEC2 = {
  enums: {
    "Option<T>": {
      None: null,
      Some: "T"
    },
    ObjectArg: {
      ImmOrOwned: "SuiObjectRef",
      Shared: "SharedObjectRef"
    },
    CallArg: {
      Pure: [VECTOR3, BCS2.U8],
      Object: "ObjectArg",
      ObjVec: [VECTOR3, "ObjectArg"]
    },
    TypeTag: {
      bool: null,
      u8: null,
      u64: null,
      u128: null,
      address: null,
      signer: null,
      vector: "TypeTag",
      struct: "StructTag",
      u16: null,
      u32: null,
      u256: null
    },
    TransactionKind: {
      // can not be called from sui.js; dummy placement
      // to set the enum counter right for ProgrammableTransact
      ProgrammableTransaction: "ProgrammableTransaction",
      ChangeEpoch: null,
      Genesis: null,
      ConsensusCommitPrologue: null
    },
    TransactionExpiration: {
      None: null,
      Epoch: BCS2.U64
    },
    TransactionData: {
      V1: "TransactionDataV1"
    }
  },
  structs: {
    SuiObjectRef: {
      objectId: BCS2.ADDRESS,
      version: BCS2.U64,
      digest: "ObjectDigest"
    },
    SharedObjectRef: {
      objectId: BCS2.ADDRESS,
      initialSharedVersion: BCS2.U64,
      mutable: BCS2.BOOL
    },
    StructTag: {
      address: BCS2.ADDRESS,
      module: BCS2.STRING,
      name: BCS2.STRING,
      typeParams: [VECTOR3, "TypeTag"]
    },
    GasData: {
      payment: [VECTOR3, "SuiObjectRef"],
      owner: BCS2.ADDRESS,
      price: BCS2.U64,
      budget: BCS2.U64
    },
    // Signed transaction data needed to generate transaction digest.
    SenderSignedData: {
      data: "TransactionData",
      txSignatures: [VECTOR3, [VECTOR3, BCS2.U8]]
    },
    TransactionDataV1: TransactionDataV12
  },
  aliases: {
    ObjectDigest: BCS2.BASE58
  }
};
var bcs2 = new BCS2({ ...getSuiMoveConfig2(), types: BCS_SPEC2 });
bcs2.registerType(
  "utf8string",
  (writer, str) => {
    const bytes2 = Array.from(new TextEncoder().encode(str));
    return writer.writeVec(bytes2, (writer2, el) => writer2.write8(el));
  },
  (reader) => {
    let bytes2 = reader.readVec((reader2) => reader2.read8());
    return new TextDecoder().decode(new Uint8Array(bytes2));
  }
);
var FaucetCoinInfo2 = object({
  amount: number2(),
  id: ObjectId2,
  transferTxDigest: TransactionDigest2
});
var FaucetResponse2 = object({
  transferredGasObjects: array(FaucetCoinInfo2),
  error: nullable(string())
});
var SuiMoveFunctionArgType2 = union([
  string(),
  object({ Object: string() })
]);
var SuiMoveFunctionArgTypes2 = array(SuiMoveFunctionArgType2);
var SuiMoveModuleId2 = object({
  address: string(),
  name: string()
});
var SuiMoveVisibility2 = union([
  literal("Private"),
  literal("Public"),
  literal("Friend")
]);
var SuiMoveAbilitySet2 = object({
  abilities: array(string())
});
var SuiMoveStructTypeParameter2 = object({
  constraints: SuiMoveAbilitySet2,
  isPhantom: boolean()
});
var SuiMoveNormalizedTypeParameterType2 = object({
  TypeParameter: number2()
});
function isSuiMoveNormalizedType2(value) {
  if (!value)
    return false;
  if (typeof value === "string")
    return true;
  if (is(value, SuiMoveNormalizedTypeParameterType2))
    return true;
  if (isSuiMoveNormalizedStructType2(value))
    return true;
  if (typeof value !== "object")
    return false;
  const valueProperties = value;
  if (is(valueProperties.Reference, SuiMoveNormalizedType2))
    return true;
  if (is(valueProperties.MutableReference, SuiMoveNormalizedType2))
    return true;
  if (is(valueProperties.Vector, SuiMoveNormalizedType2))
    return true;
  return false;
}
var SuiMoveNormalizedType2 = define2(
  "SuiMoveNormalizedType",
  isSuiMoveNormalizedType2
);
function isSuiMoveNormalizedStructType2(value) {
  if (!value || typeof value !== "object")
    return false;
  const valueProperties = value;
  if (!valueProperties.Struct || typeof valueProperties.Struct !== "object")
    return false;
  const structProperties = valueProperties.Struct;
  if (typeof structProperties.address !== "string" || typeof structProperties.module !== "string" || typeof structProperties.name !== "string" || !Array.isArray(structProperties.typeArguments) || !structProperties.typeArguments.every(
    (value2) => isSuiMoveNormalizedType2(value2)
  )) {
    return false;
  }
  return true;
}
var SuiMoveNormalizedStructType2 = define2(
  "SuiMoveNormalizedStructType",
  isSuiMoveNormalizedStructType2
);
var SuiMoveNormalizedFunction2 = object({
  visibility: SuiMoveVisibility2,
  isEntry: boolean(),
  typeParameters: array(SuiMoveAbilitySet2),
  parameters: array(SuiMoveNormalizedType2),
  return: array(SuiMoveNormalizedType2)
});
var SuiMoveNormalizedField2 = object({
  name: string(),
  type: SuiMoveNormalizedType2
});
var SuiMoveNormalizedStruct2 = object({
  abilities: SuiMoveAbilitySet2,
  typeParameters: array(SuiMoveStructTypeParameter2),
  fields: array(SuiMoveNormalizedField2)
});
var SuiMoveNormalizedModule2 = object({
  fileFormatVersion: number2(),
  address: string(),
  name: string(),
  friends: array(SuiMoveModuleId2),
  structs: record(string(), SuiMoveNormalizedStruct2),
  exposedFunctions: record(string(), SuiMoveNormalizedFunction2)
});
var SuiMoveNormalizedModules2 = record(
  string(),
  SuiMoveNormalizedModule2
);
function extractMutableReference2(normalizedType) {
  return typeof normalizedType === "object" && "MutableReference" in normalizedType ? normalizedType.MutableReference : void 0;
}
function extractReference2(normalizedType) {
  return typeof normalizedType === "object" && "Reference" in normalizedType ? normalizedType.Reference : void 0;
}
function extractStructTag2(normalizedType) {
  if (typeof normalizedType === "object" && "Struct" in normalizedType) {
    return normalizedType;
  }
  const ref = extractReference2(normalizedType);
  const mutRef = extractMutableReference2(normalizedType);
  if (typeof ref === "object" && "Struct" in ref) {
    return ref;
  }
  if (typeof mutRef === "object" && "Struct" in mutRef) {
    return mutRef;
  }
  return void 0;
}
var Balance2 = object({
  value: number2()
});
var StakeObject2 = object({
  stakedSuiId: ObjectId2,
  stakeRequestEpoch: EpochId2,
  stakeActiveEpoch: EpochId2,
  principal: string(),
  status: union([literal("Active"), literal("Pending"), literal("Unstaked")]),
  estimatedReward: optional(string())
});
var DelegatedStake2 = object({
  validatorAddress: SuiAddress2,
  stakingPool: ObjectId2,
  stakes: array(StakeObject2)
});
var StakeSubsidyFields2 = object({
  balance: object({ value: number2() }),
  distribution_counter: number2(),
  current_distribution_amount: number2(),
  stake_subsidy_period_length: number2(),
  stake_subsidy_decrease_rate: number2()
});
var StakeSubsidy2 = object({
  type: string(),
  fields: StakeSubsidyFields2
});
var SuiSupplyFields2 = object({
  value: number2()
});
var ContentsFields2 = object({
  id: string(),
  size: number2(),
  head: object({ vec: array() }),
  tail: object({ vec: array() })
});
var ContentsFieldsWithdraw2 = object({
  id: string(),
  size: number2()
});
var Contents2 = object({
  type: string(),
  fields: ContentsFields2
});
var DelegationStakingPoolFields2 = object({
  exchangeRates: object({
    id: string(),
    size: number2()
  }),
  id: string(),
  pendingStake: number2(),
  pendingPoolTokenWithdraw: number2(),
  pendingTotalSuiWithdraw: number2(),
  poolTokenBalance: number2(),
  rewardsPool: object({ value: number2() }),
  activationEpoch: object({ vec: array() }),
  deactivationEpoch: object({ vec: array() }),
  suiBalance: number2()
});
var DelegationStakingPool2 = object({
  type: string(),
  fields: DelegationStakingPoolFields2
});
var Validators2 = array(tuple([AuthorityName2, string()]));
var CommitteeInfo2 = object({
  epoch: EpochId2,
  /** Array of (validator public key, stake unit) tuple */
  validators: Validators2
});
var SuiValidatorSummary2 = object({
  suiAddress: SuiAddress2,
  protocolPubkeyBytes: string(),
  networkPubkeyBytes: string(),
  workerPubkeyBytes: string(),
  proofOfPossessionBytes: string(),
  operationCapId: string(),
  name: string(),
  description: string(),
  imageUrl: string(),
  projectUrl: string(),
  p2pAddress: string(),
  netAddress: string(),
  primaryAddress: string(),
  workerAddress: string(),
  nextEpochProtocolPubkeyBytes: nullable(string()),
  nextEpochProofOfPossession: nullable(string()),
  nextEpochNetworkPubkeyBytes: nullable(string()),
  nextEpochWorkerPubkeyBytes: nullable(string()),
  nextEpochNetAddress: nullable(string()),
  nextEpochP2pAddress: nullable(string()),
  nextEpochPrimaryAddress: nullable(string()),
  nextEpochWorkerAddress: nullable(string()),
  votingPower: string(),
  gasPrice: string(),
  commissionRate: string(),
  nextEpochStake: string(),
  nextEpochGasPrice: string(),
  nextEpochCommissionRate: string(),
  stakingPoolId: string(),
  stakingPoolActivationEpoch: nullable(string()),
  stakingPoolDeactivationEpoch: nullable(string()),
  stakingPoolSuiBalance: string(),
  rewardsPool: string(),
  poolTokenBalance: string(),
  pendingStake: string(),
  pendingPoolTokenWithdraw: string(),
  pendingTotalSuiWithdraw: string(),
  exchangeRatesId: string(),
  exchangeRatesSize: string()
});
var SuiSystemStateSummary2 = object({
  epoch: string(),
  protocolVersion: string(),
  systemStateVersion: string(),
  storageFundTotalObjectStorageRebates: string(),
  storageFundNonRefundableBalance: string(),
  referenceGasPrice: string(),
  safeMode: boolean(),
  safeModeStorageRewards: string(),
  safeModeComputationRewards: string(),
  safeModeStorageRebates: string(),
  safeModeNonRefundableStorageFee: string(),
  epochStartTimestampMs: string(),
  epochDurationMs: string(),
  stakeSubsidyStartEpoch: string(),
  maxValidatorCount: string(),
  minValidatorJoiningStake: string(),
  validatorLowStakeThreshold: string(),
  validatorVeryLowStakeThreshold: string(),
  validatorLowStakeGracePeriod: string(),
  stakeSubsidyBalance: string(),
  stakeSubsidyDistributionCounter: string(),
  stakeSubsidyCurrentDistributionAmount: string(),
  stakeSubsidyPeriodLength: string(),
  stakeSubsidyDecreaseRate: number2(),
  totalStake: string(),
  activeValidators: array(SuiValidatorSummary2),
  pendingActiveValidatorsId: string(),
  pendingActiveValidatorsSize: string(),
  pendingRemovals: array(string()),
  stakingPoolMappingsId: string(),
  stakingPoolMappingsSize: string(),
  inactivePoolsId: string(),
  inactivePoolsSize: string(),
  validatorCandidatesId: string(),
  validatorCandidatesSize: string(),
  atRiskValidators: array(tuple([SuiAddress2, string()])),
  validatorReportRecords: array(tuple([SuiAddress2, array(SuiAddress2)]))
});
var CoinStruct2 = object({
  coinType: string(),
  // TODO(chris): rename this to objectId
  coinObjectId: ObjectId2,
  version: string(),
  digest: TransactionDigest2,
  balance: string(),
  lockedUntilEpoch: nullable(number2()),
  previousTransaction: TransactionDigest2
});
var PaginatedCoins2 = object({
  data: array(CoinStruct2),
  nextCursor: nullable(ObjectId2),
  hasNextPage: boolean()
});
var CoinBalance2 = object({
  coinType: string(),
  coinObjectCount: number2(),
  totalBalance: string(),
  lockedBalance: object({
    epochId: optional(number2()),
    number: optional(number2())
  })
});
var CoinSupply2 = object({
  value: string()
});
var GasCostSummary22 = object({
  computationCost: string(),
  storageCost: string(),
  storageRebate: string(),
  nonRefundableStorageFee: string()
});
var CheckPointContentsDigest2 = string();
var CheckpointDigest2 = string();
var ECMHLiveObjectSetDigest2 = object({
  digest: array(number2())
});
var CheckpointCommitment2 = any();
var ValidatorSignature2 = string();
var EndOfEpochData2 = object({
  nextEpochCommittee: array(tuple([string(), string()])),
  nextEpochProtocolVersion: string(),
  epochCommitments: array(CheckpointCommitment2)
});
var ExecutionDigests2 = object({
  transaction: TransactionDigest2,
  effects: TransactionEffectsDigest2
});
var Checkpoint2 = object({
  epoch: string(),
  sequenceNumber: string(),
  digest: CheckpointDigest2,
  networkTotalTransactions: string(),
  previousDigest: optional(CheckpointDigest2),
  epochRollingGasCostSummary: GasCostSummary22,
  timestampMs: string(),
  endOfEpochData: optional(EndOfEpochData2),
  // TODO(jian): remove optional after 0.30.0 is released
  validatorSignature: optional(ValidatorSignature2),
  transactions: array(TransactionDigest2),
  checkpointCommitments: array(CheckpointCommitment2)
});
var CheckpointPage2 = object({
  data: array(Checkpoint2),
  nextCursor: nullable(string()),
  hasNextPage: boolean()
});
var SIGNATURE_SCHEME_TO_FLAG2 = {
  ED25519: 0,
  Secp256k1: 1
};
function toSerializedSignature({
  signature,
  signatureScheme,
  pubKey
}) {
  const serializedSignature = new Uint8Array(
    1 + signature.length + pubKey.toBytes().length
  );
  serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG2[signatureScheme]]);
  serializedSignature.set(signature, 1);
  serializedSignature.set(pubKey.toBytes(), 1 + signature.length);
  return toB642(serializedSignature);
}
var PUBLIC_KEY_SIZE2 = 32;
var Ed25519PublicKey2 = class {
  /**
   * Create a new Ed25519PublicKey object
   * @param value ed25519 public key as buffer or base-64 encoded string
   */
  constructor(value) {
    if (typeof value === "string") {
      this.data = fromB642(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== PUBLIC_KEY_SIZE2) {
      throw new Error(
        `Invalid public key input. Expected ${PUBLIC_KEY_SIZE2} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Ed25519 public keys are equal
   */
  equals(publicKey) {
    return bytesEqual2(this.toBytes(), publicKey.toBytes());
  }
  /**
   * Return the base-64 representation of the Ed25519 public key
   */
  toBase64() {
    return toB642(this.toBytes());
  }
  /**
   * Return the byte array representation of the Ed25519 public key
   */
  toBytes() {
    return this.data;
  }
  /**
   * Return the base-64 representation of the Ed25519 public key
   */
  toString() {
    return this.toBase64();
  }
  /**
   * Return the Sui address associated with this Ed25519 public key
   */
  toSuiAddress() {
    let tmp = new Uint8Array(PUBLIC_KEY_SIZE2 + 1);
    tmp.set([SIGNATURE_SCHEME_TO_FLAG2["ED25519"]]);
    tmp.set(this.toBytes(), 1);
    return normalizeSuiAddress2(
      bytesToHex(blake2b(tmp, { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH4 * 2)
    );
  }
};
Ed25519PublicKey2.SIZE = PUBLIC_KEY_SIZE2;
function bytesEqual2(a10, b5) {
  if (a10 === b5)
    return true;
  if (a10.length !== b5.length) {
    return false;
  }
  for (let i17 = 0; i17 < a10.length; i17++) {
    if (a10[i17] !== b5[i17]) {
      return false;
    }
  }
  return true;
}
var SECP256K1_PUBLIC_KEY_SIZE2 = 33;
var Secp256k1PublicKey2 = class {
  /**
   * Create a new Secp256k1PublicKey object
   * @param value secp256k1 public key as buffer or base-64 encoded string
   */
  constructor(value) {
    if (typeof value === "string") {
      this.data = fromB642(value);
    } else if (value instanceof Uint8Array) {
      this.data = value;
    } else {
      this.data = Uint8Array.from(value);
    }
    if (this.data.length !== SECP256K1_PUBLIC_KEY_SIZE2) {
      throw new Error(
        `Invalid public key input. Expected ${SECP256K1_PUBLIC_KEY_SIZE2} bytes, got ${this.data.length}`
      );
    }
  }
  /**
   * Checks if two Secp256k1 public keys are equal
   */
  equals(publicKey) {
    return bytesEqual2(this.toBytes(), publicKey.toBytes());
  }
  /**
   * Return the base-64 representation of the Secp256k1 public key
   */
  toBase64() {
    return toB642(this.toBytes());
  }
  /**
   * Return the byte array representation of the Secp256k1 public key
   */
  toBytes() {
    return this.data;
  }
  /**
   * Return the base-64 representation of the Secp256k1 public key
   */
  toString() {
    return this.toBase64();
  }
  /**
   * Return the Sui address associated with this Secp256k1 public key
   */
  toSuiAddress() {
    let tmp = new Uint8Array(SECP256K1_PUBLIC_KEY_SIZE2 + 1);
    tmp.set([SIGNATURE_SCHEME_TO_FLAG2["Secp256k1"]]);
    tmp.set(this.toBytes(), 1);
    return normalizeSuiAddress2(
      bytesToHex(blake2b(tmp, { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH4 * 2)
    );
  }
};
Secp256k1PublicKey2.SIZE = SECP256K1_PUBLIC_KEY_SIZE2;
function isValidHardenedPath(path) {
  if (!new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(path)) {
    return false;
  }
  return true;
}
function mnemonicToSeed(mnemonics) {
  return (0, import_bip392.mnemonicToSeedSync)(mnemonics, "");
}
function mnemonicToSeedHex(mnemonics) {
  return toHEX2(mnemonicToSeed(mnemonics));
}
var PRIVATE_KEY_SIZE = 32;
var ED25519_CURVE = "ed25519 seed";
var HARDENED_OFFSET = 2147483648;
var pathRegex2 = new RegExp("^m(\\/[0-9]+')+$");
var replaceDerive = (val) => val.replace("'", "");
var getMasterKeyFromSeed = (seed) => {
  const h7 = hmac.create(sha512, ED25519_CURVE);
  const I6 = h7.update(fromHEX2(seed)).digest();
  const IL = I6.slice(0, 32);
  const IR = I6.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var CKDPriv = ({ key, chainCode }, index) => {
  const indexBuffer = new ArrayBuffer(4);
  const cv = new DataView(indexBuffer);
  cv.setUint32(0, index);
  const data = new Uint8Array(1 + key.length + indexBuffer.byteLength);
  data.set(new Uint8Array(1).fill(0));
  data.set(key, 1);
  data.set(
    new Uint8Array(indexBuffer, 0, indexBuffer.byteLength),
    key.length + 1
  );
  const I6 = hmac.create(sha512, chainCode).update(data).digest();
  const IL = I6.slice(0, 32);
  const IR = I6.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var isValidPath = (path) => {
  if (!pathRegex2.test(path)) {
    return false;
  }
  return !path.split("/").slice(1).map(replaceDerive).some(
    isNaN
    /* ts T_T*/
  );
};
var derivePath = (path, seed, offset = HARDENED_OFFSET) => {
  if (!isValidPath(path)) {
    throw new Error("Invalid derivation path");
  }
  const { key, chainCode } = getMasterKeyFromSeed(seed);
  const segments = path.split("/").slice(1).map(replaceDerive).map((el) => parseInt(el, 10));
  return segments.reduce(
    (parentKeys, segment) => CKDPriv(parentKeys, segment + offset),
    { key, chainCode }
  );
};
var DEFAULT_ED25519_DERIVATION_PATH = "m/44'/784'/0'/0'/0'";
var Ed25519Keypair = class {
  /**
   * Create a new Ed25519 keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param keypair Ed25519 keypair
   */
  constructor(keypair) {
    if (keypair) {
      this.keypair = keypair;
    } else {
      this.keypair = import_tweetnacl4.default.sign.keyPair();
    }
  }
  /**
   * Get the key scheme of the keypair ED25519
   */
  getKeyScheme() {
    return "ED25519";
  }
  /**
   * Generate a new random Ed25519 keypair
   */
  static generate() {
    return new Ed25519Keypair(import_tweetnacl4.default.sign.keyPair());
  }
  /**
   * Create a Ed25519 keypair from a raw secret key byte array, also known as seed.
   * This is NOT the private scalar which is result of hashing and bit clamping of
   * the raw secret key.
   *
   * The sui.keystore key is a list of Base64 encoded `flag || privkey`. To import
   * a key from sui.keystore to typescript, decode from base64 and remove the first
   * flag byte after checking it is indeed the Ed25519 scheme flag 0x00 (See more
   * on flag for signature scheme: https://github.com/MystenLabs/sui/blob/818406c5abdf7de1b80915a0519071eec3a5b1c7/crates/sui-types/src/crypto.rs#L1650):
   * ```
   * import { Ed25519Keypair, fromB64 } from '@mysten/sui.js';
   * const raw = fromB64(t[1]);
   * if (raw[0] !== 0 || raw.length !== PRIVATE_KEY_SIZE + 1) {
   *   throw new Error('invalid key');
   * }
   * const imported = Ed25519Keypair.fromSecretKey(raw.slice(1))
   * ```
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key byte array
   * @param options: skip secret key validation
   */
  static fromSecretKey(secretKey, options) {
    const secretKeyLength = secretKey.length;
    if (secretKeyLength !== PRIVATE_KEY_SIZE) {
      throw new Error(
        `Wrong secretKey size. Expected ${PRIVATE_KEY_SIZE} bytes, got ${secretKeyLength}.`
      );
    }
    const keypair = import_tweetnacl4.default.sign.keyPair.fromSeed(secretKey);
    if (!options || !options.skipValidation) {
      const encoder = new TextEncoder();
      const signData = encoder.encode("sui validation");
      const signature = import_tweetnacl4.default.sign.detached(signData, keypair.secretKey);
      if (!import_tweetnacl4.default.sign.detached.verify(signData, signature, keypair.publicKey)) {
        throw new Error("provided secretKey is invalid");
      }
    }
    return new Ed25519Keypair(keypair);
  }
  /**
   * The public key for this Ed25519 keypair
   */
  getPublicKey() {
    return new Ed25519PublicKey2(this.keypair.publicKey);
  }
  /**
   * Return the signature for the provided data using Ed25519.
   */
  signData(data) {
    return import_tweetnacl4.default.sign.detached(data, this.keypair.secretKey);
  }
  /**
   * Derive Ed25519 keypair from mnemonics and path. The mnemonics must be normalized
   * and validated against the english wordlist.
   *
   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must
   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.
   */
  static deriveKeypair(mnemonics, path) {
    if (path == null) {
      path = DEFAULT_ED25519_DERIVATION_PATH;
    }
    if (!isValidHardenedPath(path)) {
      throw new Error("Invalid derivation path");
    }
    const { key } = derivePath(path, mnemonicToSeedHex(mnemonics));
    return Ed25519Keypair.fromSecretKey(key);
  }
  /**
   * This returns an exported keypair object, the private key field is the pure 32-byte seed.
   */
  export() {
    return {
      schema: "ED25519",
      privateKey: toB642(this.keypair.secretKey.slice(0, PRIVATE_KEY_SIZE))
    };
  }
};
var PACKAGE_VERSION2 = "0.0.0-experimental-20230418011747";
var TARGETED_RPC_VERSION2 = "0.33.0";
var RPCError2 = class extends Error {
  constructor(options) {
    super("RPC Error", { cause: options.cause });
    this.req = options.req;
    this.code = options.code;
    this.data = options.data;
  }
};
var RPCValidationError2 = class extends Error {
  constructor(options) {
    super(
      "RPC Validation Error: The response returned from RPC server does not match the TypeScript definition. This is likely because the SDK version is not compatible with the RPC server.",
      { cause: options.cause }
    );
    this.req = options.req;
    this.result = options.result;
    this.message = this.toString();
  }
  toString() {
    let str = super.toString();
    if (this.cause) {
      str += `
Cause: ${this.cause}`;
    }
    if (this.result) {
      str += `
Reponse Received: ${JSON.stringify(this.result, null, 2)}`;
    }
    return str;
  }
};
var FaucetRateLimitError2 = class extends Error {
};
var ValidResponse2 = object({
  jsonrpc: literal("2.0"),
  id: string(),
  result: any()
});
var ErrorResponse2 = object({
  jsonrpc: literal("2.0"),
  id: string(),
  error: object({
    code: any(),
    message: string(),
    data: optional(any())
  })
});
var JsonRpcClient2 = class {
  constructor(url, httpHeaders) {
    this.rpcClient = new import_browser2.default(
      async (request, callback) => {
        const options = {
          method: "POST",
          body: request,
          headers: {
            "Content-Type": "application/json",
            "Client-Sdk-Type": "typescript",
            "Client-Sdk-Version": PACKAGE_VERSION2,
            "Client-Target-Api-Version": TARGETED_RPC_VERSION2,
            ...httpHeaders
          }
        };
        try {
          let res = await fetch(url, options);
          const result = await res.text();
          if (res.ok) {
            callback(null, result);
          } else {
            const isHtml = res.headers.get("content-type") === "text/html";
            callback(
              new Error(
                `${res.status} ${res.statusText}${isHtml ? "" : `: ${result}`}`
              )
            );
          }
        } catch (err) {
          callback(err);
        }
      },
      {}
    );
  }
  async requestWithType(method, args, struct) {
    const req = { method, args };
    const response = await this.request(method, args);
    if (is(response, ErrorResponse2)) {
      throw new RPCError2({
        req,
        code: response.error.code,
        data: response.error.data,
        cause: new Error(response.error.message)
      });
    } else if (is(response, ValidResponse2)) {
      const [err] = validate(response.result, struct);
      if (err) {
        console.warn(
          new RPCValidationError2({
            req,
            result: response.result,
            cause: err
          })
        );
        return response.result;
      }
      return response.result;
    }
    throw new RPCError2({ req, data: response });
  }
  async request(method, args) {
    return new Promise((resolve, reject) => {
      this.rpcClient.request(method, args, (err, response) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  }
};
var DynamicFieldType2 = union([
  literal("DynamicField"),
  literal("DynamicObject")
]);
var DynamicFieldName2 = object({
  type: string(),
  value: any()
});
var DynamicFieldInfo2 = object({
  name: DynamicFieldName2,
  bcsName: string(),
  type: DynamicFieldType2,
  objectType: string(),
  objectId: ObjectId2,
  version: number2(),
  digest: string()
});
var DynamicFieldPage2 = object({
  data: array(DynamicFieldInfo2),
  nextCursor: nullable(ObjectId2),
  hasNextPage: boolean()
});
var getWebsocketUrl2 = (httpUrl, port) => {
  const url = new URL(httpUrl);
  url.protocol = url.protocol.replace("http", "ws");
  if (port) {
    url.port = port.toString();
  }
  return url.toString();
};
var isMinimumSubscriptionMessage2 = (msg) => msg && "subscription" in msg && typeof msg["subscription"] === "number" && "result" in msg && typeof msg["result"] === "object";
var DEFAULT_CLIENT_OPTIONS2 = {
  connectTimeout: 15e3,
  callTimeout: 3e4,
  reconnectInterval: 3e3,
  maxReconnects: 5
};
var SUBSCRIBE_EVENT_METHOD2 = "suix_subscribeEvent";
var UNSUBSCRIBE_EVENT_METHOD2 = "suix_unsubscribeEvent";
var WebsocketClient2 = class {
  /**
   * @param endpoint Sui node endpoint to connect to (accepts websocket & http)
   * @param options Configuration options, such as timeouts & connection behavior
   */
  constructor(endpoint, options = DEFAULT_CLIENT_OPTIONS2) {
    this.endpoint = endpoint;
    this.options = options;
    this.connectionState = 0;
    this.connectionTimeout = null;
    this.isSetup = false;
    this.connectionPromise = null;
    this.eventSubscriptions = /* @__PURE__ */ new Map();
    if (this.endpoint.startsWith("http"))
      this.endpoint = getWebsocketUrl2(this.endpoint);
    this.rpcClient = new import_rpc_websockets2.Client(this.endpoint, {
      reconnect_interval: this.options.reconnectInterval,
      max_reconnects: this.options.maxReconnects,
      autoconnect: false
    });
  }
  setupSocket() {
    if (this.isSetup)
      return;
    this.rpcClient.on("open", () => {
      if (this.connectionTimeout) {
        clearTimeout(this.connectionTimeout);
        this.connectionTimeout = null;
      }
      this.connectionState = 2;
      this.rpcClient.socket.on(
        "message",
        this.onSocketMessage.bind(this)
      );
    });
    this.rpcClient.on("close", () => {
      this.connectionState = 0;
    });
    this.rpcClient.on("error", console.error);
    this.isSetup = true;
  }
  // called for every message received from the node over websocket
  onSocketMessage(rawMessage) {
    const msg = JSON.parse(rawMessage);
    const params = msg.params;
    if (msg.method === SUBSCRIBE_EVENT_METHOD2) {
      if (isMinimumSubscriptionMessage2(params)) {
        const sub = this.eventSubscriptions.get(params.subscription);
        if (sub)
          sub.onMessage(params.result);
      } else if (is(params, SubscriptionEvent2)) {
        const sub = this.eventSubscriptions.get(params.subscription);
        if (sub)
          sub.onMessage(params.result);
      }
    }
  }
  async connect() {
    if (this.connectionPromise)
      return this.connectionPromise;
    if (this.connectionState === 2)
      return Promise.resolve();
    this.setupSocket();
    this.rpcClient.connect();
    this.connectionState = 1;
    this.connectionPromise = new Promise((resolve, reject) => {
      this.connectionTimeout = setTimeout(
        () => reject(new Error("timeout")),
        this.options.connectTimeout
      );
      this.rpcClient.once("open", () => {
        this.refreshSubscriptions();
        this.connectionPromise = null;
        resolve();
      });
      this.rpcClient.once("error", (err) => {
        this.connectionPromise = null;
        reject(err);
      });
    });
    return this.connectionPromise;
  }
  /**
    call only upon reconnecting to a node over websocket.
    calling multiple times on the same connection will result
    in multiple message handlers firing each time
  */
  async refreshSubscriptions() {
    if (this.eventSubscriptions.size === 0)
      return;
    try {
      let newSubs = /* @__PURE__ */ new Map();
      let newSubsArr = await Promise.all(
        Array.from(this.eventSubscriptions.values()).map(async (sub) => {
          const onMessage = sub.onMessage;
          const filter = sub.filter;
          if (!filter || !onMessage)
            return Promise.resolve(null);
          const id = await this.subscribeEvent(filter, onMessage);
          return { id, onMessage, filter };
        })
      );
      newSubsArr.forEach((entry) => {
        if (entry === null)
          return;
        const filter = entry.filter;
        const onMessage = entry.onMessage;
        newSubs.set(entry.id, { filter, onMessage });
      });
      this.eventSubscriptions = newSubs;
    } catch (err) {
      throw new Error(`error refreshing event subscriptions: ${err}`);
    }
  }
  async subscribeEvent(filter, onMessage) {
    try {
      if (this.connectionState !== 2)
        await this.connect();
      let subId = await this.rpcClient.call(
        SUBSCRIBE_EVENT_METHOD2,
        [filter],
        this.options.callTimeout
      );
      this.eventSubscriptions.set(subId, { filter, onMessage });
      return subId;
    } catch (err) {
      throw new Error(
        `Error subscribing to event: ${JSON.stringify(
          err,
          null,
          2
        )}, filter: ${JSON.stringify(filter)}`
      );
    }
  }
  async unsubscribeEvent(id) {
    try {
      if (this.connectionState !== 2)
        await this.connect();
      let removedOnNode = await this.rpcClient.call(
        UNSUBSCRIBE_EVENT_METHOD2,
        [id],
        this.options.callTimeout
      );
      return this.eventSubscriptions.delete(id) || removedOnNode;
    } catch (err) {
      throw new Error(
        `Error unsubscribing from event: ${err}, subscription: ${id}`
      );
    }
  }
};
async function requestSuiFromFaucet2(endpoint, recipient, httpHeaders) {
  const res = await fetch(endpoint, {
    method: "POST",
    body: JSON.stringify({
      FixedAmountRequest: {
        recipient
      }
    }),
    headers: {
      "Content-Type": "application/json",
      ...httpHeaders || {}
    }
  });
  if (res.status === 429) {
    throw new FaucetRateLimitError2(
      `Too many requests from this client have been sent to the faucet. Please retry later`
    );
  }
  let parsed;
  try {
    parsed = await res.json();
  } catch (e16) {
    throw new Error(
      `Encountered error when parsing response from faucet, error: ${e16}, status ${res.status}, response ${res}`
    );
  }
  if (parsed.error) {
    throw new Error(`Faucet returns error: ${parsed.error}`);
  }
  return parsed;
}
var _options2;
var Connection2 = class {
  constructor(options) {
    __privateAdd2(this, _options2, void 0);
    __privateSet2(this, _options2, options);
  }
  get fullnode() {
    return __privateGet2(this, _options2).fullnode;
  }
  // TODO: Decide if we should default the websocket URL like this:
  get websocket() {
    return __privateGet2(this, _options2).websocket || __privateGet2(this, _options2).fullnode;
  }
  get faucet() {
    return __privateGet2(this, _options2).faucet;
  }
};
_options2 = /* @__PURE__ */ new WeakMap();
var localnetConnection2 = new Connection2({
  fullnode: "http://127.0.0.1:9000",
  faucet: "http://127.0.0.1:9123/gas"
});
var devnetConnection2 = new Connection2({
  fullnode: "https://fullnode.devnet.sui.io:443/",
  faucet: "https://faucet.devnet.sui.io/gas"
});
var testnetConnection2 = new Connection2({
  fullnode: "https://fullnode.testnet.sui.io:443/",
  faucet: "https://faucet.testnet.sui.io/gas"
});
function create3(value, struct) {
  return create(value, struct);
}
var TRANSACTION_TYPE2 = Symbol("transaction-argument-type");
var option2 = (some) => union([object({ None: literal(null) }), object({ Some: some })]);
var TransactionBlockInput2 = object({
  kind: literal("Input"),
  index: integer(),
  value: optional(any()),
  type: optional(union([literal("pure"), literal("object")]))
});
var TransactionArgumentTypes2 = [
  TransactionBlockInput2,
  object({ kind: literal("GasCoin") }),
  object({ kind: literal("Result"), index: integer() }),
  object({
    kind: literal("NestedResult"),
    index: integer(),
    resultIndex: integer()
  })
];
var TransactionArgument2 = union([...TransactionArgumentTypes2]);
var ObjectTransactionArgument2 = union([...TransactionArgumentTypes2]);
ObjectTransactionArgument2[TRANSACTION_TYPE2] = {
  kind: "object"
};
var PureTransactionArgument2 = (type2) => {
  const struct = union([...TransactionArgumentTypes2]);
  struct[TRANSACTION_TYPE2] = {
    kind: "pure",
    type: type2
  };
  return struct;
};
var MoveCallTransaction2 = object({
  kind: literal("MoveCall"),
  target: define2(
    "target",
    string().validator
  ),
  typeArguments: array(string()),
  arguments: array(TransactionArgument2)
});
var TransferObjectsTransaction2 = object({
  kind: literal("TransferObjects"),
  objects: array(ObjectTransactionArgument2),
  address: PureTransactionArgument2(BCS2.ADDRESS)
});
var SplitCoinsTransaction2 = object({
  kind: literal("SplitCoins"),
  coin: ObjectTransactionArgument2,
  amounts: array(PureTransactionArgument2("u64"))
});
var MergeCoinsTransaction2 = object({
  kind: literal("MergeCoins"),
  destination: ObjectTransactionArgument2,
  sources: array(ObjectTransactionArgument2)
});
var MakeMoveVecTransaction2 = object({
  kind: literal("MakeMoveVec"),
  type: optional(option2(string())),
  objects: array(ObjectTransactionArgument2)
});
var PublishTransaction2 = object({
  kind: literal("Publish"),
  modules: array(array(integer())),
  dependencies: array(ObjectId2)
});
var UpgradePolicy2 = ((UpgradePolicy22) => {
  UpgradePolicy22[UpgradePolicy22["COMPATIBLE"] = 0] = "COMPATIBLE";
  UpgradePolicy22[UpgradePolicy22["ADDITIVE"] = 128] = "ADDITIVE";
  UpgradePolicy22[UpgradePolicy22["DEP_ONLY"] = 192] = "DEP_ONLY";
  return UpgradePolicy22;
})(UpgradePolicy2 || {});
var UpgradeTransaction2 = object({
  kind: literal("Upgrade"),
  modules: array(array(integer())),
  dependencies: array(ObjectId2),
  packageId: ObjectId2,
  ticket: ObjectTransactionArgument2
});
var TransactionTypes2 = [
  MoveCallTransaction2,
  TransferObjectsTransaction2,
  SplitCoinsTransaction2,
  MergeCoinsTransaction2,
  PublishTransaction2,
  UpgradeTransaction2,
  MakeMoveVecTransaction2
];
var TransactionType2 = union([...TransactionTypes2]);
function getTransactionType2(data) {
  assert2(data, TransactionType2);
  return TransactionTypes2.find((schema) => is(data, schema));
}
var Transactions2 = {
  MoveCall(input) {
    return create3(
      {
        kind: "MoveCall",
        target: input.target,
        arguments: input.arguments ?? [],
        typeArguments: input.typeArguments ?? []
      },
      MoveCallTransaction2
    );
  },
  TransferObjects(objects, address) {
    return create3(
      { kind: "TransferObjects", objects, address },
      TransferObjectsTransaction2
    );
  },
  SplitCoins(coin, amounts) {
    return create3({ kind: "SplitCoins", coin, amounts }, SplitCoinsTransaction2);
  },
  MergeCoins(destination, sources) {
    return create3(
      { kind: "MergeCoins", destination, sources },
      MergeCoinsTransaction2
    );
  },
  Publish({
    modules,
    dependencies
  }) {
    return create3(
      {
        kind: "Publish",
        modules: modules.map(
          (module) => typeof module === "string" ? Array.from(fromB642(module)) : module
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId2(dep))
      },
      PublishTransaction2
    );
  },
  Upgrade({
    modules,
    dependencies,
    packageId,
    ticket
  }) {
    return create3(
      {
        kind: "Upgrade",
        modules: modules.map(
          (module) => typeof module === "string" ? Array.from(fromB642(module)) : module
        ),
        dependencies: dependencies.map((dep) => normalizeSuiObjectId2(dep)),
        packageId,
        ticket
      },
      UpgradeTransaction2
    );
  },
  MakeMoveVec({
    type: type2,
    objects
  }) {
    return create3(
      {
        kind: "MakeMoveVec",
        type: type2 ? { Some: type2 } : { None: null },
        objects
      },
      MakeMoveVecTransaction2
    );
  }
};
var VECTOR_REGEX2 = /^vector<(.+)>$/;
var STRUCT_REGEX2 = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
var TypeTagSerializer2 = class {
  static parseFromStr(str, normalizeAddress = false) {
    if (str === "address") {
      return { address: null };
    } else if (str === "bool") {
      return { bool: null };
    } else if (str === "u8") {
      return { u8: null };
    } else if (str === "u16") {
      return { u16: null };
    } else if (str === "u32") {
      return { u32: null };
    } else if (str === "u64") {
      return { u64: null };
    } else if (str === "u128") {
      return { u128: null };
    } else if (str === "u256") {
      return { u256: null };
    } else if (str === "signer") {
      return { signer: null };
    }
    const vectorMatch = str.match(VECTOR_REGEX2);
    if (vectorMatch) {
      return {
        vector: TypeTagSerializer2.parseFromStr(
          vectorMatch[1],
          normalizeAddress
        )
      };
    }
    const structMatch = str.match(STRUCT_REGEX2);
    if (structMatch) {
      const address = normalizeAddress ? normalizeSuiAddress2(structMatch[1]) : structMatch[1];
      return {
        struct: {
          address,
          module: structMatch[2],
          name: structMatch[3],
          typeParams: structMatch[5] === void 0 ? [] : TypeTagSerializer2.parseStructTypeArgs(
            structMatch[5],
            normalizeAddress
          )
        }
      };
    }
    throw new Error(
      `Encountered unexpected token when parsing type args for ${str}`
    );
  }
  static parseStructTypeArgs(str, normalizeAddress = false) {
    const tok = [];
    let word = "";
    let nestedAngleBrackets = 0;
    for (let i17 = 0; i17 < str.length; i17++) {
      const char = str[i17];
      if (char === "<") {
        nestedAngleBrackets++;
      }
      if (char === ">") {
        nestedAngleBrackets--;
      }
      if (nestedAngleBrackets === 0 && char === ",") {
        tok.push(word.trim());
        word = "";
        continue;
      }
      word += char;
    }
    tok.push(word.trim());
    return tok.map(
      (tok2) => TypeTagSerializer2.parseFromStr(tok2, normalizeAddress)
    );
  }
  static tagToString(tag) {
    if ("bool" in tag) {
      return "bool";
    }
    if ("u8" in tag) {
      return "u8";
    }
    if ("u16" in tag) {
      return "u16";
    }
    if ("u32" in tag) {
      return "u32";
    }
    if ("u64" in tag) {
      return "u64";
    }
    if ("u128" in tag) {
      return "u128";
    }
    if ("u256" in tag) {
      return "u256";
    }
    if ("address" in tag) {
      return "address";
    }
    if ("signer" in tag) {
      return "signer";
    }
    if ("vector" in tag) {
      return `vector<${TypeTagSerializer2.tagToString(tag.vector)}>`;
    }
    if ("struct" in tag) {
      const struct = tag.struct;
      const typeParams = struct.typeParams.map(TypeTagSerializer2.tagToString).join(", ");
      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ""}`;
    }
    throw new Error("Invalid TypeTag");
  }
};
var ARGUMENT_INNER2 = "Argument";
var VECTOR22 = "vector";
var OPTION2 = "Option";
var CALL_ARG2 = "CallArg";
var TYPE_TAG2 = "TypeTag";
var PROGRAMMABLE_TX_BLOCK2 = "ProgrammableTransaction";
var PROGRAMMABLE_CALL_INNER2 = "ProgrammableMoveCall";
var TRANSACTION_INNER2 = "Transaction";
var ENUM_KIND2 = "EnumKind";
var TRANSACTION2 = [ENUM_KIND2, TRANSACTION_INNER2];
var ARGUMENT2 = [ENUM_KIND2, ARGUMENT_INNER2];
var PROGRAMMABLE_CALL2 = "SimpleProgrammableMoveCall";
var builder2 = new BCS2(bcs2).registerStructType(PROGRAMMABLE_TX_BLOCK2, {
  inputs: [VECTOR22, CALL_ARG2],
  transactions: [VECTOR22, TRANSACTION2]
}).registerEnumType(ARGUMENT_INNER2, {
  GasCoin: null,
  Input: { index: BCS2.U16 },
  Result: { index: BCS2.U16 },
  NestedResult: { index: BCS2.U16, resultIndex: BCS2.U16 }
}).registerStructType(PROGRAMMABLE_CALL_INNER2, {
  package: BCS2.ADDRESS,
  module: BCS2.STRING,
  function: BCS2.STRING,
  type_arguments: [VECTOR22, TYPE_TAG2],
  arguments: [VECTOR22, ARGUMENT2]
}).registerEnumType(TRANSACTION_INNER2, {
  /**
   * A Move Call - any public Move function can be called via
   * this transaction. The results can be used that instant to pass
   * into the next transaction.
   */
  MoveCall: PROGRAMMABLE_CALL2,
  /**
   * Transfer vector of objects to a receiver.
   */
  TransferObjects: {
    objects: [VECTOR22, ARGUMENT2],
    address: ARGUMENT2
  },
  /**
   * Split `amount` from a `coin`.
   */
  SplitCoins: { coin: ARGUMENT2, amounts: [VECTOR22, ARGUMENT2] },
  /**
   * Merge Vector of Coins (`sources`) into a `destination`.
   */
  MergeCoins: { destination: ARGUMENT2, sources: [VECTOR22, ARGUMENT2] },
  /**
   * Publish a Move module.
   */
  Publish: {
    modules: [VECTOR22, [VECTOR22, BCS2.U8]],
    dependencies: [VECTOR22, BCS2.ADDRESS]
  },
  /**
   * Build a vector of objects using the input arguments.
   * It is impossible to construct a `vector<T: key>` otherwise,
   * so this call serves a utility function.
   */
  MakeMoveVec: {
    type: [OPTION2, TYPE_TAG2],
    objects: [VECTOR22, ARGUMENT2]
  },
  /**  */
  Upgrade: {
    modules: [VECTOR22, [VECTOR22, BCS2.U8]],
    dependencies: [VECTOR22, BCS2.ADDRESS],
    packageId: BCS2.ADDRESS,
    ticket: ARGUMENT2
  }
});
builder2.registerType(
  [ENUM_KIND2, "T"],
  function encode2(writer, data, typeParams, typeMap) {
    const kind = data.kind;
    const invariant = { [kind]: data };
    const [enumType] = typeParams;
    return this.getTypeInterface(enumType)._encodeRaw.call(
      this,
      writer,
      invariant,
      typeParams,
      typeMap
    );
  },
  function decode2(reader, typeParams, typeMap) {
    const [enumType] = typeParams;
    const data = this.getTypeInterface(enumType)._decodeRaw.call(
      this,
      reader,
      typeParams,
      typeMap
    );
    const kind = Object.keys(data)[0];
    return { kind, ...data[kind] };
  },
  (data) => {
    if (typeof data !== "object" && !("kind" in data)) {
      throw new Error(
        `EnumKind: Missing property "kind" in the input ${JSON.stringify(
          data
        )}`
      );
    }
    return true;
  }
);
builder2.registerType(
  PROGRAMMABLE_CALL2,
  function encodeProgrammableTx2(writer, data, typeParams, typeMap) {
    const [pkg, module, fun] = data.target.split("::");
    const type_arguments = data.typeArguments.map(
      (tag) => TypeTagSerializer2.parseFromStr(tag, true)
    );
    return this.getTypeInterface(PROGRAMMABLE_CALL_INNER2)._encodeRaw.call(
      this,
      writer,
      {
        package: normalizeSuiAddress2(pkg),
        module,
        function: fun,
        type_arguments,
        arguments: data.arguments
      },
      typeParams,
      typeMap
    );
  },
  function decodeProgrammableTx2(reader, typeParams, typeMap) {
    let data = builder2.getTypeInterface(PROGRAMMABLE_CALL_INNER2)._decodeRaw.call(this, reader, typeParams, typeMap);
    return {
      target: [data.package, data.module, data.function].join("::"),
      arguments: data.arguments,
      typeArguments: data.type_arguments.map(TypeTagSerializer2.tagToString)
    };
  },
  // Validation callback to error out if the data format is invalid.
  // TODO: make sure TypeTag can be parsed.
  (data) => {
    return data.target.split("::").length === 3;
  }
);
var ObjectArg2 = union([
  object({ ImmOrOwned: SuiObjectRef2 }),
  object({
    Shared: object({
      objectId: string(),
      initialSharedVersion: union([integer(), string()]),
      mutable: boolean()
    })
  })
]);
var PureCallArg2 = object({ Pure: array(integer()) });
var ObjectCallArg2 = object({ Object: ObjectArg2 });
var BuilderCallArg2 = union([PureCallArg2, ObjectCallArg2]);
var Inputs2 = {
  Pure(data, type2) {
    return {
      Pure: Array.from(
        data instanceof Uint8Array ? data : builder2.ser(type2, data).toBytes()
      )
    };
  },
  ObjectRef({ objectId, digest, version: version2 }) {
    return {
      Object: {
        ImmOrOwned: {
          digest,
          version: version2,
          objectId: normalizeSuiAddress2(objectId)
        }
      }
    };
  },
  SharedObjectRef({
    objectId,
    mutable,
    initialSharedVersion
  }) {
    return {
      Object: {
        Shared: {
          mutable,
          initialSharedVersion,
          objectId: normalizeSuiAddress2(objectId)
        }
      }
    };
  }
};
function getIdFromCallArg2(arg) {
  if (typeof arg === "string") {
    return normalizeSuiAddress2(arg);
  }
  if ("ImmOrOwned" in arg.Object) {
    return normalizeSuiAddress2(arg.Object.ImmOrOwned.objectId);
  }
  return normalizeSuiAddress2(arg.Object.Shared.objectId);
}
function getSharedObjectInput2(arg) {
  return typeof arg === "object" && "Object" in arg && "Shared" in arg.Object ? arg.Object.Shared : void 0;
}
function isMutableSharedObjectInput2(arg) {
  var _a;
  return ((_a = getSharedObjectInput2(arg)) == null ? void 0 : _a.mutable) ?? false;
}
var STD_ASCII_MODULE_NAME2 = "ascii";
var STD_ASCII_STRUCT_NAME2 = "String";
var STD_UTF8_MODULE_NAME2 = "string";
var STD_UTF8_STRUCT_NAME2 = "String";
var STD_OPTION_MODULE_NAME2 = "option";
var STD_OPTION_STRUCT_NAME2 = "Option";
var RESOLVED_SUI_ID2 = {
  address: SUI_FRAMEWORK_ADDRESS2,
  module: OBJECT_MODULE_NAME2,
  name: ID_STRUCT_NAME2
};
var RESOLVED_ASCII_STR2 = {
  address: MOVE_STDLIB_ADDRESS2,
  module: STD_ASCII_MODULE_NAME2,
  name: STD_ASCII_STRUCT_NAME2
};
var RESOLVED_UTF8_STR2 = {
  address: MOVE_STDLIB_ADDRESS2,
  module: STD_UTF8_MODULE_NAME2,
  name: STD_UTF8_STRUCT_NAME2
};
var RESOLVED_STD_OPTION2 = {
  address: MOVE_STDLIB_ADDRESS2,
  module: STD_OPTION_MODULE_NAME2,
  name: STD_OPTION_STRUCT_NAME2
};
var isSameStruct2 = (a10, b5) => a10.address === b5.address && a10.module === b5.module && a10.name === b5.name;
function isTxContext2(param) {
  var _a;
  const struct = (_a = extractStructTag2(param)) == null ? void 0 : _a.Struct;
  return (struct == null ? void 0 : struct.address) === "0x2" && (struct == null ? void 0 : struct.module) === "tx_context" && (struct == null ? void 0 : struct.name) === "TxContext";
}
function expectType2(typeName, argVal) {
  if (typeof argVal === "undefined") {
    return;
  }
  if (typeof argVal !== typeName) {
    throw new Error(
      `Expect ${argVal} to be ${typeName}, received ${typeof argVal}`
    );
  }
}
var allowedTypes2 = [
  "Address",
  "Bool",
  "U8",
  "U16",
  "U32",
  "U64",
  "U128",
  "U256"
];
function getPureSerializationType2(normalizedType, argVal) {
  if (typeof normalizedType === "string" && allowedTypes2.includes(normalizedType)) {
    if (normalizedType in ["U8", "U16", "U32", "U64", "U128", "U256"]) {
      expectType2("number", argVal);
    } else if (normalizedType === "Bool") {
      expectType2("boolean", argVal);
    } else if (normalizedType === "Address") {
      expectType2("string", argVal);
      if (argVal && !isValidSuiAddress2(argVal)) {
        throw new Error("Invalid Sui Address");
      }
    }
    return normalizedType.toLowerCase();
  } else if (typeof normalizedType === "string") {
    throw new Error(
      `Unknown pure normalized type ${JSON.stringify(normalizedType, null, 2)}`
    );
  }
  if ("Vector" in normalizedType) {
    if ((argVal === void 0 || typeof argVal === "string") && normalizedType.Vector === "U8") {
      return "string";
    }
    if (argVal !== void 0 && !Array.isArray(argVal)) {
      throw new Error(
        `Expect ${argVal} to be a array, received ${typeof argVal}`
      );
    }
    const innerType = getPureSerializationType2(
      normalizedType.Vector,
      // undefined when argVal is empty
      argVal ? argVal[0] : void 0
    );
    if (innerType === void 0) {
      return;
    }
    return `vector<${innerType}>`;
  }
  if ("Struct" in normalizedType) {
    if (isSameStruct2(normalizedType.Struct, RESOLVED_ASCII_STR2)) {
      return "string";
    } else if (isSameStruct2(normalizedType.Struct, RESOLVED_UTF8_STR2)) {
      return "utf8string";
    } else if (isSameStruct2(normalizedType.Struct, RESOLVED_SUI_ID2)) {
      return "address";
    } else if (isSameStruct2(normalizedType.Struct, RESOLVED_STD_OPTION2)) {
      const optionToVec = {
        Vector: normalizedType.Struct.typeArguments[0]
      };
      return getPureSerializationType2(optionToVec, argVal);
    }
  }
  return void 0;
}
function hashTypedData2(typeTag, data) {
  const typeTagBytes = Array.from(`${typeTag}::`).map((e16) => e16.charCodeAt(0));
  const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);
  dataWithTag.set(typeTagBytes);
  dataWithTag.set(data, typeTagBytes.length);
  return blake2b(dataWithTag, { dkLen: 32 });
}
var TransactionExpiration2 = optional(
  nullable(
    union([
      object({ Epoch: integer() }),
      object({ None: union([literal(true), literal(null)]) })
    ])
  )
);
var SuiAddress32 = string();
var StringEncodedBigint2 = define2("StringEncodedBigint", (val) => {
  if (!["string", "number", "bigint"].includes(typeof val))
    return false;
  try {
    BigInt(val);
    return true;
  } catch {
    return false;
  }
});
var GasConfig2 = object({
  budget: optional(StringEncodedBigint2),
  price: optional(StringEncodedBigint2),
  payment: optional(array(SuiObjectRef2)),
  owner: optional(SuiAddress32)
});
var SerializedTransactionDataBuilder2 = object({
  version: literal(1),
  sender: optional(SuiAddress32),
  expiration: TransactionExpiration2,
  gasConfig: GasConfig2,
  inputs: array(TransactionBlockInput2),
  transactions: array(TransactionType2)
});
function prepareSuiAddress2(address) {
  return normalizeSuiAddress2(address).replace("0x", "");
}
var TRANSACTION_DATA_MAX_SIZE2 = 128 * 1024;
var TransactionBlockDataBuilder2 = class {
  constructor(clone2) {
    this.version = 1;
    this.sender = clone2 == null ? void 0 : clone2.sender;
    this.expiration = clone2 == null ? void 0 : clone2.expiration;
    this.gasConfig = (clone2 == null ? void 0 : clone2.gasConfig) ?? {};
    this.inputs = (clone2 == null ? void 0 : clone2.inputs) ?? [];
    this.transactions = (clone2 == null ? void 0 : clone2.transactions) ?? [];
  }
  static fromKindBytes(bytes2) {
    const kind = builder2.de("TransactionKind", bytes2);
    const programmableTx = kind == null ? void 0 : kind.ProgrammableTransaction;
    if (!programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    const serialized = create3(
      {
        version: 1,
        gasConfig: {},
        inputs: programmableTx.inputs.map(
          (value, index) => create3(
            {
              kind: "Input",
              value,
              index,
              type: is(value, PureCallArg2) ? "pure" : "object"
            },
            TransactionBlockInput2
          )
        ),
        transactions: programmableTx.transactions
      },
      SerializedTransactionDataBuilder2
    );
    return TransactionBlockDataBuilder2.restore(serialized);
  }
  static fromBytes(bytes2) {
    var _a;
    const rawData = builder2.de("TransactionData", bytes2);
    const data = rawData == null ? void 0 : rawData.V1;
    const programmableTx = (_a = data == null ? void 0 : data.kind) == null ? void 0 : _a.ProgrammableTransaction;
    if (!data || !programmableTx) {
      throw new Error("Unable to deserialize from bytes.");
    }
    const serialized = create3(
      {
        version: 1,
        sender: data.sender,
        expiration: data.expiration,
        gasConfig: data.gasData,
        inputs: programmableTx.inputs.map(
          (value, index) => create3(
            {
              kind: "Input",
              value,
              index,
              type: is(value, PureCallArg2) ? "pure" : "object"
            },
            TransactionBlockInput2
          )
        ),
        transactions: programmableTx.transactions
      },
      SerializedTransactionDataBuilder2
    );
    return TransactionBlockDataBuilder2.restore(serialized);
  }
  static restore(data) {
    assert2(data, SerializedTransactionDataBuilder2);
    const transactionData = new TransactionBlockDataBuilder2();
    Object.assign(transactionData, data);
    return transactionData;
  }
  /**
   * Generate transaction digest.
   *
   * @param bytes BCS serialized transaction data
   * @returns transaction digest.
   */
  static getDigestFromBytes(bytes2) {
    const hash2 = hashTypedData2("TransactionData", bytes2);
    return toB582(hash2);
  }
  build({
    overrides,
    onlyTransactionKind
  } = {}) {
    const inputs = this.inputs.map((input) => {
      assert2(input.value, BuilderCallArg2);
      return input.value;
    });
    const kind = {
      ProgrammableTransaction: {
        inputs,
        transactions: this.transactions
      }
    };
    if (onlyTransactionKind) {
      return builder2.ser("TransactionKind", kind, { maxSize: TRANSACTION_DATA_MAX_SIZE2 }).toBytes();
    }
    const expiration = (overrides == null ? void 0 : overrides.expiration) ?? this.expiration;
    const sender = (overrides == null ? void 0 : overrides.sender) ?? this.sender;
    const gasConfig = { ...this.gasConfig, ...overrides == null ? void 0 : overrides.gasConfig };
    if (!sender) {
      throw new Error("Missing transaction sender");
    }
    if (!gasConfig.budget) {
      throw new Error("Missing gas budget");
    }
    if (!gasConfig.payment) {
      throw new Error("Missing gas payment");
    }
    if (!gasConfig.price) {
      throw new Error("Missing gas price");
    }
    const transactionData = {
      sender: prepareSuiAddress2(sender),
      expiration: expiration ? expiration : { None: true },
      gasData: {
        payment: gasConfig.payment,
        owner: prepareSuiAddress2(this.gasConfig.owner ?? sender),
        price: BigInt(gasConfig.price),
        budget: BigInt(gasConfig.budget)
      },
      kind: {
        ProgrammableTransaction: {
          inputs,
          transactions: this.transactions
        }
      }
    };
    return builder2.ser(
      "TransactionData",
      { V1: transactionData },
      { maxSize: TRANSACTION_DATA_MAX_SIZE2 }
    ).toBytes();
  }
  getDigest() {
    const bytes2 = this.build({ onlyTransactionKind: false });
    return TransactionBlockDataBuilder2.getDigestFromBytes(bytes2);
  }
  snapshot() {
    return create3(this, SerializedTransactionDataBuilder2);
  }
};
function createTransactionResult2(index) {
  const baseResult = { kind: "Result", index };
  const nestedResults = [];
  const nestedResultFor = (resultIndex) => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {
    kind: "NestedResult",
    index,
    resultIndex
  });
  return new Proxy(baseResult, {
    set() {
      throw new Error(
        "The transaction result is a proxy, and does not support setting properties directly"
      );
    },
    // TODO: Instead of making this return a concrete argument, we should ideally
    // make it reference-based (so that this gets resolved at build-time), which
    // allows re-ordering transactions.
    get(target, property) {
      if (property in target) {
        return Reflect.get(target, property);
      }
      if (property === Symbol.iterator) {
        return function* () {
          let i17 = 0;
          while (true) {
            yield nestedResultFor(i17);
            i17++;
          }
        };
      }
      if (typeof property === "symbol")
        return;
      const resultIndex = parseInt(property, 10);
      if (Number.isNaN(resultIndex) || resultIndex < 0)
        return;
      return nestedResultFor(resultIndex);
    }
  });
}
function expectProvider2(provider) {
  if (!provider) {
    throw new Error(
      `No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`
    );
  }
  return provider;
}
var TRANSACTION_BRAND2 = Symbol.for("@mysten/transaction");
var MAX_GAS_OBJECTS2 = 256;
var MAX_GAS2 = 1e9;
var GAS_OVERHEAD_PER_COIN2 = 10n;
var _blockData2;
var _input2;
var input_fn2;
var _selectGasPayment2;
var selectGasPayment_fn2;
var _prepare2;
var prepare_fn2;
var _TransactionBlock2 = class {
  constructor(transaction) {
    __privateAdd2(this, _input2);
    __privateAdd2(this, _selectGasPayment2);
    __privateAdd2(this, _prepare2);
    __privateAdd2(this, _blockData2, void 0);
    __privateSet2(this, _blockData2, new TransactionBlockDataBuilder2(
      transaction ? transaction.blockData : void 0
    ));
  }
  /** Returns `true` if the object is an instance of the Transaction builder class. */
  static is(obj) {
    return !!obj && typeof obj === "object" && obj[TRANSACTION_BRAND2] === true;
  }
  /**
   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.
   * Supports either a byte array, or base64-encoded bytes.
   */
  static fromKind(serialized) {
    const tx = new _TransactionBlock2();
    __privateSet2(tx, _blockData2, TransactionBlockDataBuilder2.fromKindBytes(
      typeof serialized === "string" ? fromB642(serialized) : serialized
    ));
    return tx;
  }
  /**
   * Converts from a serialized transaction format to a `Transaction` class.
   * There are two supported serialized formats:
   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.
   * - A byte array (or base64-encoded bytes) containing BCS transaction data.
   */
  static from(serialized) {
    const tx = new _TransactionBlock2();
    if (typeof serialized !== "string" || !serialized.startsWith("{")) {
      __privateSet2(tx, _blockData2, TransactionBlockDataBuilder2.fromBytes(
        typeof serialized === "string" ? fromB642(serialized) : serialized
      ));
    } else {
      __privateSet2(tx, _blockData2, TransactionBlockDataBuilder2.restore(
        JSON.parse(serialized)
      ));
    }
    return tx;
  }
  /** A helper to retrieve the Transaction builder `Transactions` */
  static get Transactions() {
    return Transactions2;
  }
  /** A helper to retrieve the Transaction builder `Inputs` */
  static get Inputs() {
    return Inputs2;
  }
  setSender(sender) {
    __privateGet2(this, _blockData2).sender = sender;
  }
  /**
   * Sets the sender only if it has not already been set.
   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.
   */
  setSenderIfNotSet(sender) {
    if (!__privateGet2(this, _blockData2).sender) {
      __privateGet2(this, _blockData2).sender = sender;
    }
  }
  setExpiration(expiration) {
    __privateGet2(this, _blockData2).expiration = expiration;
  }
  setGasPrice(price) {
    __privateGet2(this, _blockData2).gasConfig.price = String(price);
  }
  setGasBudget(budget) {
    __privateGet2(this, _blockData2).gasConfig.budget = String(budget);
  }
  setGasOwner(owner) {
    __privateGet2(this, _blockData2).gasConfig.owner = owner;
  }
  setGasPayment(payments) {
    if (payments.length >= MAX_GAS_OBJECTS2) {
      throw new Error(
        `Payment objects exceed maximum amount ${MAX_GAS_OBJECTS2}`
      );
    }
    __privateGet2(this, _blockData2).gasConfig.payment = payments.map(
      (payment) => mask(payment, SuiObjectRef2)
    );
  }
  /** Get a snapshot of the transaction data, in JSON form: */
  get blockData() {
    return __privateGet2(this, _blockData2).snapshot();
  }
  // Used to brand transaction classes so that they can be identified, even between multiple copies
  // of the builder.
  get [TRANSACTION_BRAND2]() {
    return true;
  }
  /** Returns an argument for the gas coin, to be used in a transaction. */
  get gas() {
    return { kind: "GasCoin" };
  }
  /**
   * Add a new object input to the transaction.
   */
  object(value) {
    const id = getIdFromCallArg2(value);
    const inserted = __privateGet2(this, _blockData2).inputs.find(
      (i17) => i17.type === "object" && id === getIdFromCallArg2(i17.value)
    );
    return inserted ?? __privateMethod2(this, _input2, input_fn2).call(this, "object", value);
  }
  /**
   * Add a new object input to the transaction using the fully-resolved object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  objectRef(...args) {
    return this.object(Inputs2.ObjectRef(...args));
  }
  /**
   * Add a new shared object input to the transaction using the fully-resolved shared object reference.
   * If you only have an object ID, use `builder.object(id)` instead.
   */
  sharedObjectRef(...args) {
    return this.object(Inputs2.SharedObjectRef(...args));
  }
  /**
   * Add a new non-object input to the transaction.
   */
  pure(value, type2) {
    return __privateMethod2(this, _input2, input_fn2).call(this, "pure", value instanceof Uint8Array ? Inputs2.Pure(value) : type2 ? Inputs2.Pure(value, type2) : value);
  }
  /** Add a transaction to the transaction block. */
  add(transaction) {
    const index = __privateGet2(this, _blockData2).transactions.push(transaction);
    return createTransactionResult2(index - 1);
  }
  // Method shorthands:
  splitCoins(...args) {
    return this.add(Transactions2.SplitCoins(...args));
  }
  mergeCoins(...args) {
    return this.add(Transactions2.MergeCoins(...args));
  }
  publish(...args) {
    return this.add(Transactions2.Publish(...args));
  }
  upgrade(...args) {
    return this.add(Transactions2.Upgrade(...args));
  }
  moveCall(...args) {
    return this.add(Transactions2.MoveCall(...args));
  }
  transferObjects(...args) {
    return this.add(Transactions2.TransferObjects(...args));
  }
  makeMoveVec(...args) {
    return this.add(Transactions2.MakeMoveVec(...args));
  }
  /**
   * Serialize the transaction to a string so that it can be sent to a separate context.
   * This is different from `build` in that it does not serialize to BCS bytes, and instead
   * uses a separate format that is unique to the transaction builder. This allows
   * us to serialize partially-complete transactions, that can then be completed and
   * built in a separate context.
   *
   * For example, a dapp can construct a transaction, but not provide gas objects
   * or a gas budget. The transaction then can be sent to the wallet, where this
   * information is automatically filled in (e.g. by querying for coin objects
   * and performing a dry run).
   */
  serialize() {
    return JSON.stringify(__privateGet2(this, _blockData2).snapshot());
  }
  /** Build the transaction to BCS bytes. */
  async build({
    provider,
    onlyTransactionKind
  } = {}) {
    await __privateMethod2(this, _prepare2, prepare_fn2).call(this, { provider, onlyTransactionKind });
    return __privateGet2(this, _blockData2).build({ onlyTransactionKind });
  }
  /** Derive transaction digest */
  async getDigest({
    provider
  } = {}) {
    await __privateMethod2(this, _prepare2, prepare_fn2).call(this, { provider });
    return __privateGet2(this, _blockData2).getDigest();
  }
};
var TransactionBlock2 = _TransactionBlock2;
_blockData2 = /* @__PURE__ */ new WeakMap();
_input2 = /* @__PURE__ */ new WeakSet();
input_fn2 = function(type2, value) {
  const index = __privateGet2(this, _blockData2).inputs.length;
  const input = create3(
    {
      kind: "Input",
      // bigints can't be serialized to JSON, so just string-convert them here:
      value: typeof value === "bigint" ? String(value) : value,
      index,
      type: type2
    },
    TransactionBlockInput2
  );
  __privateGet2(this, _blockData2).inputs.push(input);
  return input;
};
_selectGasPayment2 = /* @__PURE__ */ new WeakSet();
selectGasPayment_fn2 = async function(provider) {
  const gasOwner = __privateGet2(this, _blockData2).gasConfig.owner ?? __privateGet2(this, _blockData2).sender;
  const coins = await expectProvider2(provider).getCoins({
    owner: gasOwner,
    coinType: SUI_TYPE_ARG2
  });
  const paymentCoins = coins.data.filter((coin) => {
    const matchingInput = __privateGet2(this, _blockData2).inputs.find((input) => {
      if (is(input.value, BuilderCallArg2) && "Object" in input.value && "ImmOrOwned" in input.value.Object) {
        return coin.coinObjectId === input.value.Object.ImmOrOwned.objectId;
      }
      return false;
    });
    return !matchingInput;
  }).slice(0, MAX_GAS_OBJECTS2 - 1).map((coin) => ({
    objectId: coin.coinObjectId,
    digest: coin.digest,
    version: coin.version
  }));
  if (!paymentCoins.length) {
    throw new Error("No valid gas coins found for the transaction.");
  }
  return paymentCoins;
};
_prepare2 = /* @__PURE__ */ new WeakSet();
prepare_fn2 = async function({ provider, onlyTransactionKind }) {
  var _a;
  if (!onlyTransactionKind && !__privateGet2(this, _blockData2).sender) {
    throw new Error("Missing transaction sender");
  }
  const { inputs, transactions } = __privateGet2(this, _blockData2);
  const moveModulesToResolve = [];
  const objectsToResolve = [];
  transactions.forEach((transaction) => {
    if (transaction.kind === "MoveCall") {
      const needsResolution = transaction.arguments.some(
        (arg) => arg.kind === "Input" && !is(inputs[arg.index].value, BuilderCallArg2)
      );
      if (needsResolution) {
        moveModulesToResolve.push(transaction);
      }
      return;
    }
    const transactionType = getTransactionType2(transaction);
    if (!transactionType.schema)
      return;
    Object.entries(transaction).forEach(([key, value]) => {
      if (key === "kind")
        return;
      const keySchema = transactionType.schema[key];
      const isArray = keySchema.type === "array";
      const wellKnownEncoding = isArray ? keySchema.schema[TRANSACTION_TYPE2] : keySchema[TRANSACTION_TYPE2];
      if (!wellKnownEncoding)
        return;
      const encodeInput = (index) => {
        const input = inputs[index];
        if (!input) {
          throw new Error(`Missing input ${value.index}`);
        }
        if (is(input.value, BuilderCallArg2))
          return;
        if (wellKnownEncoding.kind === "object" && typeof input.value === "string") {
          objectsToResolve.push({ id: input.value, input });
        } else if (wellKnownEncoding.kind === "pure") {
          input.value = Inputs2.Pure(input.value, wellKnownEncoding.type);
        } else {
          throw new Error("Unexpected input format.");
        }
      };
      if (isArray) {
        value.forEach((arrayItem) => {
          if (arrayItem.kind !== "Input")
            return;
          encodeInput(arrayItem.index);
        });
      } else {
        if (value.kind !== "Input")
          return;
        encodeInput(value.index);
      }
    });
  });
  if (moveModulesToResolve.length) {
    await Promise.all(
      moveModulesToResolve.map(async (moveCall) => {
        const [packageId, moduleName, functionName] = moveCall.target.split("::");
        const normalized = await expectProvider2(
          provider
        ).getNormalizedMoveFunction({
          package: normalizeSuiObjectId2(packageId),
          module: moduleName,
          function: functionName
        });
        const hasTxContext = normalized.parameters.length > 0 && isTxContext2(normalized.parameters.at(-1));
        const params = hasTxContext ? normalized.parameters.slice(0, normalized.parameters.length - 1) : normalized.parameters;
        if (params.length !== moveCall.arguments.length) {
          throw new Error("Incorrect number of arguments.");
        }
        params.forEach((param, i17) => {
          const arg = moveCall.arguments[i17];
          if (arg.kind !== "Input")
            return;
          const input = inputs[arg.index];
          if (is(input.value, BuilderCallArg2))
            return;
          const inputValue = input.value;
          const serType = getPureSerializationType2(param, inputValue);
          if (serType) {
            input.value = Inputs2.Pure(inputValue, serType);
            return;
          }
          const structVal = extractStructTag2(param);
          if (structVal != null || typeof param === "object" && "TypeParameter" in param) {
            if (typeof inputValue !== "string") {
              throw new Error(
                `Expect the argument to be an object id string, got ${JSON.stringify(
                  inputValue,
                  null,
                  2
                )}`
              );
            }
            objectsToResolve.push({
              id: inputValue,
              input,
              normalizedType: param
            });
            return;
          }
          throw new Error(
            `Unknown call arg type ${JSON.stringify(
              param,
              null,
              2
            )} for value ${JSON.stringify(inputValue, null, 2)}`
          );
        });
      })
    );
  }
  if (objectsToResolve.length) {
    const dedupedIds = [...new Set(objectsToResolve.map(({ id }) => id))];
    const objects = await expectProvider2(provider).multiGetObjects({
      ids: dedupedIds,
      options: { showOwner: true }
    });
    let objectsById = new Map(
      dedupedIds.map((id, index) => {
        return [id, objects[index]];
      })
    );
    const invalidObjects = Array.from(objectsById).filter(([_2, obj]) => obj.error).map(([id, _2]) => id);
    if (invalidObjects.length) {
      throw new Error(
        `The following input objects are not invalid: ${invalidObjects.join(
          ", "
        )}`
      );
    }
    objectsToResolve.forEach(({ id, input, normalizedType }) => {
      const object18 = objectsById.get(id);
      const initialSharedVersion = getSharedObjectInitialVersion2(object18);
      if (initialSharedVersion) {
        const mutable = isMutableSharedObjectInput2(input.value) || normalizedType != null && extractMutableReference2(normalizedType) != null;
        input.value = Inputs2.SharedObjectRef({
          objectId: id,
          initialSharedVersion,
          mutable
        });
      } else {
        input.value = Inputs2.ObjectRef(getObjectReference2(object18));
      }
    });
  }
  if (!onlyTransactionKind) {
    if (!__privateGet2(this, _blockData2).gasConfig.price) {
      this.setGasPrice(await expectProvider2(provider).getReferenceGasPrice());
    }
    if (!__privateGet2(this, _blockData2).gasConfig.payment) {
      __privateGet2(this, _blockData2).gasConfig.payment = await __privateMethod2(this, _selectGasPayment2, selectGasPayment_fn2).call(this, provider);
    }
    if (!this.blockData.gasConfig.budget) {
      const dryRunResult = await expectProvider2(
        provider
      ).dryRunTransactionBlock({
        transactionBlock: __privateGet2(this, _blockData2).build({
          overrides: {
            gasConfig: {
              budget: String(MAX_GAS2),
              payment: []
            }
          }
        })
      });
      if (dryRunResult.effects.status.status !== "success") {
        throw new Error(
          `Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,
          { cause: dryRunResult }
        );
      }
      const coinOverhead = GAS_OVERHEAD_PER_COIN2 * BigInt(((_a = this.blockData.gasConfig.payment) == null ? void 0 : _a.length) || 0n) * BigInt(this.blockData.gasConfig.price || 1n);
      this.setGasBudget(
        BigInt(dryRunResult.effects.gasUsed.computationCost) + BigInt(dryRunResult.effects.gasUsed.storageCost) + coinOverhead
      );
    }
  }
};
var NetworkMetrics2 = object({
  currentTps: number2(),
  tps30Days: number2(),
  currentCheckpoint: string(),
  currentEpoch: string(),
  totalAddresses: string(),
  totalObjects: string(),
  totalPackages: string()
});
var EndOfEpochInfo2 = object({
  lastCheckpointId: string(),
  epochEndTimestamp: string(),
  protocolVersion: string(),
  referenceGasPrice: string(),
  totalStake: string(),
  storageFundReinvestment: string(),
  storageCharge: string(),
  storageRebate: string(),
  storageFundBalance: string(),
  stakeSubsidyAmount: string(),
  totalGasFees: string(),
  totalStakeRewardsDistributed: string(),
  leftoverStorageFundInflow: string()
});
var EpochInfo2 = object({
  epoch: string(),
  validators: array(SuiValidatorSummary2),
  epochTotalTransactions: string(),
  firstCheckpointId: string(),
  epochStartTimestamp: string(),
  endOfEpochInfo: nullable(EndOfEpochInfo2)
});
var EpochPage2 = object({
  data: array(EpochInfo2),
  nextCursor: nullable(string()),
  hasNextPage: boolean()
});
var DEFAULT_OPTIONS2 = {
  socketOptions: DEFAULT_CLIENT_OPTIONS2,
  versionCacheTimeoutInSeconds: 600
};
var JsonRpcProvider2 = class {
  /**
   * Establish a connection to a Sui RPC endpoint
   *
   * @param connection The `Connection` object containing configuration for the network.
   * @param options configuration options for the provider
   */
  constructor(connection = devnetConnection2, options = DEFAULT_OPTIONS2) {
    this.options = options;
    this.connection = connection;
    const opts = { ...DEFAULT_OPTIONS2, ...options };
    this.options = opts;
    this.client = opts.rpcClient ?? new JsonRpcClient2(this.connection.fullnode);
    this.wsClient = opts.websocketClient ?? new WebsocketClient2(this.connection.websocket, opts.socketOptions);
  }
  async getRpcApiVersion() {
    if (this.rpcApiVersion && this.cacheExpiry && this.cacheExpiry <= Date.now()) {
      return this.rpcApiVersion;
    }
    try {
      const resp = await this.client.requestWithType("rpc.discover", [], any());
      this.rpcApiVersion = resp.info.version;
      this.cacheExpiry = // Date.now() is in milliseconds, but the timeout is in seconds
      Date.now() + (this.options.versionCacheTimeoutInSeconds ?? 0) * 1e3;
      return this.rpcApiVersion;
    } catch (err) {
      console.warn("Error fetching version number of the RPC API", err);
    }
    return void 0;
  }
  async requestSuiFromFaucet(recipient, httpHeaders) {
    if (!this.connection.faucet) {
      throw new Error("Faucet URL is not specified");
    }
    return requestSuiFromFaucet2(this.connection.faucet, recipient, httpHeaders);
  }
  /**
   * Get all Coin<`coin_type`> objects owned by an address.
   */
  async getCoins(input) {
    if (!input.owner || !isValidSuiAddress2(normalizeSuiAddress2(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.client.requestWithType(
      "suix_getCoins",
      [input.owner, input.coinType, input.cursor, input.limit],
      PaginatedCoins2
    );
  }
  /**
   * Get all Coin objects owned by an address.
   */
  async getAllCoins(input) {
    if (!input.owner || !isValidSuiAddress2(normalizeSuiAddress2(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.client.requestWithType(
      "suix_getAllCoins",
      [input.owner, input.cursor, input.limit],
      PaginatedCoins2
    );
  }
  /**
   * Get the total coin balance for one coin type, owned by the address owner.
   */
  async getBalance(input) {
    if (!input.owner || !isValidSuiAddress2(normalizeSuiAddress2(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.client.requestWithType(
      "suix_getBalance",
      [input.owner, input.coinType],
      CoinBalance2
    );
  }
  /**
   * Get the total coin balance for all coin types, owned by the address owner.
   */
  async getAllBalances(input) {
    if (!input.owner || !isValidSuiAddress2(normalizeSuiAddress2(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.client.requestWithType(
      "suix_getAllBalances",
      [input.owner],
      array(CoinBalance2)
    );
  }
  /**
   * Fetch CoinMetadata for a given coin type
   */
  async getCoinMetadata(input) {
    return await this.client.requestWithType(
      "suix_getCoinMetadata",
      [input.coinType],
      CoinMetadataStruct2
    );
  }
  /**
   *  Fetch total supply for a coin
   */
  async getTotalSupply(input) {
    return await this.client.requestWithType(
      "suix_getTotalSupply",
      [input.coinType],
      CoinSupply2
    );
  }
  /**
   * Invoke any RPC method
   * @param method the method to be invoked
   * @param args the arguments to be passed to the RPC request
   */
  async call(method, args) {
    const response = await this.client.request(method, args);
    if (is(response, ErrorResponse2)) {
      throw new RPCError2({
        req: { method, args },
        code: response.error.code,
        data: response.error.data,
        cause: new Error(response.error.message)
      });
    }
    return response.result;
  }
  /**
   * Get Move function argument types like read, write and full access
   */
  async getMoveFunctionArgTypes(input) {
    return await this.client.requestWithType(
      "sui_getMoveFunctionArgTypes",
      [input.package, input.module, input.function],
      SuiMoveFunctionArgTypes2
    );
  }
  /**
   * Get a map from module name to
   * structured representations of Move modules
   */
  async getNormalizedMoveModulesByPackage(input) {
    return await this.client.requestWithType(
      "sui_getNormalizedMoveModulesByPackage",
      [input.package],
      SuiMoveNormalizedModules2
    );
  }
  /**
   * Get a structured representation of Move module
   */
  async getNormalizedMoveModule(input) {
    return await this.client.requestWithType(
      "sui_getNormalizedMoveModule",
      [input.package, input.module],
      SuiMoveNormalizedModule2
    );
  }
  /**
   * Get a structured representation of Move function
   */
  async getNormalizedMoveFunction(input) {
    return await this.client.requestWithType(
      "sui_getNormalizedMoveFunction",
      [input.package, input.module, input.function],
      SuiMoveNormalizedFunction2
    );
  }
  /**
   * Get a structured representation of Move struct
   */
  async getNormalizedMoveStruct(input) {
    return await this.client.requestWithType(
      "sui_getNormalizedMoveStruct",
      [input.package, input.module, input.struct],
      SuiMoveNormalizedStruct2
    );
  }
  /**
   * Get all objects owned by an address
   */
  async getOwnedObjects(input) {
    if (!input.owner || !isValidSuiAddress2(normalizeSuiAddress2(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.client.requestWithType(
      "suix_getOwnedObjects",
      [
        input.owner,
        {
          filter: input.filter,
          options: input.options
        },
        input.cursor,
        input.limit
      ],
      PaginatedObjectsResponse2
    );
  }
  /**
   * Get details about an object
   */
  async getObject(input) {
    if (!input.id || !isValidSuiObjectId2(normalizeSuiObjectId2(input.id))) {
      throw new Error("Invalid Sui Object id");
    }
    return await this.client.requestWithType(
      "sui_getObject",
      [input.id, input.options],
      SuiObjectResponse2
    );
  }
  /**
   * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail
   */
  async multiGetObjects(input) {
    input.ids.forEach((id) => {
      if (!id || !isValidSuiObjectId2(normalizeSuiObjectId2(id))) {
        throw new Error(`Invalid Sui Object id ${id}`);
      }
    });
    const hasDuplicates = input.ids.length !== new Set(input.ids).size;
    if (hasDuplicates) {
      throw new Error(`Duplicate object ids in batch call ${input.ids}`);
    }
    return await this.client.requestWithType(
      "sui_multiGetObjects",
      [input.ids, input.options],
      array(SuiObjectResponse2)
    );
  }
  /**
   * Get transaction blocks for a given query criteria
   */
  async queryTransactionBlocks(input) {
    return await this.client.requestWithType(
      "suix_queryTransactionBlocks",
      [
        {
          filter: input.filter,
          options: input.options
        },
        input.cursor,
        input.limit,
        (input.order || "descending") === "descending"
      ],
      PaginatedTransactionResponse2
    );
  }
  async getTransactionBlock(input) {
    if (!isValidTransactionDigest2(input.digest)) {
      throw new Error("Invalid Transaction digest");
    }
    return await this.client.requestWithType(
      "sui_getTransactionBlock",
      [input.digest, input.options],
      SuiTransactionBlockResponse2
    );
  }
  async multiGetTransactionBlocks(input) {
    input.digests.forEach((d15) => {
      if (!isValidTransactionDigest2(d15)) {
        throw new Error(`Invalid Transaction digest ${d15}`);
      }
    });
    const hasDuplicates = input.digests.length !== new Set(input.digests).size;
    if (hasDuplicates) {
      throw new Error(`Duplicate digests in batch call ${input.digests}`);
    }
    return await this.client.requestWithType(
      "sui_multiGetTransactionBlocks",
      [input.digests, input.options],
      array(SuiTransactionBlockResponse2)
    );
  }
  async executeTransactionBlock(input) {
    return await this.client.requestWithType(
      "sui_executeTransactionBlock",
      [
        typeof input.transactionBlock === "string" ? input.transactionBlock : toB642(input.transactionBlock),
        Array.isArray(input.signature) ? input.signature : [input.signature],
        input.options,
        input.requestType
      ],
      SuiTransactionBlockResponse2
    );
  }
  /**
   * Get total number of transactions
   */
  async getTotalTransactionBlocks() {
    const resp = await this.client.requestWithType(
      "sui_getTotalTransactionBlocks",
      [],
      string()
    );
    return BigInt(resp);
  }
  /**
   * Getting the reference gas price for the network
   */
  async getReferenceGasPrice() {
    const resp = await this.client.requestWithType(
      "suix_getReferenceGasPrice",
      [],
      string()
    );
    return BigInt(resp);
  }
  /**
   * Return the delegated stakes for an address
   */
  async getStakes(input) {
    if (!input.owner || !isValidSuiAddress2(normalizeSuiAddress2(input.owner))) {
      throw new Error("Invalid Sui address");
    }
    return await this.client.requestWithType(
      "suix_getStakes",
      [input.owner],
      array(DelegatedStake2)
    );
  }
  /**
   * Return the delegated stakes queried by id.
   */
  async getStakesByIds(input) {
    input.stakedSuiIds.forEach((id) => {
      if (!id || !isValidSuiObjectId2(normalizeSuiObjectId2(id))) {
        throw new Error(`Invalid Sui Stake id ${id}`);
      }
    });
    return await this.client.requestWithType(
      "suix_getStakesByIds",
      [input.stakedSuiIds],
      array(DelegatedStake2)
    );
  }
  /**
   * Return the latest system state content.
   */
  async getLatestSuiSystemState() {
    return await this.client.requestWithType(
      "suix_getLatestSuiSystemState",
      [],
      SuiSystemStateSummary2
    );
  }
  /**
   * Get events for a given query criteria
   */
  async queryEvents(input) {
    return await this.client.requestWithType(
      "suix_queryEvents",
      [
        input.query,
        input.cursor,
        input.limit,
        (input.order || "descending") === "descending"
      ],
      PaginatedEvents2
    );
  }
  /**
   * Subscribe to get notifications whenever an event matching the filter occurs
   */
  async subscribeEvent(input) {
    return this.wsClient.subscribeEvent(input.filter, input.onMessage);
  }
  /**
   * Unsubscribe from an event subscription
   */
  async unsubscribeEvent(input) {
    return this.wsClient.unsubscribeEvent(input.id);
  }
  /**
   * Runs the transaction block in dev-inspect mode. Which allows for nearly any
   * transaction (or Move call) with any arguments. Detailed results are
   * provided, including both the transaction effects and any return values.
   */
  async devInspectTransactionBlock(input) {
    let devInspectTxBytes;
    if (TransactionBlock2.is(input.transactionBlock)) {
      input.transactionBlock.setSenderIfNotSet(input.sender);
      devInspectTxBytes = toB642(
        await input.transactionBlock.build({
          provider: this,
          onlyTransactionKind: true
        })
      );
    } else if (typeof input.transactionBlock === "string") {
      devInspectTxBytes = input.transactionBlock;
    } else if (input.transactionBlock instanceof Uint8Array) {
      devInspectTxBytes = toB642(input.transactionBlock);
    } else {
      throw new Error("Unknown transaction block format.");
    }
    return await this.client.requestWithType(
      "sui_devInspectTransactionBlock",
      [input.sender, devInspectTxBytes, input.gasPrice, input.epoch],
      DevInspectResults2
    );
  }
  /**
   * Dry run a transaction block and return the result.
   */
  async dryRunTransactionBlock(input) {
    return await this.client.requestWithType(
      "sui_dryRunTransactionBlock",
      [
        typeof input.transactionBlock === "string" ? input.transactionBlock : toB642(input.transactionBlock)
      ],
      DryRunTransactionBlockResponse2
    );
  }
  /**
   * Return the list of dynamic field objects owned by an object
   */
  async getDynamicFields(input) {
    if (!input.parentId || !isValidSuiObjectId2(normalizeSuiObjectId2(input.parentId))) {
      throw new Error("Invalid Sui Object id");
    }
    return await this.client.requestWithType(
      "suix_getDynamicFields",
      [input.parentId, input.cursor, input.limit],
      DynamicFieldPage2
    );
  }
  /**
   * Return the dynamic field object information for a specified object
   */
  async getDynamicFieldObject(input) {
    return await this.client.requestWithType(
      "suix_getDynamicFieldObject",
      [input.parentId, input.name],
      SuiObjectResponse2
    );
  }
  /**
   * Get the sequence number of the latest checkpoint that has been executed
   */
  async getLatestCheckpointSequenceNumber() {
    const resp = await this.client.requestWithType(
      "sui_getLatestCheckpointSequenceNumber",
      [],
      string()
    );
    return String(resp);
  }
  /**
   * Returns information about a given checkpoint
   */
  async getCheckpoint(input) {
    return await this.client.requestWithType(
      "sui_getCheckpoint",
      [input.id],
      Checkpoint2
    );
  }
  /**
   * Returns historical checkpoints paginated
   */
  async getCheckpoints(input) {
    const version2 = await this.getRpcApiVersion();
    const resp = await this.client.requestWithType(
      "sui_getCheckpoints",
      [
        input.cursor,
        version2 && (0, import_femver2.lt)(version2, "0.32.0") ? String(input == null ? void 0 : input.limit) : input == null ? void 0 : input.limit,
        input.descendingOrder
      ],
      CheckpointPage2
    );
    return resp;
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCommitteeInfo(input) {
    return await this.client.requestWithType(
      "suix_getCommitteeInfo",
      [input == null ? void 0 : input.epoch],
      CommitteeInfo2
    );
  }
  async getNetworkMetrics() {
    return await this.client.requestWithType(
      "suix_getNetworkMetrics",
      [],
      NetworkMetrics2
    );
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getEpochs(input) {
    const version2 = await this.getRpcApiVersion();
    return await this.client.requestWithType(
      "suix_getEpochs",
      [
        input == null ? void 0 : input.cursor,
        version2 && (0, import_femver2.lt)(version2, "0.32.0") ? String(input == null ? void 0 : input.limit) : input == null ? void 0 : input.limit,
        input == null ? void 0 : input.descendingOrder
      ],
      EpochPage2
    );
  }
  /**
   * Return the committee information for the asked epoch
   */
  async getCurrentEpoch() {
    return await this.client.requestWithType(
      "suix_getCurrentEpoch",
      [],
      EpochInfo2
    );
  }
};
var AppId2 = ((AppId22) => {
  AppId22[AppId22["Sui"] = 0] = "Sui";
  return AppId22;
})(AppId2 || {});
var IntentVersion2 = ((IntentVersion22) => {
  IntentVersion22[IntentVersion22["V0"] = 0] = "V0";
  return IntentVersion22;
})(IntentVersion2 || {});
var IntentScope2 = ((IntentScope3) => {
  IntentScope3[IntentScope3["TransactionData"] = 0] = "TransactionData";
  IntentScope3[IntentScope3["TransactionEffects"] = 1] = "TransactionEffects";
  IntentScope3[IntentScope3["CheckpointSummary"] = 2] = "CheckpointSummary";
  IntentScope3[IntentScope3["PersonalMessage"] = 3] = "PersonalMessage";
  return IntentScope3;
})(IntentScope2 || {});
function intentWithScope2(scope) {
  return [
    scope,
    0,
    0
    /* Sui */
  ];
}
function messageWithIntent2(scope, message) {
  const intent = intentWithScope2(scope);
  const intentMessage = new Uint8Array(intent.length + message.length);
  intentMessage.set(intent);
  intentMessage.set(message, intent.length);
  return intentMessage;
}
var SignerWithProvider = class {
  ///////////////////
  // Sub-classes MAY override these
  /**
   * Request gas tokens from a faucet server and send to the signer
   * address
   * @param httpHeaders optional request headers
   */
  async requestSuiFromFaucet(httpHeaders) {
    return this.provider.requestSuiFromFaucet(
      await this.getAddress(),
      httpHeaders
    );
  }
  constructor(provider) {
    this.provider = provider;
  }
  /**
   * Sign a message using the keypair, with the `PersonalMessage` intent.
   */
  async signMessage(input) {
    const signature = await this.signData(
      messageWithIntent2(3, input.message)
    );
    return {
      messageBytes: toB642(input.message),
      signature
    };
  }
  /**
   * Sign a transaction.
   */
  async signTransactionBlock(input) {
    let transactionBlockBytes;
    if (TransactionBlock2.is(input.transactionBlock)) {
      input.transactionBlock.setSenderIfNotSet(await this.getAddress());
      transactionBlockBytes = await input.transactionBlock.build({
        provider: this.provider
      });
    } else if (input.transactionBlock instanceof Uint8Array) {
      transactionBlockBytes = input.transactionBlock;
    } else {
      throw new Error("Unknown transaction format");
    }
    const intentMessage = messageWithIntent2(
      0,
      transactionBlockBytes
    );
    const signature = await this.signData(intentMessage);
    return {
      transactionBlockBytes: toB642(transactionBlockBytes),
      signature
    };
  }
  /**
   * Sign a transaction block and submit to the Fullnode for execution.
   *
   * @param options specify which fields to return (e.g., transaction, effects, events, etc).
   * By default, only the transaction digest will be returned.
   * @param requestType WaitForEffectsCert or WaitForLocalExecution, see details in `ExecuteTransactionRequestType`.
   * Defaults to `WaitForLocalExecution` if options.show_effects or options.show_events is true
   */
  async signAndExecuteTransactionBlock(input) {
    const { transactionBlockBytes, signature } = await this.signTransactionBlock({
      transactionBlock: input.transactionBlock
    });
    return await this.provider.executeTransactionBlock({
      transactionBlock: transactionBlockBytes,
      signature,
      options: input.options,
      requestType: input.requestType
    });
  }
  /**
   * Derive transaction digest from
   * @param tx BCS serialized transaction data or a `Transaction` object
   * @returns transaction digest
   */
  async getTransactionBlockDigest(tx) {
    if (TransactionBlock2.is(tx)) {
      tx.setSenderIfNotSet(await this.getAddress());
      return tx.getDigest({ provider: this.provider });
    } else if (tx instanceof Uint8Array) {
      return TransactionBlockDataBuilder2.getDigestFromBytes(tx);
    } else {
      throw new Error("Unknown transaction format.");
    }
  }
  /**
   * Runs the transaction in dev-inpsect mode. Which allows for nearly any
   * transaction (or Move call) with any arguments. Detailed results are
   * provided, including both the transaction effects and any return values.
   */
  async devInspectTransactionBlock(input) {
    const address = await this.getAddress();
    return this.provider.devInspectTransactionBlock({
      sender: address,
      ...input
    });
  }
  /**
   * Dry run a transaction and return the result.
   */
  async dryRunTransactionBlock(input) {
    let dryRunTxBytes;
    if (TransactionBlock2.is(input.transactionBlock)) {
      input.transactionBlock.setSenderIfNotSet(await this.getAddress());
      dryRunTxBytes = await input.transactionBlock.build({
        provider: this.provider
      });
    } else if (typeof input.transactionBlock === "string") {
      dryRunTxBytes = fromB642(input.transactionBlock);
    } else if (input.transactionBlock instanceof Uint8Array) {
      dryRunTxBytes = input.transactionBlock;
    } else {
      throw new Error("Unknown transaction format");
    }
    return this.provider.dryRunTransactionBlock({
      transactionBlock: dryRunTxBytes
    });
  }
  /**
   * Returns the estimated gas cost for the transaction
   * @param tx The transaction to estimate the gas cost. When string it is assumed it's a serialized tx in base64
   * @returns total gas cost estimation
   * @throws whens fails to estimate the gas cost
   */
  async getGasCostEstimation(...args) {
    const txEffects = await this.dryRunTransactionBlock(...args);
    const gasEstimation = getTotalGasUsedUpperBound(txEffects.effects);
    if (typeof gasEstimation === "undefined") {
      throw new Error("Failed to estimate the gas cost from transaction");
    }
    return gasEstimation;
  }
};
var RawSigner = class extends SignerWithProvider {
  constructor(keypair, provider) {
    super(provider);
    this.keypair = keypair;
  }
  async getAddress() {
    return this.keypair.getPublicKey().toSuiAddress();
  }
  async signData(data) {
    const pubkey = this.keypair.getPublicKey();
    const digest = blake2b(data, { dkLen: 32 });
    const signature = this.keypair.signData(digest);
    const signatureScheme = this.keypair.getKeyScheme();
    return toSerializedSignature({
      signatureScheme,
      signature,
      pubKey: pubkey
    });
  }
  connect(provider) {
    return new RawSigner(this.keypair, provider);
  }
};
var SUI_SYSTEM_STATE_OBJECT_ID2 = normalizeSuiObjectId2("0x5");

// node_modules/@wallet-standard/app/lib/esm/wallets.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f11) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f11)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f11 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f11.call(receiver, value) : f11 ? f11.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f11) {
  if (kind === "a" && !f11)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f11 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f11 : kind === "a" ? f11.call(receiver) : f11 ? f11.value : state.get(receiver);
};
var _AppReadyEvent_detail;
var wallets = void 0;
var registered = /* @__PURE__ */ new Set();
var listeners = {};
function getWallets() {
  if (wallets)
    return wallets;
  wallets = Object.freeze({ register, get, on });
  if (typeof window === "undefined")
    return wallets;
  const api = Object.freeze({ register });
  try {
    window.addEventListener("wallet-standard:register-wallet", ({ detail: callback }) => callback(api));
  } catch (error) {
    console.error("wallet-standard:register-wallet event listener could not be added\n", error);
  }
  try {
    window.dispatchEvent(new AppReadyEvent(api));
  } catch (error) {
    console.error("wallet-standard:app-ready event could not be dispatched\n", error);
  }
  return wallets;
}
function register(...wallets2) {
  var _a;
  wallets2 = wallets2.filter((wallet) => !registered.has(wallet));
  if (!wallets2.length)
    return () => {
    };
  wallets2.forEach((wallet) => registered.add(wallet));
  (_a = listeners["register"]) == null ? void 0 : _a.forEach((listener) => guard(() => listener(...wallets2)));
  return function unregister() {
    var _a2;
    wallets2.forEach((wallet) => registered.delete(wallet));
    (_a2 = listeners["unregister"]) == null ? void 0 : _a2.forEach((listener) => guard(() => listener(...wallets2)));
  };
}
function get() {
  return [...registered];
}
function on(event, listener) {
  var _a;
  ((_a = listeners[event]) == null ? void 0 : _a.push(listener)) || (listeners[event] = [listener]);
  return function off() {
    var _a2;
    listeners[event] = (_a2 = listeners[event]) == null ? void 0 : _a2.filter((existingListener) => listener !== existingListener);
  };
}
function guard(callback) {
  try {
    callback();
  } catch (error) {
    console.error(error);
  }
}
var AppReadyEvent = class extends Event {
  constructor(api) {
    super("wallet-standard:app-ready", {
      bubbles: false,
      cancelable: false,
      composed: false
    });
    _AppReadyEvent_detail.set(this, void 0);
    __classPrivateFieldSet(this, _AppReadyEvent_detail, api, "f");
  }
  get detail() {
    return __classPrivateFieldGet(this, _AppReadyEvent_detail, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  /** @deprecated */
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  /** @deprecated */
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  /** @deprecated */
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
};
_AppReadyEvent_detail = /* @__PURE__ */ new WeakMap();

// node_modules/@wallet-standard/wallet/lib/esm/register.js
var _RegisterWalletEvent_detail;
_RegisterWalletEvent_detail = /* @__PURE__ */ new WeakMap();

// node_modules/@wallet-standard/wallet/lib/esm/util.js
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f11) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f11)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f11 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f11.call(receiver, value) : f11 ? f11.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f11) {
  if (kind === "a" && !f11)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f11 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f11 : kind === "a" ? f11.call(receiver) : f11 ? f11.value : state.get(receiver);
};
var _ReadonlyWalletAccount_address;
var _ReadonlyWalletAccount_publicKey;
var _ReadonlyWalletAccount_chains;
var _ReadonlyWalletAccount_features;
var _ReadonlyWalletAccount_label;
var _ReadonlyWalletAccount_icon;
var ReadonlyWalletAccount = class {
  /**
   * Create and freeze a read-only account.
   *
   * @param account Account to copy properties from.
   */
  constructor(account) {
    _ReadonlyWalletAccount_address.set(this, void 0);
    _ReadonlyWalletAccount_publicKey.set(this, void 0);
    _ReadonlyWalletAccount_chains.set(this, void 0);
    _ReadonlyWalletAccount_features.set(this, void 0);
    _ReadonlyWalletAccount_label.set(this, void 0);
    _ReadonlyWalletAccount_icon.set(this, void 0);
    if (new.target === ReadonlyWalletAccount) {
      Object.freeze(this);
    }
    __classPrivateFieldSet2(this, _ReadonlyWalletAccount_address, account.address, "f");
    __classPrivateFieldSet2(this, _ReadonlyWalletAccount_publicKey, account.publicKey.slice(), "f");
    __classPrivateFieldSet2(this, _ReadonlyWalletAccount_chains, account.chains.slice(), "f");
    __classPrivateFieldSet2(this, _ReadonlyWalletAccount_features, account.features.slice(), "f");
    __classPrivateFieldSet2(this, _ReadonlyWalletAccount_label, account.label, "f");
    __classPrivateFieldSet2(this, _ReadonlyWalletAccount_icon, account.icon, "f");
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.address | WalletAccount::address} */
  get address() {
    return __classPrivateFieldGet2(this, _ReadonlyWalletAccount_address, "f");
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.publicKey | WalletAccount::publicKey} */
  get publicKey() {
    return __classPrivateFieldGet2(this, _ReadonlyWalletAccount_publicKey, "f").slice();
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.chains | WalletAccount::chains} */
  get chains() {
    return __classPrivateFieldGet2(this, _ReadonlyWalletAccount_chains, "f").slice();
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.features | WalletAccount::features} */
  get features() {
    return __classPrivateFieldGet2(this, _ReadonlyWalletAccount_features, "f").slice();
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.label | WalletAccount::label} */
  get label() {
    return __classPrivateFieldGet2(this, _ReadonlyWalletAccount_label, "f");
  }
  /** Implementation of {@link "@wallet-standard/base".WalletAccount.icon | WalletAccount::icon} */
  get icon() {
    return __classPrivateFieldGet2(this, _ReadonlyWalletAccount_icon, "f");
  }
};
_ReadonlyWalletAccount_address = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_publicKey = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_chains = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_features = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_label = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_icon = /* @__PURE__ */ new WeakMap();

// node_modules/@mysten/wallet-standard/dist/index.mjs
var REQUIRED_FEATURES = [
  "standard:connect",
  "standard:events"
];
function isStandardWalletAdapterCompatibleWallet(wallet, features = []) {
  return [...REQUIRED_FEATURES, ...features].every(
    (feature) => feature in wallet.features
  );
}

// node_modules/@mysten/wallet-adapter-unsafe-burner/dist/index.mjs
var __accessCheck3 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet3 = (obj, member, getter) => {
  __accessCheck3(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd3 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet3 = (obj, member, value, setter) => {
  __accessCheck3(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _provider;
var _keypair;
var _signer;
var _account;
var UnsafeBurnerWalletAdapter = class {
  constructor(network = localnetConnection2) {
    this.name = "Unsafe Burner Wallet";
    this.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAJrElEQVR42tWbe2xT1x3H7UxAyD3XrdrSbGXlUbKWsq5rWdVuVOMRSEqSOmnVRZMmJqZNYv1nf3R/jWmVmVrtRRM/YwPd1nVTNcrE3pQCoikrIRAC4VVNY0hlD9ZOo1uCfe3ra9979v0dcy3s5Pper76Oh/STE+495/4+5/c85zqe2f7HAx5vKsS+monJj/CdHi/f4/HWW4f6AwdblmXjTM0NyS+movKtw9v+j6C5gKhyTMTTpA2x15Qwy+Pz75motOGdgKep8WF5ATgVZIt5NeO2wMqD0hfVGNPh3oYaYflsjG0l63PeyLCDnqbsLpZIhaRNFI+Ox+Le5KB0RybK8gDmJOkI07U4i/FhT1NDQl8Me5rUIfaDfELOJ0NsFa/SJQHm1WLsHcDqRWiy9BCL8s0N5t6UWWFVvxplejYm60hC91cNjPtzCTZsAptCVoeLP8PDDQJNCSodap6H+LtE8ZcdkvVkkD38vwDn4/Jvy4EhBhZSvRaUHiTXn31gJJxkUPoClBKKFizM+inhVA2cYIdM4HJouPvoe9s9H+KzDhyGK6KkmIqitBhww2C11rjQL2L4kgUwFxk8yPyzauUA3Pk/353XnA6zKbKCaQ2UlMvJF6W5uF5F8yHfZWZpC9HRmBziaEpm1bpY9XvhxuWJRldC7Mt03WlZwpjnkZUNa2DMG2EaPj9MGd2l2mofd0hQ7ZSopsXckHxVCUp32fXGdD0ZktrgFUmMqwhcWFjp87RArsD+9bn585IRaSHAKgBL3SZwOTRc8BKg7yYoskp5OJDiiPmF2Sj7ox0siYJ7lJA04EqvzZ9B1xSVt6PlW0IxZgUMJdZYAJuWngLQt9IRuZXmoTEkmci8ZtTXTViUKyasA9FRun5d8z6bfw0gYWm9mmCXxZatQgxfC7I2NVpRYQOxKWppLs4mcgn5NcibgL1K40xYp8CYY5TXEpjcb3LAJ0OZyyg3+2nySm6fjEtzkEz+7VBx3RTb+60z9dma7pkvwO2QQL5HzTtAdpKF7euw/HuzfrosBHy+ZsBimzbQshjWTVMDgez53B5MbjcGbr1ZjdUJOM5O0SLXzJ2R+uOA1dMAVoLsm5zb73JSId8t8Aa1LsAJdoTCrCaw6e3NC2DdFMUXWRg173mysJNOSUNskUJ1cOlXa2LhcbgmSszXYSn9hl3KSxTDjrZ2cbbfbWDyumsh9m3e7zCG7a3ETt+gtI7fx6lEOanZKDVvuA2cjYmt5xNOd2Louz3IQ12UZ2Zo3lkb9cDlvSs6m4Vk5Yqlabs0B97wT7PUuCXQz0Bnt9QxMPTW4iwBtmUlY8hFsHJPlzcQ1xuG75CVK1kXofCUGnU9fg1aVD7kfE9MoabtYkcAvIUYS2op3Hc3TTrDQzIAeojugTVLFolWDR6wFPtY0R66n6HltwjCIawnE2ymresk9NtN+pfUUi0mX6RJLfrh9zMRaRPOqubSA8W2MNzC0mHpK7j2ruuw5mYkxl5+2+HGQeg4yNYg7vNg+xMxFsuRMuiTsRJZG3cysAl4D9n4aC4un8L9qUyVvbCyYwFXX1nGUxFf1cCiEQqy75O+TpMwYKNKSPQUqhLyyWLsRbESLctx0YnixgfphRWA8pOPc+N4F9d+eV9V4OlCX/As5w5g+wtGhJGukp5go2R3D7EW9rSDcnGL56YgJHj+8GcFND/Vy41jj/H0jxc6HU/AA2QlR01UlH3D7CmITQnJq4lVWBi1yl8XYEh278c5H++F+Iui7r7bYR8tH/gbqoJN7fVODUhLYVVxzmYCEyOxFg7RUVa0egCHZZ55eRHnp/tKgMna6s/bbMdTxZgMzl9CCcmq7k690OzDfaeSN4QcsREjsQpgXHwyWyfg9K5WE7hc6JqTWjyihObfygOFOkv6i5K5TZx8LsL1sVS4NL8ItiB7sgAcEKcWHfUCVhK3kUVnBNbfXIs4l5xAv5sJs234eTUy93L0Au2otQOw5ORMyfQ6WwexFupVSHowG6uThXfebmlhWojMS3fazmMeGxEI6S2SUti6RAo2vKohVuH3qUG5FWm/PjH8kzutgSH5g58xrVwzIbZkxHf7OFjFC+wrMDXcpOqOKX/g01U/XPvVJyxdWsiJblqYmnZoWbDxAcR56X5WPuh4ewcL5PY9JBRUYjc7fzjG6Uc3mHBWbg23X1BLaFHOSnrw4bWiNAXSEWcWRntIignXTP/oDsfKZX66mMbZAPfhviU1AyYmJLYAMZa/QXjUSeIiixpj3UUFtd884KytjN7EjdGNNMbWwtlf3FvbQ4OQtIoYSzbxqVDLXMTxP8jnnbiyKcaJLvueGLD6kXW2sKZov1tpn7hwXf3ZUvq0K2FXOM7Op/Xgb6PhxsWIErYGVuK3WGXWkkwMMZVCVl5kWtax5A6usgemvnx4DelUcYcFC0eIbcbXKzggeyBjeXIhkftaKknJKLtnuSg7KmKQsrH+1nqbmLWY6w/tBGy/8xrruR5SM99LLIjfT/4ZbNZnQEPssIVb21rKTGRIPDagNoLdFMKgcuLc/TF6Bulk6c7ovg4TU+XvS6FNw1tDfVqH9MOPmBDui0hcK6wz744FlDjNe0m3aVldJYagtI6YbF+3ZGPsQHlN1vbeh8lJofqJ+uo9Zi4wXZxKFiXKGxbHT7pNq71oNg4Qi6MviE0FpRVqjGXILYoJ4tCjdYU1rWeMdPLc/ochj3B9pGNGL4NupGPRlUl35KMVxFLNO6ZnxYlBsUPqoMkbUqAb6VhMVKQ7MVT1dYdrL8hzEAcjpmvjHKphgaFb0ZVJZw7dwVD9q5fkgPTRbBxnzmGfgRLQsMCkG+moQdcp6GzzZsL2MGyllvBNGWM9RqMCk26kI7aBK526csVShZTfzid6FEzeiNAGP92jpCPQEbrW7EW5MbZxAz/fN9lg0IbQaaxrQ83/VoKPb/HqJx67Hw+43CDQBPsX0gm6ufXNvH4vP9rZapzx7+Nn+oxZAjfo2caZ3n350c5W6FSEdQ86sNarj3c/jRV+H42AXsdGRBfPPIlnb/mUtxzWXfALn/PmRze2Gud6E/xsXwYtnlsWN8Tc5/oyxjn/jvyJrlY82xLUfWuPr/TqxzuXQZkIP9M7CXiyuP4B4WmsTnNhzinjrD+WO9bRhmdZWLXe4EKRtV5tpN3Hx3s2G+d79/MJf4qff0LnE72kfFEs4ITQvWLMab8C131dP9n9Je1Yx000Nz2jAf+UJwCBchc3NvGR1Qx71XXY2Ww1Jvx7YalzAPkX9rp5E5Z+pv+ja8bE43uN491b9dHO9Xx4lUxziLn21Nai/wXWM6t9vkvtrwAAAABJRU5ErkJggg==";
    __privateAdd3(this, _provider, void 0);
    __privateAdd3(this, _keypair, void 0);
    __privateAdd3(this, _signer, void 0);
    __privateAdd3(this, _account, void 0);
    this.signMessage = async (messageInput) => {
      return __privateGet3(this, _signer).signMessage({ message: messageInput.message });
    };
    this.signTransactionBlock = async (transactionInput) => {
      return __privateGet3(this, _signer).signTransactionBlock({
        transactionBlock: transactionInput.transactionBlock
      });
    };
    this.signAndExecuteTransactionBlock = async (transactionInput) => {
      return await __privateGet3(this, _signer).signAndExecuteTransactionBlock({
        transactionBlock: transactionInput.transactionBlock,
        options: transactionInput.options,
        requestType: transactionInput.requestType
      });
    };
    this.on = () => {
      return () => {
      };
    };
    __privateSet3(this, _keypair, new Ed25519Keypair());
    __privateSet3(this, _provider, new JsonRpcProvider2(network));
    __privateSet3(this, _account, new ReadonlyWalletAccount({
      address: __privateGet3(this, _keypair).getPublicKey().toSuiAddress(),
      chains: ["sui:unknown"],
      features: [
        "sui:signAndExecuteTransactionBlock",
        "sui:signTransactionBlock"
      ],
      publicKey: __privateGet3(this, _keypair).getPublicKey().toBytes()
    }));
    __privateSet3(this, _signer, new RawSigner(__privateGet3(this, _keypair), __privateGet3(this, _provider)));
    this.connecting = false;
    this.connected = false;
    console.warn(
      "Your application is currently using the `UnsafeBurnerWalletAdapter`. Make sure that this adapter is not included in production."
    );
  }
  async getAccounts() {
    return [__privateGet3(this, _account)];
  }
  async connect() {
    this.connecting = true;
    try {
      __privateGet3(this, _signer).requestSuiFromFaucet();
    } catch (e16) {
      console.warn(
        "Failed to request Sui from the faucet. This may prevent transactions from being submitted."
      );
      console.warn(e16);
    }
    this.connecting = false;
    this.connected = true;
  }
  async disconnect() {
    this.connecting = false;
    this.connected = false;
  }
};
_provider = /* @__PURE__ */ new WeakMap();
_keypair = /* @__PURE__ */ new WeakMap();
_signer = /* @__PURE__ */ new WeakMap();
_account = /* @__PURE__ */ new WeakMap();

// node_modules/mitt/dist/mitt.mjs
function mitt_default(n17) {
  return { all: n17 = n17 || /* @__PURE__ */ new Map(), on: function(t18, e16) {
    var i17 = n17.get(t18);
    i17 ? i17.push(e16) : n17.set(t18, [e16]);
  }, off: function(t18, e16) {
    var i17 = n17.get(t18);
    i17 && (e16 ? i17.splice(i17.indexOf(e16) >>> 0, 1) : n17.set(t18, []));
  }, emit: function(t18, e16) {
    var i17 = n17.get(t18);
    i17 && i17.slice().map(function(n18) {
      n18(e16);
    }), (i17 = n17.get("*")) && i17.slice().map(function(n18) {
      n18(t18, e16);
    });
  } };
}

// node_modules/@mysten/wallet-adapter-wallet-standard/dist/index.mjs
var __accessCheck4 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet4 = (obj, member, getter) => {
  __accessCheck4(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd4 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet4 = (obj, member, value, setter) => {
  __accessCheck4(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod3 = (obj, member, method) => {
  __accessCheck4(obj, member, "access private method");
  return method;
};
var suiSignTransactionBlockLatestVersion = "1.0.0";
var suiSignAndExecuteTransactionBlockLatestVersion = "1.0.0";
function isFeatureCompatible(featureVersion, adapterVersion) {
  const [featureMajor] = featureVersion.split(".");
  const [adapterMajor] = adapterVersion.split(".");
  return +adapterMajor === +featureMajor;
}
var _events;
var _wallet;
var _walletEventUnsubscribe;
var _notifyChanged;
var notifyChanged_fn;
var StandardWalletAdapter = class {
  constructor({ wallet }) {
    __privateAdd4(this, _notifyChanged);
    this.connected = false;
    this.connecting = false;
    __privateAdd4(this, _events, mitt_default());
    __privateAdd4(this, _wallet, void 0);
    __privateAdd4(this, _walletEventUnsubscribe, null);
    this.signMessage = (messageInput) => {
      return __privateGet4(this, _wallet).features["sui:signMessage"].signMessage(messageInput);
    };
    this.signTransactionBlock = (transactionInput) => {
      const version2 = __privateGet4(this, _wallet).features["sui:signTransactionBlock"].version;
      if (!isFeatureCompatible(version2, suiSignTransactionBlockLatestVersion)) {
        throw new Error(
          `Version mismatch, signTransaction feature version ${version2} is not compatible with version ${suiSignTransactionBlockLatestVersion}`
        );
      }
      return __privateGet4(this, _wallet).features["sui:signTransactionBlock"].signTransactionBlock(transactionInput);
    };
    this.signAndExecuteTransactionBlock = (transactionInput) => {
      const version2 = __privateGet4(this, _wallet).features["sui:signAndExecuteTransactionBlock"].version;
      if (!isFeatureCompatible(
        version2,
        suiSignAndExecuteTransactionBlockLatestVersion
      )) {
        throw new Error(
          `Version mismatch, signAndExecuteTransactionBlock feature version ${version2} is not compatible with version ${suiSignAndExecuteTransactionBlockLatestVersion}`
        );
      }
      return __privateGet4(this, _wallet).features["sui:signAndExecuteTransactionBlock"].signAndExecuteTransactionBlock(transactionInput);
    };
    this.on = (event, callback) => {
      __privateGet4(this, _events).on(event, callback);
      return () => {
        __privateGet4(this, _events).off(event, callback);
      };
    };
    __privateSet4(this, _wallet, wallet);
  }
  get name() {
    return __privateGet4(this, _wallet).name;
  }
  get icon() {
    return __privateGet4(this, _wallet).icon;
  }
  get wallet() {
    return __privateGet4(this, _wallet);
  }
  async getAccounts() {
    return __privateGet4(this, _wallet).accounts;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      this.connecting = true;
      __privateSet4(this, _walletEventUnsubscribe, __privateGet4(this, _wallet).features["standard:events"].on("change", async ({ accounts }) => {
        if (accounts) {
          this.connected = accounts.length > 0;
          await __privateMethod3(this, _notifyChanged, notifyChanged_fn).call(this);
        }
      }));
      if (!__privateGet4(this, _wallet).accounts.length) {
        await __privateGet4(this, _wallet).features["standard:connect"].connect();
      }
      if (!__privateGet4(this, _wallet).accounts.length) {
        throw new Error("No wallet accounts found");
      }
      this.connected = true;
      await __privateMethod3(this, _notifyChanged, notifyChanged_fn).call(this);
    } finally {
      this.connecting = false;
    }
  }
  async disconnect() {
    if (__privateGet4(this, _wallet).features["standard:disconnect"]) {
      await __privateGet4(this, _wallet).features["standard:disconnect"].disconnect();
    }
    this.connected = false;
    this.connecting = false;
    if (__privateGet4(this, _walletEventUnsubscribe)) {
      __privateGet4(this, _walletEventUnsubscribe).call(this);
      __privateSet4(this, _walletEventUnsubscribe, null);
    }
  }
};
_events = /* @__PURE__ */ new WeakMap();
_wallet = /* @__PURE__ */ new WeakMap();
_walletEventUnsubscribe = /* @__PURE__ */ new WeakMap();
_notifyChanged = /* @__PURE__ */ new WeakSet();
notifyChanged_fn = async function() {
  __privateGet4(this, _events).emit("change", {
    connected: this.connected,
    accounts: await this.getAccounts()
  });
};
var DEFAULT_FEATURES = ["sui:signAndExecuteTransactionBlock"];
var _wallets;
var _adapters;
var _events2;
var _features;
var WalletStandardAdapterProvider = class {
  constructor({ features } = {}) {
    __privateAdd4(this, _wallets, void 0);
    __privateAdd4(this, _adapters, void 0);
    __privateAdd4(this, _events2, void 0);
    __privateAdd4(this, _features, void 0);
    __privateSet4(this, _adapters, /* @__PURE__ */ new Map());
    __privateSet4(this, _wallets, getWallets());
    __privateSet4(this, _events2, mitt_default());
    __privateSet4(this, _features, features ?? DEFAULT_FEATURES);
    __privateGet4(this, _wallets).on("register", () => {
      __privateGet4(this, _events2).emit("changed");
    });
    __privateGet4(this, _wallets).on("unregister", () => {
      __privateGet4(this, _events2).emit("changed");
    });
  }
  get() {
    const filtered = __privateGet4(this, _wallets).get().filter(
      (wallet) => isStandardWalletAdapterCompatibleWallet(wallet, __privateGet4(this, _features))
    );
    filtered.forEach((wallet) => {
      if (!__privateGet4(this, _adapters).has(wallet)) {
        __privateGet4(this, _adapters).set(wallet, new StandardWalletAdapter({ wallet }));
      }
    });
    return [...__privateGet4(this, _adapters).values()];
  }
  on(eventName, callback) {
    __privateGet4(this, _events2).on(eventName, callback);
    return () => {
      __privateGet4(this, _events2).off(eventName, callback);
    };
  }
};
_wallets = /* @__PURE__ */ new WeakMap();
_adapters = /* @__PURE__ */ new WeakMap();
_events2 = /* @__PURE__ */ new WeakMap();
_features = /* @__PURE__ */ new WeakMap();

// node_modules/ethos-connect/dist/hooks/useWalletKit.js
var C6 = ({ defaultChain: s9, configuredAdapters: l9, features: E4, enableUnsafeBurner: S3, preferredWallets: h7, storageAdapter: y6, storageKey: A2, disableAutoConnect: W5 }) => {
  const T = (0, import_react25.useMemo)(() => l9 ?? [new WalletStandardAdapterProvider({ features: E4 }), ...S3 ? [new UnsafeBurnerWalletAdapter()] : []], [l9]), r17 = (0, import_react25.useRef)(null);
  r17.current || (r17.current = createWalletKitCore({ adapters: T, preferredWallets: h7, storageAdapter: y6, storageKey: A2 }));
  const { wallets: u5, status: g10, currentWallet: e16, accounts: m12, currentAccount: n17 } = (0, import_react25.useSyncExternalStore)(r17.current.subscribe, r17.current.getState, r17.current.getState);
  (0, import_react25.useEffect)(() => {
    var _a;
    W5 || ((_a = r17.current) == null ? void 0 : _a.autoconnect());
  }, [g10, u5]);
  const { autoconnect: N4, ...k4 } = r17.current, p12 = (0, import_react25.useCallback)((t18) => {
    if (!e16 || !n17)
      throw new Error("No wallet connect to sign message");
    const o18 = t18.account || n17, a10 = t18.chain || s9 || r6;
    return e16.signAndExecuteTransactionBlock({ ...t18, account: o18, chain: a10 });
  }, [e16, n17, s9]), B4 = (0, import_react25.useCallback)((t18) => {
    if (!e16 || !n17)
      throw new Error("No wallet connect to sign message");
    const o18 = t18.account || n17, a10 = t18.chain || s9 || r6;
    return e16.signTransactionBlock({ ...t18, account: o18, chain: a10 });
  }, [e16, n17, s9]), f11 = (0, import_react25.useCallback)((t18) => {
    if (!e16 || !n17)
      throw new Error("No wallet connect to sign message");
    const o18 = t18.account || n17, a10 = typeof t18.message == "string" ? new Uint8Array(Buffer.from(t18.message, "utf8")) : t18.message;
    return e16.signMessage({ ...t18, message: a10, account: o18 });
  }, [e16, n17]), d15 = (0, import_react25.useCallback)(async (t18) => {
    if (!e16 || !n17)
      throw new Error("No wallet connect to preapprove transactions");
    const o18 = window.ethosWallet;
    return !o18 || e16.name !== "Ethos Wallet" ? (console.log("Wallet does not support preapproval"), false) : (t18.address || (t18.address = n17.address), t18.chain || (t18.chain = s9 ?? r6), o18.requestPreapproval(t18));
  }, [e16, n17, s9]), x5 = (0, import_react25.useMemo)(() => !e16 || !n17 ? null : { type: t5.Extension, name: e16.name, icon: e16.name === "Sui Wallet" ? "https://sui.io/favicon.png" : e16.icon, getAddress: async () => n17 == null ? void 0 : n17.address, accounts: m12, currentAccount: n17, signAndExecuteTransactionBlock: p12, signTransactionBlock: B4, requestPreapproval: d15, signMessage: f11, disconnect: () => {
    var _a;
    e16.disconnect(), (_a = r17.current) == null ? void 0 : _a.disconnect();
  } }, [e16, m12, n17, p12, d15, f11]);
  return { wallets: u5, status: g10, signer: x5, ...k4 };
};
var tt = C6;

// node_modules/ethos-connect/dist/hooks/useConnect.js
var W2 = (n17, a10) => {
  const t18 = (0, import_react26.useRef)(false), i17 = (0, import_react26.useRef)({ ethos: false, extension: false }), [d15, S3] = (0, import_react26.useState)({ provider: null, signer: null }), { wallets: A2, status: u5, signer: g10, getState: c11, connect: b5 } = tt({ defaultChain: (n17 == null ? void 0 : n17.chain) ?? r6, preferredWallets: n17 == null ? void 0 : n17.preferredWallets, disableAutoConnect: n17 == null ? void 0 : n17.disableAutoConnect }), m12 = (0, import_react26.useCallback)(() => {
    t18.current = false, i17.current = { ethos: false, extension: false }, S3((e16) => ({ ...e16, signer: null }));
  }, []);
  (0, import_react26.useEffect)(() => {
    t18.current = false, i17.current = { ethos: false, extension: false };
  }, [n17]), (0, import_react26.useEffect)(() => {
    const { provider: e16, signer: r17 } = d15;
    if (!e16 && !r17)
      return;
    const f11 = c11();
    f11.isConnecting || f11.isError || a10 && a10(d15);
  }, [u5, d15, a10, c11]);
  const s9 = (0, import_react26.useCallback)((e16, r17) => {
    if (c4("useConnect", "trying to set providerAndSigner", r17, t18.current, i17.current), t18.current)
      return;
    r17 && (i17.current[r17] = true);
    const f11 = !Object.values(i17.current).includes(false);
    if (!e16 && !f11)
      return;
    t18.current = !!e16;
    const h7 = typeof (n17 == null ? void 0 : n17.network) == "string" ? n17.network : i4, x5 = new Connection({ fullnode: h7 }), C10 = new JsonRpcProvider(x5);
    if (e16) {
      const k4 = e16 == null ? void 0 : e16.disconnect;
      e16.disconnect = () => {
        k4(), m12();
      };
    }
    S3({ provider: C10, signer: e16 });
  }, [m12]);
  return (0, import_react26.useEffect)(() => {
    u5 === WalletKitCoreConnectionStatus.DISCONNECTED && (i17.current.extension = false, t18.current = false, S3((e16) => ({ ...e16, signer: null })));
  }, [u5]), (0, import_react26.useEffect)(() => {
    !n17 || c4("mobile", "listening to mobile connection from EthosConnectProvider");
  }, [s9, n17]), (0, import_react26.useEffect)(() => {
    if (!n17)
      return;
    const e16 = c11();
    c4("useConnect", "Setting providerAndSigner extension", e16), !(e16.isConnecting || e16.isError) && s9(g10, "extension");
  }, [u5, c11, s9, g10, n17]), (0, import_react26.useEffect)(() => {
    if (!n17)
      return;
    if (!n17.apiKey) {
      c4("useConnect", "Setting null providerAndSigner ethos"), s9(null, "ethos");
      return;
    }
    (async () => {
      const r17 = await C3.getEthosSigner({ defaultChain: n17.chain ?? r6 });
      c4("useConnect", "Setting providerAndSigner ethos", r17), s9(r17, "ethos");
    })();
  }, [s9, n17]), { wallets: A2, providerAndSigner: d15, connect: b5, getState: c11 };
};
var G3 = W2;

// node_modules/ethos-connect/dist/hooks/useContext.js
var w9 = { network: i4, chain: r6, walletAppUrl: "https://ethoswallet.xyz" };
var L2 = ({ configuration: n17, onWalletConnected: C10 }) => {
  const [t18, T] = (0, import_react27.useState)({ ...w9, ...n17 }), [l9, a10] = (0, import_react27.useState)(false), p12 = (0, import_react27.useCallback)((e16) => {
    c4("EthosConnectProvider", "EthosConnectProvider Configuration:", e16);
    const o18 = { ...w9, ...e16 };
    C3.initializeEthos(o18), T((i17) => JSON.stringify(o18) !== JSON.stringify(i17) ? o18 : i17);
  }, []);
  (0, import_react27.useEffect)(() => {
    C3.initializeEthos(t18);
  }, [t18]), (0, import_react27.useEffect)(() => {
    !n17 || JSON.stringify(t18) !== JSON.stringify(n17) && p12(n17);
  }, [t18, n17]);
  const U = (0, import_react27.useCallback)((e16) => {
    a10(false), C10 && C10(e16);
  }, [C10]), { wallets: g10, connect: A2, providerAndSigner: s9, getState: P4 } = G3(t18, U), { account: { address: m12, contents: h7 }, altAccount: E4, setAltAccount: x5 } = v2(s9.signer, (t18 == null ? void 0 : t18.network) ?? i4), y6 = (0, import_react27.useMemo)(() => ({ isModalOpen: l9, openModal: () => {
    a10(true);
  }, closeModal: () => {
    a10(false);
  } }), [l9, a10]), S3 = (0, import_react27.useMemo)(() => {
    const { provider: e16, signer: o18 } = s9, i17 = P4();
    let r17;
    (o18 == null ? void 0 : o18.type) === "hosted" ? r17 = i9.Connected : i17.isConnecting ? r17 = i9.Loading : e16 && i17.isConnected ? r17 = i9.Connected : r17 = i9.NoConnection;
    const v7 = { status: r17, wallets: g10.map((u5) => ({ ...u5, name: u5.name, icon: u5.icon })), selectWallet: A2, provider: e16, altAccount: E4, setAltAccount: x5 };
    return o18 && m12 && (v7.wallet = { ...o18, address: m12, contents: h7 }), v7;
  }, [g10, A2, m12, E4, x5, s9, h7, t18]);
  return (0, import_react27.useEffect)(() => {
    var _a, _b;
    l9 ? (_a = document.getElementsByTagName("html").item(0)) == null ? void 0 : _a.setAttribute("style", "overflow: hidden;") : (_b = document.getElementsByTagName("html").item(0)) == null ? void 0 : _b.setAttribute("style", "");
  }, [l9]), { ...(0, import_react27.useMemo)(() => ({ wallet: S3, modal: y6, providerAndSigner: s9 }), [S3, y6, s9]), ethosConfiguration: t18, init: p12 };
};
var et = L2;

// node_modules/ethos-connect/dist/components/EthosConnectProvider.js
var l7 = ({ ethosConfiguration: o18, onWalletConnected: t18, connectMessage: r17, dappName: i17, dappIcon: a10, children: d15 }) => {
  var _a, _b, _c;
  const e16 = et({ configuration: o18 || {}, onWalletConnected: t18 });
  return import_react28.default.createElement(r10.Provider, { value: e16 }, d15, import_react28.default.createElement(vt, { isOpen: ((_a = e16.modal) == null ? void 0 : _a.isModalOpen) || false, hideEmailSignIn: ((_b = e16.ethosConfiguration) == null ? void 0 : _b.hideEmailSignIn) || false, hideWalletSignIn: ((_c = e16.ethosConfiguration) == null ? void 0 : _c.hideWalletSignIn) || false, connectMessage: r17, dappName: i17, dappIcon: a10, preferredWallets: o18 == null ? void 0 : o18.preferredWallets }));
};
var x3 = l7;

// node_modules/ethos-connect/dist/components/styled/SignInButton.js
var import_react30 = __toESM(require_react(), 1);

// node_modules/ethos-connect/dist/components/headless/WorkingButton.js
var import_react29 = __toESM(require_react(), 1);
var m10 = (r17) => {
  const { children: t18, isWorking: n17, workingComponent: p12, ...s9 } = r17;
  return import_react29.default.createElement("button", { ...s9 }, n17 ? p12 || import_react29.default.createElement("span", { className: "block p-2" }, import_react29.default.createElement(a, { width: 32 })) : import_react29.default.createElement(import_react29.default.Fragment, null, t18));
};
var a6 = m10;

// node_modules/ethos-connect/dist/components/styled/SignInButton.js
var c7 = (n17) => {
  const { children: e16, onClick: t18, externalContext: i17, ...s9 } = n17, { openModal: r17 } = (i17 == null ? void 0 : i17.modal) || m8(), l9 = (0, import_react30.useCallback)((p12) => {
    r17(), t18 && t18(p12);
  }, [r17, t18]);
  return import_react30.default.createElement(import_react30.default.Fragment, null, import_react30.default.createElement(a6, { onClick: l9, ...s9, style: g6(n17.style) }, e16 || import_react30.default.createElement(import_react30.default.Fragment, null, "Sign In")));
};
var C7 = c7;
var g6 = (n17) => ({ lineHeight: "21px", border: "none", cursor: "pointer", fontFamily: "inherit", fontSize: "14px", ...n17 || {} });

// node_modules/ethos-connect/dist/components/headless/HoverColorButton.js
var import_react31 = __toESM(require_react(), 1);
var g7 = (e16) => {
  const { hoverBackgroundColor: n17, hoverChildren: s9, children: u5, style: i17, ...l9 } = e16, [o18, r17] = (0, import_react31.useState)(false), a10 = (0, import_react31.useCallback)(() => {
    r17(true);
  }, []), c11 = (0, import_react31.useCallback)(() => {
    r17(false);
  }, []);
  return import_react31.default.createElement(a6, { onMouseEnter: a10, onMouseLeave: c11, style: { ...i17, backgroundColor: o18 ? n17 || e5 : void 0, color: o18 ? "white" : "black" }, ...l9 }, o18 ? s9 : u5);
};
var W3 = g7;

// node_modules/ethos-connect/dist/components/styled/AddressWidget.js
var import_react37 = __toESM(require_react(), 1);

// node_modules/ethos-connect/dist/lib/truncateMiddle.js
var i12 = (c11, e16 = 6) => c11 ? `${c11.slice(0, e16)}...${c11.slice(e16 * -1)}` : "";
var r12 = i12;

// node_modules/ethos-connect/dist/components/svg/Sui.js
var import_react32 = __toESM(require_react(), 1);
var e11 = ({ width: l9 = 24, color: t18 = "#6EBCEE" }) => import_react32.default.createElement("svg", { id: "SuiSvg", xmlns: "http://www.w3.org/2000/svg", width: l9, height: l9 * (40 / 28), viewBox: "-1 0 28 40", style: { display: "block", verticalAlign: "middle" } }, import_react32.default.createElement("path", { d: "M1.8611,33.0541a13.6477,13.6477,0,0,0,23.7778,0,13.89,13.89,0,0,0,0-13.8909L15.1824.8368a1.6444,1.6444,0,0,0-2.8648,0L1.8611,19.1632A13.89,13.89,0,0,0,1.8611,33.0541ZM10.8044,9.5555,13.0338,5.648a.8222.8222,0,0,1,1.4324,0L23.043,20.68a10.8426,10.8426,0,0,1,.8873,8.8828,9.4254,9.4254,0,0,0-.4388-1.4586c-1.1847-3.0254-3.8634-5.36-7.9633-6.9393-2.8187-1.0819-4.618-2.6731-5.3491-4.73C9.2375,13.7848,10.221,10.8942,10.8044,9.5555ZM7.0028,16.2184,4.457,20.68a10.8569,10.8569,0,0,0,0,10.8582,10.6776,10.6776,0,0,0,16.1566,2.935,7.5061,7.5061,0,0,0,.0667-5.2913c-.87-2.1858-2.9646-3.9308-6.2252-5.1876-3.6857-1.4147-6.08-3.6233-7.1157-6.5625A9.297,9.297,0,0,1,7.0028,16.2184Z", style: { fill: t18, fillRule: "evenodd" } }));
var a7 = e11;

// node_modules/ethos-connect/dist/components/styled/CopyWalletAddressButton.js
var import_react34 = __toESM(require_react(), 1);

// node_modules/ethos-connect/dist/components/styled/MenuButton.js
var import_react33 = __toESM(require_react(), 1);
var e12 = (o18) => import_react33.default.createElement(W3, { ...o18, style: n12() });
var s7 = e12;
var n12 = () => ({ width: "100%", borderRadius: "12px", textAlign: "left", padding: "6px 12px", display: "flex", alignItems: "center", gap: "6px", border: "none", fontFamily: "inherit", cursor: "pointer" });

// node_modules/ethos-connect/dist/components/styled/CopyWalletAddressButton.js
var M3 = (l9) => {
  const { externalContext: i17, ...u5 } = l9, { wallet: n17 } = (i17 == null ? void 0 : i17.wallet) || m9(), r17 = (0, import_react34.useCallback)((o18) => import_react34.default.createElement(import_react34.default.Fragment, null, import_react34.default.createElement("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react34.default.createElement("path", { d: "M15.6657 3.88789C15.3991 2.94272 14.5305 2.25 13.5 2.25H10.5C9.46954 2.25 8.60087 2.94272 8.33426 3.88789M15.6657 3.88789C15.7206 4.0825 15.75 4.28782 15.75 4.5V4.5C15.75 4.91421 15.4142 5.25 15 5.25H9C8.58579 5.25 8.25 4.91421 8.25 4.5V4.5C8.25 4.28782 8.27937 4.0825 8.33426 3.88789M15.6657 3.88789C16.3119 3.93668 16.9545 3.99828 17.5933 4.07241C18.6939 4.20014 19.5 5.149 19.5 6.25699V19.5C19.5 20.7426 18.4926 21.75 17.25 21.75H6.75C5.50736 21.75 4.5 20.7426 4.5 19.5V6.25699C4.5 5.149 5.30608 4.20014 6.40668 4.07241C7.04547 3.99828 7.68808 3.93668 8.33426 3.88789", stroke: o18 ? "white" : "black", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })), "Copy Wallet Address"), []), C10 = (0, import_react34.useCallback)((o18) => {
    const e16 = o18.target, a10 = e16.innerHTML;
    e16.innerHTML = "Copied!", navigator.clipboard.writeText((n17 == null ? void 0 : n17.address) || ""), setTimeout(() => {
      e16.innerHTML = a10;
    }, 1e3);
  }, [n17]);
  return import_react34.default.createElement(s7, { ...u5, onClick: C10, hoverChildren: r17(true) }, r17(false));
};
var B = M3;

// node_modules/ethos-connect/dist/components/styled/WalletExplorerButton.js
var import_react35 = __toESM(require_react(), 1);
var C8 = (e16) => {
  const t18 = (0, import_react35.useCallback)((l9) => import_react35.default.createElement(import_react35.default.Fragment, null, import_react35.default.createElement("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react35.default.createElement("path", { d: "M12 21C16.1926 21 19.7156 18.1332 20.7157 14.2529M12 21C7.80742 21 4.28442 18.1332 3.2843 14.2529M12 21C14.4853 21 16.5 16.9706 16.5 12C16.5 7.02944 14.4853 3 12 3M12 21C9.51472 21 7.5 16.9706 7.5 12C7.5 7.02944 9.51472 3 12 3M12 3C15.3652 3 18.299 4.84694 19.8431 7.58245M12 3C8.63481 3 5.70099 4.84694 4.15692 7.58245M19.8431 7.58245C17.7397 9.40039 14.9983 10.5 12 10.5C9.00172 10.5 6.26027 9.40039 4.15692 7.58245M19.8431 7.58245C20.5797 8.88743 21 10.3946 21 12C21 12.778 20.9013 13.5329 20.7157 14.2529M20.7157 14.2529C18.1334 15.6847 15.1619 16.5 12 16.5C8.8381 16.5 5.86662 15.6847 3.2843 14.2529M3.2843 14.2529C3.09871 13.5329 3 12.778 3 12C3 10.3946 3.42032 8.88743 4.15692 7.58245", stroke: l9 ? "white" : "black", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })), "Wallet Explorer"), []), r17 = (0, import_react35.useCallback)(() => {
    window.open("https://ethoswallet.xyz/dashboard", "_blank");
  }, []);
  return import_react35.default.createElement(s7, { ...e16, onClick: r17, hoverChildren: t18(true) }, t18(false));
};
var p9 = C8;

// node_modules/ethos-connect/dist/components/styled/LogoutButton.js
var import_react36 = __toESM(require_react(), 1);
var u3 = (M5) => {
  const { externalContext: n17, ...e16 } = M5, { wallet: Z } = (n17 == null ? void 0 : n17.wallet) || m9(), o18 = (0, import_react36.useCallback)((V) => import_react36.default.createElement(import_react36.default.Fragment, null, import_react36.default.createElement("svg", { width: "18", height: "18", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, import_react36.default.createElement("path", { d: "M13.5 21V20.25V21ZM7.5 21V21.75V21ZM5.25 18.75H6H5.25ZM5.25 5.25H4.5H5.25ZM7.5 3V2.25V3ZM13.5 3V3.75V3ZM15.75 5.25L15 5.25V5.25H15.75ZM15 9C15 9.41421 15.3358 9.75 15.75 9.75C16.1642 9.75 16.5 9.41421 16.5 9H15ZM16.5 15C16.5 14.5858 16.1642 14.25 15.75 14.25C15.3358 14.25 15 14.5858 15 15H16.5ZM15.75 18.75H16.5H15.75ZM18.2197 14.4697C17.9268 14.7626 17.9268 15.2374 18.2197 15.5303C18.5126 15.8232 18.9874 15.8232 19.2803 15.5303L18.2197 14.4697ZM21.75 12L22.2803 12.5303C22.5732 12.2374 22.5732 11.7626 22.2803 11.4697L21.75 12ZM19.2803 8.46967C18.9874 8.17678 18.5126 8.17678 18.2197 8.46967C17.9268 8.76256 17.9268 9.23744 18.2197 9.53033L19.2803 8.46967ZM9 11.25C8.58579 11.25 8.25 11.5858 8.25 12C8.25 12.4142 8.58579 12.75 9 12.75V11.25ZM13.5 20.25H7.5V21.75H13.5V20.25ZM6 18.75L6 5.25H4.5L4.5 18.75H6ZM7.5 3.75L13.5 3.75V2.25L7.5 2.25V3.75ZM15 5.25V9H16.5V5.25H15ZM15 15V18.75H16.5V15H15ZM6 5.25C6 4.42157 6.67157 3.75 7.5 3.75V2.25C5.84315 2.25 4.5 3.59315 4.5 5.25H6ZM7.5 20.25C6.67157 20.25 6 19.5784 6 18.75H4.5C4.5 20.4069 5.84315 21.75 7.5 21.75V20.25ZM13.5 21.75C15.1569 21.75 16.5 20.4069 16.5 18.75H15C15 19.5784 14.3284 20.25 13.5 20.25V21.75ZM13.5 3.75C14.3284 3.75 15 4.42157 15 5.25L16.5 5.25C16.5 3.59315 15.1569 2.25 13.5 2.25V3.75ZM19.2803 15.5303L22.2803 12.5303L21.2197 11.4697L18.2197 14.4697L19.2803 15.5303ZM22.2803 11.4697L19.2803 8.46967L18.2197 9.53033L21.2197 12.5303L22.2803 11.4697ZM21.75 11.25L9 11.25V12.75L21.75 12.75V11.25Z", fill: V ? "white" : "black" })), "Log Out"), []);
  return import_react36.default.createElement(s7, { ...e16, onClick: Z == null ? void 0 : Z.disconnect, hoverChildren: o18(true) }, o18(false));
};
var i14 = u3;

// node_modules/ethos-connect/dist/components/styled/AddressWidget.js
var import_react38 = __toESM(require_react(), 1);

// node_modules/ethos-connect/dist/enums/AddressWidgetButtons.js
var a8;
(function(l9) {
  l9.CopyWalletAddress = "copy_wallet_address", l9.WalletExplorer = "wallet_explorer", l9.Logout = "logout";
})(a8 || (a8 = {}));

// node_modules/ethos-connect/dist/components/styled/AddressWidget.js
var w10 = ({ includeMenu: p12 = true, buttonColor: r17 = e5, extraButtons: a10 = [], excludeButtons: s9 = [], externalContext: t18 }) => {
  var _a;
  const { wallet: e16 } = (t18 == null ? void 0 : t18.wallet) || m9(), [l9, i17] = (0, import_react37.useState)(false);
  (0, import_react38.useEffect)(() => {
    e16 || i17(false);
  }, [e16]);
  const u5 = (0, import_react37.useCallback)(() => {
    !e16 || i17(true);
  }, [e16]), x5 = (0, import_react37.useCallback)(() => {
    !e16 || i17(false);
  }, [e16]);
  return import_react37.default.createElement("div", { style: W4(), onMouseEnter: u5, onMouseLeave: x5 }, import_react37.default.createElement("div", { style: k2() }, import_react37.default.createElement("div", null, import_react37.default.createElement(a7, { color: "#222532", width: 12 })), e16 ? import_react37.default.createElement(import_react37.default.Fragment, null, import_react37.default.createElement("div", { style: A() }, o5((_a = e16.contents) == null ? void 0 : _a.suiBalance), " ", "Sui"), import_react37.default.createElement("div", { style: M4() }, e16.icon && import_react37.default.createElement("img", { style: E2(), src: e16.icon }), r12(e16.address))) : import_react37.default.createElement(C7, { style: I5(), externalContext: t18 })), p12 && l9 && import_react37.default.createElement("div", { style: P3() }, !s9.includes(a8.CopyWalletAddress) && import_react37.default.createElement(B, { externalContext: t18, hoverBackgroundColor: r17 }), !s9.includes(a8.WalletExplorer) && import_react37.default.createElement(p9, { hoverBackgroundColor: r17 }), a10, !s9.includes(a8.Logout) && import_react37.default.createElement(i14, { externalContext: t18, hoverBackgroundColor: r17 })));
};
var O2 = w10;
var W4 = () => ({ position: "relative", backgroundColor: "white", padding: "6px 12px 6px 18px", boxShadow: "1px 1px 3px 1px #dfdfe0", borderRadius: "18px", fontSize: "14px", color: "black" });
var k2 = () => ({ display: "flex", justifyContent: "center", alignItems: "center", gap: "12px" });
var A = () => ({ whiteSpace: "nowrap" });
var M4 = () => ({ borderRadius: "30px", backgroundColor: "#f2f1f0", padding: "6px 12px", display: "flex", alignItems: "center", gap: "6px" });
var P3 = () => ({ display: "flex", flexDirection: "column", gap: "6px", padding: "12px 18px", position: "absolute", bottom: 0, left: "12px", right: "12px", transform: "translateY(100%)", boxShadow: "1px 1px 3px 1px #dfdfe0", borderBottomLeftRadius: "18px", borderBottomRightRadius: "18px", backgroundColor: "white", zIndex: "99" });
var I5 = () => ({ padding: "0 12px 0 0", background: "none", whiteSpace: "nowrap" });
var E2 = () => ({ width: "20px", height: "20px" });

// node_modules/ethos-connect/dist/lib/logout.js
var n14 = async (o18, t18 = false) => {
  c4("logout", `-- Wallet ${t18} --`, `-- Is Extension: ${o18 == null ? void 0 : o18.type} --`, `-- Disconnect: ${!!(o18 == null ? void 0 : o18.disconnect)} --`, "signer", o18), o18.type === "extension" || !t18 ? await o18.disconnect() : await o18.logout();
};
var c9 = n14;

// node_modules/ethos-connect/dist/lib/preapprove.js
var a9 = async ({ signer: r17, preapproval: p12 }) => r17.requestPreapproval(p12);
var t16 = a9;

// node_modules/ethos-connect/dist/lib/sign.js
var r13 = async ({ signer: s9, message: n17 }) => s9.sign({ message: n17 });
var e13 = r13;

// node_modules/ethos-connect/dist/lib/transact.js
var r14 = async ({ signer: t18, transactionInput: n17 }) => (c4("transact", "Starting transaction", t18, n17), t18.signAndExecuteTransactionBlock(n17));
var c10 = r14;

// node_modules/ethos-connect/dist/lib/hideWallet.js
var i15 = (e16) => {
  e16.type !== t5.Extension && M(false);
};
var g8 = i15;

// node_modules/ethos-connect/dist/lib/showWallet.js
var i16 = (e16) => {
  e16.type !== t5.Extension && M(true);
};
var g9 = i16;

// node_modules/ethos-connect/dist/lib/dripSui.js
var p10 = async ({ address: r17, network: n17, faucet: o18 }) => {
  const t18 = new Connection({ fullnode: n17 ?? i4, faucet: `${o18 ?? p3}gas` });
  return new JsonRpcProvider(t18).requestSuiFromFaucet(r17);
};
var f9 = p10;

// node_modules/ethos-connect/dist/lib/nameService.js
var import_lodash2 = __toESM(require_lodash(), 1);
var d13 = "0xe7ed73e4c2c1b38729155bf5c44dc4496a9edd2f";
var y5 = "0xa378adb13792599e8eb8c7e4f2e938863921e4f4";
var E3 = "0x0000000000000000000000000000000000000002";
var w11 = "results.Ok[0][1].returnValues[0][0]";
var x4 = "results.Ok[0][1].returnValues[1][0]";
var f10 = (e16) => (e16 == null ? void 0 : e16.length) > 0 ? Array.from(e16, (n17) => ("0" + (n17 & 255).toString(16)).slice(-2)).join("") : "";
var k3 = (e16) => (e16 == null ? void 0 : e16.length) > 0 ? new TextDecoder().decode(Buffer.from(e16.slice(1)).buffer) : "";
var B3 = (e16) => {
  var _a;
  return String((_a = e16 == null ? void 0 : e16.match(/0x0{0,}([\w\d]+)/)) == null ? void 0 : _a[1]);
};
var S2 = (e16) => e16 ? `0x${e16.padStart(40, "0")}` : "";
var D2 = async (e16, n17, o18 = E3) => {
  const v7 = new Connection({ fullnode: n17 || i4 }), s9 = new JsonRpcProvider(v7);
  try {
    const t18 = new TransactionBlock();
    t18.add(TransactionBlock.Transactions.MoveCall({ target: `${d13}::base_registry::get_record_by_key`, arguments: [t18.object(y5), t18.pure(`${B3(e16)}.addr.reverse`)] }));
    const c11 = import_lodash2.default.get(await s9.devInspectTransactionBlock({ transactionBlock: t18, sender: o18 }), x4);
    if (!c11)
      return e16;
    const a10 = S2(f10(c11)), i17 = new TransactionBlock();
    i17.add(TransactionBlock.Transactions.MoveCall({ target: `${d13}::resolver::name`, arguments: [t18.object(a10), t18.pure(e16)] }));
    const l9 = await s9.devInspectTransactionBlock({ transactionBlock: i17, sender: o18 }), g10 = import_lodash2.default.get(l9, w11);
    return g10 ? k3(g10) : e16;
  } catch (t18) {
    return console.log("Error retreiving SuiNS Name", t18), e16;
  }
};
var C9 = async (e16, n17, o18 = E3) => {
  const v7 = new Connection({ fullnode: n17 || i4 }), s9 = new JsonRpcProvider(v7);
  try {
    const t18 = new TransactionBlock();
    t18.add(TransactionBlock.Transactions.MoveCall({ target: `${d13}::base_registry::get_record_by_key`, arguments: [t18.object(y5), t18.pure(e16)] }));
    const c11 = await s9.devInspectTransactionBlock({ transactionBlock: t18, sender: o18 }), a10 = import_lodash2.default.get(c11, x4);
    if (!a10)
      return e16;
    const i17 = S2(f10(a10)), l9 = new TransactionBlock();
    l9.add(TransactionBlock.Transactions.MoveCall({ target: `${d13}::resolver::addr`, arguments: [t18.object(i17), t18.pure(e16)] }));
    const g10 = await s9.devInspectTransactionBlock({ transactionBlock: l9, sender: o18 }), T = import_lodash2.default.get(g10, w11);
    return T ? S2(f10(T)) : e16;
  } catch (t18) {
    return console.log("Error retrieving address from SuiNS name", t18), e16;
  }
};

// node_modules/ethos-connect/dist/hooks/useProviderAndSigner.js
var import_react39 = __toESM(require_react(), 1);
var o17 = () => {
  const { providerAndSigner: r17 } = (0, import_react39.useContext)(r10);
  return r17 || { provider: null, signer: null };
};
var m11 = o17;

// node_modules/ethos-connect/dist/hooks/useAddress.js
var n15 = () => {
  var _a;
  const { signer: r17 } = m11();
  return (_a = r17 == null ? void 0 : r17.currentAccount) == null ? void 0 : _a.address;
};
var d14 = n15;

// node_modules/ethos-connect/dist/hooks/useContents.js
var import_react40 = __toESM(require_react(), 1);
var e15 = () => {
  var _a, _b;
  return (_b = (_a = (0, import_react40.useContext)(r10).wallet) == null ? void 0 : _a.wallet) == null ? void 0 : _b.contents;
};
var r15 = e15;

// node_modules/ethos-connect/dist/components/DetachedEthosConnectProvider.js
var import_react41 = __toESM(require_react(), 1);
var r16 = ({ context: e16, connectMessage: o18, dappName: t18, dappIcon: a10, children: i17 }) => {
  var _a, _b;
  return import_react41.default.createElement(import_react41.default.Fragment, null, i17, import_react41.default.createElement(vt, { isOpen: e16.modal.isModalOpen, hideEmailSignIn: ((_a = e16.ethosConfiguration) == null ? void 0 : _a.hideEmailSignIn) || false, hideWalletSignIn: ((_b = e16.ethosConfiguration) == null ? void 0 : _b.hideWalletSignIn) || false, connectMessage: o18, dappName: t18, dappIcon: a10, externalContext: e16 }));
};
var p11 = r16;

// node_modules/ethos-connect/dist/ethos-connect.esm.js
var N3 = { AddressWidget: O2, MenuButton: s7, headless: { HoverColorButton: W3 } };
var D3 = { AddressWidgetButtons: a8 };
var F3 = { login: h4, logout: c9, sign: e13, transact: c10, preapprove: t16, showWallet: g9, hideWallet: g8, showSignInModal: Et, hideSignInModal: xt, useProviderAndSigner: m11, useAddress: d14, useContents: r15, useWallet: m9, useContext: et, getWalletContents: Y2, dripSui: f9, getSuiName: D2, getSuiAddress: C9, formatBalance: o5, truncateMiddle: r12, ipfsConversion: F2, components: N3, enums: D3 };
export {
  t4 as Chain,
  p11 as DetachedEthosConnectProvider,
  x3 as EthosConnectProvider,
  i9 as EthosConnectStatus,
  IntentScope,
  C7 as SignInButton,
  TransactionBlock,
  F3 as ethos,
  verifyMessage
};
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@babel/runtime/helpers/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

store2/dist/store2.js:
  (*! store2 - v2.14.2 - 2022-07-18
  * Copyright (c) 2022 Nathan Bubna; Licensed (MIT OR GPL-3.0) *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=ethos-connect.js.map
